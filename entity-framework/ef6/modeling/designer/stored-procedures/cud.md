---
title: Конструктор-хранимые процедуры CUD — EF6
description: Конструктор CUD хранимые процедуры в Entity Framework 6
author: ajcvickers
ms.date: 10/23/2016
uid: ef6/modeling/designer/stored-procedures/cud
ms.openlocfilehash: 167504d3abbd156f426c481c410a1953bc047de4
ms.sourcegitcommit: 0a25c03fa65ae6e0e0e3f66bac48d59eceb96a5a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/14/2020
ms.locfileid: "92066126"
---
# <a name="designer-cud-stored-procedures"></a>Конструктор хранимых процедур CUD

В этом пошаговом руководстве показано, как сопоставлять \\ операции создания операций вставки, обновления и удаления (CUD) типа сущности с хранимыми процедурами с помощью Entity Framework Designer (EF Designer). По умолчанию Entity Framework автоматически создает инструкции SQL для операций CUD, но можно также сопоставлять хранимые процедуры с этими операциями.  

Обратите внимание, что Code First не поддерживает сопоставление с хранимыми процедурами или функциями. Однако можно вызывать хранимые процедуры или функции с помощью метода System. Data. Entity. DbSet. SqlQuery. Например.

``` csharp
var query = context.Products.SqlQuery("EXECUTE [dbo].[GetAllProducts]");
```

## <a name="considerations-when-mapping-the-cud-operations-to-stored-procedures"></a>Рекомендации по сопоставлению операций CUD с хранимыми процедурами

При сопоставлении операций CUD с хранимыми процедурами применяются следующие соображения.

- При сопоставлении одной из операций CUD с хранимой процедурой сопоставьте все эти операции. Если не выполнить сопоставление всех трех, несопоставленные операции завершатся неудачей, если **UpdateException**   они будут выполнены и будет создано исключение упдатиксцептион.
- Необходимо сопоставлять каждый параметр хранимой процедуры со свойствами сущности.
- Если сервер создает значение первичного ключа для вставленной строки, необходимо преобразовать это значение обратно в свойство ключа сущности. В приведенном ниже примере **InsertPerson**   хранимая процедура инсертперсон Возвращает созданный первичный ключ как часть результирующего набора хранимой процедуры. Первичный ключ сопоставляется с ключом сущности (**PersonID**) с помощью функции ** &lt; добавления &gt; результатов привязки**в   конструкторе EF.
- Вызовы хранимых процедур сопоставляются с сущностями в концептуальной модели 1:1. Например, если в концептуальной модели реализуется иерархия наследования, а затем сопоставляются хранимые процедуры CUD **для родительских** (базовых) **и дочерних** (производных) сущностей, сохранение **дочерних** изменений приведет к вызову только хранимых процедур **дочернего**класса, а вызовы хранимых процедур **родительского**объекта не будут вызываться.

## <a name="prerequisites"></a>Предварительные требования

Для выполнения данного пошагового руководства требуется:

- Последняя версия Visual Studio.
- [Образец базы данных School](xref:ef6/resources/school-database).

## <a name="set-up-the-project"></a>Настройка проекта

- Откройте Visual Studio 2012.
- Выбор **файла- &gt; создать- &gt; проект**
- В левой области щелкните **Visual C \# **, а затем выберите шаблон **консоли** .
- Введите **кудспрокссампле**в   качестве имени.
- Выберите **OK**.

## <a name="create-a-model"></a>Создание модели

- Щелкните правой кнопкой мыши имя проекта в обозреватель решений и выберите **Добавить- &gt; новый элемент**.
- Выберите **данные** в меню слева, а затем выберите **ADO.NET EDM** в области Шаблоны.
- Введите **кудспрокс. EDMX** в поле имя файла и нажмите кнопку **Добавить**.
- В диалоговом окне Выбор содержимого модели выберите пункт **создать из базы данных**, а затем нажмите кнопку **Далее**.
- Нажмите кнопку **создать соединение**. В диалоговом окне Свойства соединения введите имя сервера (например, **(LocalDB) \\ mssqllocaldb**), выберите метод проверки подлинности, введите **School**   в качестве имени базы данных и нажмите кнопку **ОК**.
    В диалоговом окне Выбор подключения к данным будет обновлен параметр подключения к базе данных.
- В диалоговом окне Выбор объектов базы данных в узле **таблицы**   выберите таблицу **Person** .
- Кроме того, выберите следующие хранимые процедуры в узле **хранимые процедуры и функции** : **делетеперсон**, **инсертперсон**и **упдатеперсон**.
- Начиная с Visual Studio 2012 конструктор EF поддерживает неполное импортирование хранимых процедур. По умолчанию флажок **Импорт выбранных хранимых процедур и функций в сущностную модель** установлен. Поскольку в этом примере у нас есть хранимые процедуры для вставки, обновления и удаления типов сущностей, мы не хотим импортировать их и снять этот флажок.

    ![Процедуры импорта S](~/ef6/media/importsprocs.jpg)

- Нажмите кнопку **Готово**.
    Отобразится конструктор EF, предоставляющий область конструктора для редактирования модели.

## <a name="map-the-person-entity-to-stored-procedures"></a>Сопоставьте сущность Person с хранимыми процедурами

- Щелкните правой кнопкой мыши **Person**   тип сущности Person и выберите **сопоставление хранимых процедур**.
- Сопоставления хранимых процедур отображаются в окне **сведения о сопоставлении**   .
- Нажмите кнопку ** &lt; выбрать команду &gt; Вставить функцию**.
    Поле становится раскрывающимся списком хранимых процедур в модели хранения, которые могут быть сопоставлены с типами сущностей в концептуальной модели.
    Выберите **инсертперсон**   из раскрывающегося списка.
- Появятся применяемые по умолчанию сопоставления параметров хранимой процедуры со свойствами сущности. Обратите внимание, что стрелки указывают направление сопоставления: «Значения свойств передаются параметрам хранимой процедуры».
- Нажмите кнопку ** &lt; Добавить привязку &gt; к результату**.
- Введите **невперсонид**, имя параметра, возвращаемого **InsertPerson**   хранимой процедурой инсертперсон. Убедитесь, что не вводите начальные или конечные пробелы.
- Нажмите клавишу **Ввод**.
- По умолчанию **невперсонид**   сопоставляется с ключом сущности **PersonID**. Обратите внимание, что стрелка указывает направление сопоставления — значение столбца результата передается свойству.

    ![Сведения о сопоставлении](~/ef6/media/mappingdetails.png)

- Щелкните ** &lt; выбрать обновление функции &gt; **   и выберите **упдатеперсон**в   раскрывающемся списке получено.
- Появятся применяемые по умолчанию сопоставления параметров хранимой процедуры со свойствами сущности.
- Щелкните ** &lt; выбрать Удалить функцию &gt; **   и выберите **делетеперсон**в   раскрывающемся списке получено.
- Появятся применяемые по умолчанию сопоставления параметров хранимой процедуры со свойствами сущности.

Операции вставки, обновления и удаления **Person**   типа сущности Person теперь сопоставлены с хранимыми процедурами.

Если необходимо включить проверку параллелизма при обновлении или удалении сущности с хранимыми процедурами, используйте один из следующих вариантов.

- Используйте **выходной** параметр, чтобы получить количество затронутых строк из хранимой процедуры и установить флажок **затронутые строки**   рядом с именем параметра. Если возвращаемое значение равно нулю при вызове операции,  [**OptimisticConcurrencyException**](https://msdn.microsoft.com/library/system.data.optimisticconcurrencyexception.aspx)   будет создано исключение оптимистикконкурренциексцептион.
- Установите флажок **использовать исходное значение** рядом со свойством, которое необходимо использовать для проверки параллелизма. При попытке обновления значение свойства, которое было первоначально считано из базы данных, будет использоваться при записи данных обратно в базу данных. Если значение не совпадает со значением в базе данных, **OptimisticConcurrencyException**   будет выдано исключение оптимистикконкурренциексцептион.

## <a name="use-the-model"></a>Использование модели

Откройте файл **Program.CS** , в котором определен метод **Main** . Добавьте следующий код в функцию main.

Код создает новый объект **Person** , затем обновляет объект и, наконец, удаляет объект.

``` csharp
    using (var context = new SchoolEntities())
    {
        var newInstructor = new Person
        {
            FirstName = "Robyn",
            LastName = "Martin",
            HireDate = DateTime.Now,
            Discriminator = "Instructor"
        }

        // Add the new object to the context.
        context.People.Add(newInstructor);

        Console.WriteLine("Added {0} {1} to the context.",
            newInstructor.FirstName, newInstructor.LastName);

        Console.WriteLine("Before SaveChanges, the PersonID is: {0}",
            newInstructor.PersonID);

        // SaveChanges will call the InsertPerson sproc.  
        // The PersonID property will be assigned the value
        // returned by the sproc.
        context.SaveChanges();

        Console.WriteLine("After SaveChanges, the PersonID is: {0}",
            newInstructor.PersonID);

        // Modify the object and call SaveChanges.
        // This time, the UpdatePerson will be called.
        newInstructor.FirstName = "Rachel";
        context.SaveChanges();

        // Remove the object from the context and call SaveChanges.
        // The DeletePerson sproc will be called.
        context.People.Remove(newInstructor);
        context.SaveChanges();

        Person deletedInstructor = context.People.
            Where(p => p.PersonID == newInstructor.PersonID).
            FirstOrDefault();

        if (deletedInstructor == null)
            Console.WriteLine("A person with PersonID {0} was deleted.",
                newInstructor.PersonID);
    }
```

- Скомпилируйте и запустите приложение. Программа выдает следующие выходные данные *

> [!NOTE]
> PersonID автоматически создается сервером, поэтому, скорее всего, будет отображаться другое число *

``` Output
Added Robyn Martin to the context.
Before SaveChanges, the PersonID is: 0
After SaveChanges, the PersonID is: 51
A person with PersonID 51 was deleted.
```

При работе с конечной версией Visual Studio можно использовать IntelliTrace с отладчиком для просмотра инструкций SQL, которые будут выполнены.

![Отладка с помощью IntelliTrace](~/ef6/media/intellitrace.png)
