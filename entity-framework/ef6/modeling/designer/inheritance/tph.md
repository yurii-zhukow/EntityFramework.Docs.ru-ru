---
title: Наследование конструктора с подиерархией — EF6
description: Наследование конструктора ИЕРАРХИй в Entity Framework 6
author: divega
ms.date: 10/23/2016
uid: ef6/modeling/designer/inheritance/tph
ms.openlocfilehash: 39675f9533dfef0ddad1867e3b70cd13b30708ea
ms.sourcegitcommit: abda0872f86eefeca191a9a11bfca976bc14468b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/14/2020
ms.locfileid: "90073400"
---
# <a name="designer-tph-inheritance"></a>Наследование конструктора с подиерархией
В этом пошаговом руководстве показано, как реализовать наследование "одна таблица на иерархию" в концептуальной модели с помощью Entity Framework Designer (конструктор EF). Наследование «подстановка» использует одну таблицу базы данных для сохранения данных всех типов сущностей в иерархии наследования.

В этом пошаговом руководстве мы сопоставлению таблицы Person с тремя типами сущностей: Person (базовый тип), Student (является производным от Person) и инструктором (от человека). Мы создадим концептуальную модель из базы данных (Database First), а затем изменим модель, чтобы реализовать наследование с помощью конструктора EF.

Можно сопоставляться с наследованием с помощью Model First, но вам пришлось бы написать собственный рабочий процесс создания базы данных, который является сложным. Затем этот рабочий процесс будет назначен свойству **рабочего процесса создания базы данных** в конструкторе EF. Более простой альтернативой является использование Code First.

## <a name="other-inheritance-options"></a>Другие параметры наследования

"Одна таблица на тип" (TPT) — это еще один тип наследования, в котором отдельные таблицы в базе данных сопоставляются с сущностями, участвующими в наследовании. Дополнительные сведения о сопоставлении наследования типа «таблица на тип» с помощью конструктора EF см. в разделе [TPT Designer EF наследование](xref:ef6/modeling/designer/inheritance/tpt).

Модель с принаследованием типа "Таблица — конкретная" (TPC) и смешанные модели наследования поддерживаются средой выполнения Entity Framework, но не поддерживаются конструктором EF. Если вы хотите использовать функции TPC или смешанное наследование, у вас есть два варианта: использовать Code First или вручную изменить файл EDMX. Если вы решили работать с файлом EDMX, окно сведения о сопоставлении будет переведено в "защищенный режим", и вы не сможете использовать конструктор для изменения сопоставлений.

## <a name="prerequisites"></a>Предварительные условия

Для выполнения данного пошагового руководства требуется:

- Последняя версия Visual Studio.
- [Образец базы данных School](xref:ef6/resources/school-database).

## <a name="set-up-the-project"></a>Настройка проекта

-   Откройте Visual Studio 2012.
-   Выбор **файла- &gt; создать- &gt; проект**
-   В левой области щелкните **Visual C \# **, а затем выберите шаблон **консоли** .
-   Введите **тфдбфирстсампле**в   качестве имени.
-   Выберите **OK**.

## <a name="create-a-model"></a>Создание модели

-   Щелкните правой кнопкой мыши имя проекта в обозреватель решений и выберите **Добавить- &gt; новый элемент**.
-   Выберите **данные** в меню слева, а затем выберите **ADO.NET EDM** в области Шаблоны.
-   Введите **тфмодел. EDMX** в поле имя файла и нажмите кнопку **Добавить**.
-   В диалоговом окне Выбор содержимого модели выберите пункт **создать из базы данных**, а затем нажмите кнопку **Далее**.
-   Нажмите кнопку **создать соединение**.
    В диалоговом окне Свойства соединения введите имя сервера (например, **(LocalDB) \\ mssqllocaldb**), выберите метод проверки подлинности, введите **School**   в качестве имени базы данных и нажмите кнопку **ОК**.
    В диалоговом окне Выбор подключения к данным будет обновлен параметр подключения к базе данных.
-   В диалоговом окне Выбор объектов базы данных в узле таблицы выберите таблицу **Person** .
-   Нажмите кнопку **Готово**.

Отобразится Entity Designer, предоставляющий область конструктора для редактирования модели. Все объекты, выбранные в диалоговом окне Выбор объектов базы данных, добавляются в модель.

Таким образом таблица **Person** будет выглядеть в базе данных.

![Таблица Person](~/ef6/media/persontable.png) 

## <a name="implement-table-per-hierarchy-inheritance"></a>Реализация наследования одной таблицы на иерархию

Таблица **Person** имеет столбец **дискриминатора** , который может иметь одно из двух значений: "Student" и "Instructor". В зависимости от значения Таблица **Person** будет сопоставлена с сущностью **Student** или с сущностью **Instructor** . Таблица **Person** также содержит два столбца, **HireDate**   и **енроллментдате**, которые должны **допускать значения NULL** , поскольку человек не может одновременно быть студентом и преподавателем (по крайней мере, в этом пошаговом руководстве).

### <a name="add-new-entities"></a>Добавить новые сущности

-   Добавьте новую сущность.
    Для этого щелкните правой кнопкой мыши пустое пространство в области конструктора Entity Framework Designer и выберите пункт **Добавить- &gt; сущность**.
-   Введите **Instructor**   в поле **имя сущности**   и выберите **Person**из раскрывающегося   списка для **базового типа**.
-   Нажмите кнопку **ОК**.
-   Добавьте еще одну новую сущность. Введите **Student**   в поле **имя сущности**   и выберите **Person**из раскрывающегося   списка для **базового типа**.

В область конструктора были добавлены два новых типа сущностей. Стрелка указывает от новых типов сущностей на тип сущности **Person**   ; это означает, что **пользователь**   является базовым типом для новых типов сущностей.

-   Щелкните правой кнопкой мыши свойство **HireDate**   сущности **Person**   . Выберите **Вырезать** (или используйте клавишу CTRL + X).
-   Щелкните сущность **Instructor**правой кнопкой мыши   и выберите команду **Вставить** (или используйте клавишу CTRL + V).
-   Щелкните правой кнопкой мыши свойство **HireDate**   и выберите пункт **Свойства**.
-   В окне **Свойства**   присвойте свойству **Nullable**значение    **false**.
-   Щелкните правой кнопкой мыши свойство **енроллментдате**   сущности **Person**   . Выберите **Вырезать** (или используйте клавишу CTRL + X).
-   Щелкните сущность **Student** правой кнопкой мыши и выберите команду **Вставить (или используйте клавишу CTRL + V).**
-   Выберите свойство **енроллментдате**   и присвойте **Nullable**   свойству Nullable значение **false**.
-   Выберите **Person**   тип сущности Person. В окне **Свойства**   задайте **Abstract**   для свойства abstract значение **true**.
-   Удалите свойство **дискриминатора** из **Person**. Причина его удаления объясняется в следующем разделе.

### <a name="map-the-entities"></a>Сопоставьте сущности

-   Щелкните **лектора** правой кнопкой мыши и выберите пункт **Сопоставление таблиц.**
    Сущность Instructor выбирается в окне сведения о сопоставлении.
-   Нажмите кнопку ** &lt; Добавить таблицу или представление &gt; **   в окне **сведения о сопоставлении**   .
    Поле ** &lt; Добавить таблицу или представление &gt; **преобразуется в раскрывающийся   список таблиц или представлений, к которым можно сопоставить выбранную сущность.
-   Выберите **Person**из раскрывающегося   списка.
-   В окне **сведения о сопоставлении**   обновляется сопоставление столбцов по умолчанию и параметр для добавления условия.
-   Щелкните ** &lt; Добавить условие &gt; **.
    Поле ** &lt; Добавить условие &gt; **преобразуется в раскрывающийся   список столбцов, для которых можно задать условия.
-   Выберите **Дискриминатор**   из раскрывающегося списка.
-   В столбце **оператор**   окна **сведения о сопоставлении**   выберите значение = из раскрывающегося списка.
-   В столбце **значение/свойство** введите **Instructor**. Конечный результат должен выглядеть следующим образом:

    ![Сведения о сопоставлении](~/ef6/media/mappingdetails2.png)

-   Повторите эти шаги для **Student**   типа сущности Student, но сделайте условие равным значению **Student** .  
    *Причина, по которой мы хотели удалить свойство **дискриминатора** , заключается в том, что нельзя сопоставлять столбец таблицы более одного раза. Этот столбец будет использоваться для условного сопоставления, поэтому его нельзя использовать для сопоставления свойств. Единственный способ, который можно использовать для обоих, если в условии используется сравнение со **значением NULL**   или не равно **null**   .*

Теперь наследование типа «одна таблица на иерархию» успешно реализовано.

![Окончательная подтаблица](~/ef6/media/finaltph.png)

## <a name="use-the-model"></a>Использование модели

Откройте файл **Program.CS** , в котором определен метод **Main** . Вставьте следующий код в функцию **Main** . Код выполняет три запроса. Первый запрос возвращает все объекты **Person** . Второй запрос использует метод **OFTYPE** для возврата объектов **инструктора** . Третий запрос использует метод **OFTYPE** для возвращения объектов **Student** .

``` csharp
    using (var context = new SchoolEntities())
    {
        Console.WriteLine("All people:");
        foreach (var person in context.People)
        {
            Console.WriteLine("    {0} {1}", person.FirstName, person.LastName);
        }

        Console.WriteLine("Instructors only: ");
        foreach (var person in context.People.OfType<Instructor>())
        {
            Console.WriteLine("    {0} {1}", person.FirstName, person.LastName);
        }

        Console.WriteLine("Students only: ");
        foreach (var person in context.People.OfType<Student>())
        {
            Console.WriteLine("    {0} {1}", person.FirstName, person.LastName);
        }
    }
```
