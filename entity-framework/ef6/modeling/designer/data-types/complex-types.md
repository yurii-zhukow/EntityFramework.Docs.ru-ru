---
title: Сложные типы — конструктор EF — EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 9a8228ef-acfd-4575-860d-769d2c0e18a1
ms.openlocfilehash: a3c5578acee23688c04772d2dd0a2221779af562
ms.sourcegitcommit: cc0ff36e46e9ed3527638f7208000e8521faef2e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78415427"
---
# <a name="complex-types---ef-designer"></a>Сложные типы — конструктор EF
В этом разделе показано, как сопоставлять сложные типы с Entity Framework Designer (конструктор EF) и как выполнять запросы сущностей, содержащих свойства сложного типа.

На следующем рисунке показаны основные окна, используемые при работе с конструктором EF.

![Конструктор EF](~/ef6/media/efdesigner.png)

> [!NOTE]
> При построении концептуальной модели в окне Список ошибок могут появиться предупреждения о несопоставленных сущностях и ассоциациях. Эти предупреждения можно игнорировать, так как после выбора создания базы данных из модели ошибки будут исчезнуть.

## <a name="what-is-a-complex-type"></a>Что такое сложный тип

Сложные типы — это нескалярные свойства типов сущности, которые позволяют организовать в сущностях скалярные свойства. Подобно сущностям, сложные типы состоят из скалярных свойств или свойств других сложных типов.

При работе с объектами, представляющими сложные типы, учитывайте следующее:

-   Сложные типы не имеют ключей и поэтому не могут существовать независимо друг от друга. Сложные типы могут существовать только как свойства типов сущностей или других сложных типов.
-   Сложные типы не могут участвовать в связях и не могут содержать свойства навигации.
-   Свойства сложного типа не могут иметь **значение NULL**. Исключение **InvalidOperationException **возникает при вызове **DbContext. SaveChanges** и обнаружении сложного объекта со значением NULL. Скалярные свойства сложных объектов могут иметь **значение NULL**.
-   Сложные типы не могут наследоваться от других сложных типов.
-   Сложный тип необходимо определить как **класс**. 
-   EF обнаруживает изменения элементов в объекте сложного типа при вызове **DbContext. DetectChanges** . Entity Framework автоматически вызывает **DetectChanges** при вызове следующих членов: **DbSet. Find**, **DbSet. local**, **DbSet. Remove**, **DbSet. Add**, **DbSet. Attach**, **DbContext. SaveChanges**, **DbContext. жетвалидатионеррорс**, **DbContext. Entry**, **дбчанжетраккер.** ALL.

## <a name="refactor-an-entitys-properties-into-new-complex-type"></a>Рефакторинг свойств сущности в новый сложный тип

Если у вас уже есть сущность в концептуальной модели, может потребоваться рефакторинг некоторых свойств в свойство сложного типа.

В области конструктора выберите одно или несколько свойств (за исключением свойств навигации) сущности, щелкните правой кнопкой мыши и выберите **Рефакторинг —&gt; переместить в новый сложный тип**.

![Рефакторинг](~/ef6/media/refactor.png)

Новый сложный тип с выбранными свойствами добавляется в **Обозреватель моделей**. Сложному типу присваивается имя по умолчанию.

Сложное свойство только что созданного типа заменит выбранные свойства. Все сопоставления свойств будут сохранены.

![Рефакторинг 2](~/ef6/media/refactor2.png)

## <a name="create-a-new-complex-type"></a>Создание нового сложного типа

Можно также создать новый сложный тип, который не содержит свойств существующей сущности.

Щелкните правой кнопкой мыши папку **Составные типы** в обозревателе моделей и выберите команду **AddNew сложный тип.** . Кроме того, можно выбрать папку **сложных типов** и нажать клавишу **INSERT** на клавиатуре.

![Добавить новый сложный тип](~/ef6/media/addnewcomplextype.png)

Новый сложный тип будет добавлен в папку с именем по умолчанию. Теперь в тип можно добавлять свойства.

## <a name="add-properties-to-a-complex-type"></a>Добавление свойств в сложный тип

Свойства сложного типа могут иметь как скалярные, так и существующие сложные типы. Однако свойства сложного типа не могут иметь циклических ссылок. Например, сложный тип **онситекаурседетаилс** не может иметь свойство сложного типа **онситекаурседетаилс**.

Добавить свойство к сложному типу можно любым из следующих способов.

-   В обозревателе моделей щелкните правой кнопкой мыши сложный тип, наведите указатель на пункт **Добавить**, укажите **скалярное свойство** или **сложное свойство**, а затем выберите нужный тип свойства. Кроме того, можно выбрать сложный тип и нажать клавишу **Insert** на клавиатуре.  

    ![Добавить свойства в сложный тип](~/ef6/media/addpropertiestocomplextype.png)

    Новое свойство будет добавлено к сложному типу с именем по умолчанию.

- OR -

-   Щелкните правой кнопкой мыши свойство сущности в области **конструктора EF** и выберите **Копировать**, затем щелкните правой кнопкой мыши сложный тип в **обозревателе моделей** и выберите команду **Вставить**.

## <a name="rename-a-complex-type"></a>Переименование сложного типа

При переименовании сложного типа все ссылки на тип обновляются по всему проекту.

-   Медленно дважды щелкните сложный тип в **обозревателе моделей**.
    Имя будет выбрано в режиме редактирования.

- OR -

-   Щелкните правой кнопкой мыши сложный тип в **обозревателе моделей** и выберите команду **Переименовать**.

- OR -

-   Выберите сложный тип в браузере моделей и нажмите клавишу F2.

- OR -

-   Щелкните правой кнопкой мыши сложный тип в **обозревателе моделей** и выберите пункт **свойства**. Измените имя в окне **свойства** .

## <a name="add-an-existing-complex-type-to-an-entity-and-map-its-properties-to-table-columns"></a>Добавьте существующий сложный тип в сущность и сопоставьте его свойства со столбцами таблицы.

1.  Щелкните сущность правой кнопкой мыши, наведите указатель на пункт **Добавить новый**и выберите пункт **сложное свойство**.
    Свойство сложного типа с именем по умолчанию будет добавлено к сущности. Свойству назначается тип по умолчанию (выбранный из имеющихся сложных типов).
2.  Назначьте требуемый тип свойству в окне " **свойства** ".
    После добавления свойства сложного типа к сущности необходимо сопоставить ее свойства со столбцами таблицы.
3.  Щелкните правой кнопкой мыши тип сущности в области конструктора или в **обозревателе моделей** и выберите **сопоставления таблиц**.
    Сопоставления таблиц отображаются в окне **сведения о Сопоставлении** .
4.  Разверните **карты, чтобы &lt;имя таблицы&gt;**  узле.
    Появится **сопоставление столбцов** узле.
5.  Разверните элемент **сопоставления столбцов** узле.
    Появится список всех столбцов таблицы. Свойства по умолчанию (если таковые имеются), к которым соответствует таблица Columns, перечислены под заголовком **значение или свойство** .
6.  Выберите столбец, который необходимо соотнести, и щелкните правой кнопкой мыши соответствующее поле **значения или свойства** .
    Отобразится раскрывающийся список всех скалярных свойств.
7.  Выберите соответствующее свойство.

    ![Составной тип Map](~/ef6/media/mapcomplextype.png)

8.  Повторите шаги 6 и 7 для каждого столбца таблицы.

>[!NOTE]
> Чтобы удалить сопоставление столбцов, выберите столбец, который необходимо сопоставить, а затем щелкните поле **значение или свойство** . Затем в раскрывающемся списке выберите **Удалить** .

## <a name="map-a-function-import-to-a-complex-type"></a>Преобразование импорта функции в сложный тип

Импорт функций основан на хранимых процедурах. Чтобы сопоставить импорт со сложным типом, столбцы, возвращаемые соответствующей хранимой процедурой, должны соответствовать свойствам сложного типа по числу и должны иметь типы хранения, совместимые с типами свойств.

-   Дважды щелкните импортированную функцию, которая должна быть сопоставлена с сложным типом.

    ![Импорты функций](~/ef6/media/functionimports.png)

-   Задайте параметры для нового импорта функции следующим образом.
    -   Укажите хранимую процедуру, для которой вы создаете импорт функции, в поле **имя хранимой процедуры** . Это поле представляет собой раскрывающийся список, содержащий все хранимые процедуры, которые имеются в модели хранения.
    -   Укажите имя импорта функции в поле **имя импорта функции** .
    -   Выберите **сложный** в качестве типа возвращаемого значения, а затем укажите конкретный сложный тип возвращаемого значения, выбрав соответствующий тип из раскрывающегося списка.

        ![Изменить импорт функции](~/ef6/media/editfunctionimport.png)

-   Нажмите кнопку **ОК**.
    В концептуальной модели создается запись импорта функции.

### <a name="customize-column-mapping-for-function-import"></a>Настройка сопоставления столбцов для импорта функции

-   Щелкните правой кнопкой мыши импорт функции в обозревателе моделей и выберите **Сопоставление импорта функций**.
    Откроется окно **сведения о Сопоставлении** и отобразится сопоставление по умолчанию для импорта функции. Стрелки указывают сопоставления между значениями столбцов и значениями свойств. По умолчанию предполагается, что имена столбцов совпадают с именами свойств сложного типа. Имена столбцов по умолчанию отображаются серым текстом.
-   Если необходимо, измените имена столбцов таким образом, чтобы они совпадали с именами столбцов, возвращаемых хранимой процедурой, соответствующей импорту функции.

## <a name="delete-a-complex-type"></a>Удаление сложного типа

При удалении сложного типа он удаляется из концептуальной модели. Кроме того, удаляются сопоставления для всех экземпляров типа. Однако ссылки на тип не обновляются. Например, если сущность имеет свойство сложного типа типа ComplexType1 и ComplexType1 удаляется в **обозревателе моделей**, соответствующее свойство сущности не обновляется. Модель не будет проверена, так как она содержит сущность, ссылающуюся на удаленный сложный тип. Обновить или удалить ссылки на удаленные сложные типы можно с помощью конструктора сущностей.

-   Щелкните в обозревателе моделей правой кнопкой мыши сложный тип и выберите пункт **Удалить**.

- OR -

-   В браузере моделей выберите сложный тип и нажмите на клавиатуре клавишу DELETE.

## <a name="query-for-entities-containing-properties-of-complex-type"></a>Запрос сущностей, содержащих свойства сложного типа

В следующем коде показано, как выполнить запрос, возвращающий коллекцию объектов типа сущности, содержащих свойство сложного типа.

``` csharp
    using (SchoolEntities context = new SchoolEntities())
    {
        var courses =
            from c in context.OnsiteCourses
            order by c.Details.Time
            select c;

        foreach (var c in courses)
        {
            Console.WriteLine("Time: " + c.Details.Time);
            Console.WriteLine("Days: " + c.Details.Days);
            Console.WriteLine("Location: " + c.Details.Location);
        }
    }
```
