---
title: Заметки к данным Code First — EF6
description: Code First заметок к данным в Entity Framework 6
author: divega
ms.date: 10/23/2016
uid: ef6/modeling/code-first/data-annotations
ms.openlocfilehash: dd91ddf674f2235190e50beb847e569a898ad59b
ms.sourcegitcommit: abda0872f86eefeca191a9a11bfca976bc14468b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/14/2020
ms.locfileid: "90074068"
---
# <a name="code-first-data-annotations"></a>Заметки к данным Code First
> [!NOTE]
> **EF 4.1 только в сторону** — функции, API и т. д., обсуждаемые на этой странице, появились в Entity Framework 4,1. Если вы используете более раннюю версию, некоторые или все эти сведения не применяются.

Содержимое этой страницы адаптируется из статьи, первоначально написанной Джулия Лерман ( \<http://thedatafarm.com> ).

Entity Framework Code First позволяет использовать собственные доменные классы для представления модели, которую использует EF для выполнения запросов, отслеживания изменений и обновления функций. Code First использует шаблон программирования, называемый "соглашение по конфигурации". Code First предполагает, что классы соответствуют соглашениям Entity Framework, и в этом случае автоматически выполнит действия по выполнению своей работы. Однако если ваши классы не соответствуют этим соглашениям, вы можете добавлять конфигурации в классы для предоставления EF с информацией о необходимых параметрах.

Code First предоставляет два способа добавления этих конфигураций в классы. В одном из них используются простые атрибуты, называемые заметками, а во второй — API-интерфейс Fluent Code First, который предоставляет способ описания конфигураций императивно в коде.

В этой статье основное внимание уделяется использованию аннотаций (в пространстве имен System. ComponentModel. заметок к данным) для настройки классов: выделение наиболее часто используемых конфигураций. Аннотации данных также понятны в ряде приложений .NET, таких как ASP.NET MVC, что позволяет этим приложениям использовать те же заметки для проверок на стороне клиента.


## <a name="the-model"></a>Модель

Я продемонстрирую Code First аннотации с помощью простой пары классов: blog и POST.

``` csharp
    public class Blog
    {
        public int Id { get; set; }
        public string Title { get; set; }
        public string BloggerName { get; set;}
        public virtual ICollection<Post> Posts { get; set; }
    }

    public class Post
    {
        public int Id { get; set; }
        public string Title { get; set; }
        public DateTime DateCreated { get; set; }
        public string Content { get; set; }
        public int BlogId { get; set; }
        public ICollection<Comment> Comments { get; set; }
    }
```

Как и в случае, классы блога и POST посвящены первому соглашению о коде и не нуждаются в корректировках для включения совместимости с EF. Однако заметки также можно использовать для предоставления в EF дополнительных сведений о классах и базе данных, с которой они сопоставляются.

 

## <a name="key"></a>Key

Entity Framework полагается на каждую сущность, имеющую значение ключа, используемое для отслеживания сущностей. Одно из соглашений Code First является неявными свойствами ключа; Code First будет искать свойство с именем "ID" или сочетание имени класса и "ID", например "Блогид". Это свойство будет сопоставляться с первичным ключевым столбцом в базе данных.

Классы blog и POST соответствуют этому соглашению. Что делать, если это не так? Что если в блоге использовалось имя *примаритраккингкэй* вместо или даже *foo*? Если код сначала не находит свойство, которое соответствует этому соглашению, это вызовет исключение из-за того, что Entity Framework требуется ключевое свойство. Можно использовать ключевую аннотацию, чтобы указать, какое свойство будет использоваться в качестве EntityKey.

``` csharp
    public class Blog
    {
        [Key]
        public int PrimaryTrackingKey { get; set; }
        public string Title { get; set; }
        public string BloggerName { get; set;}
        public virtual ICollection<Post> Posts { get; set; }
    }
```

Если вы используете функцию создания базы данных в первую очередь, таблица блога будет иметь первичный ключевой столбец с именем Примаритраккингкэй, который также определен как Identity по умолчанию.

![Таблица блога с первичным ключом](~/ef6/media/jj591583-figure01.png)

### <a name="composite-keys"></a>Составные ключи

Entity Framework поддерживает составные ключи — Первичные ключи, состоящие более чем из одного свойства. Например, у вас может быть класс Passport, первичный ключ которого является сочетанием Пасспортнумбер и Иссуингкаунтри.

``` csharp
    public class Passport
    {
        [Key]
        public int PassportNumber { get; set; }
        [Key]
        public string IssuingCountry { get; set; }
        public DateTime Issued { get; set; }
        public DateTime Expires { get; set; }
    }
```

Попытка использовать приведенный выше класс в модели EF приведет к `InvalidOperationException` следующим результатам:

*Не удалось определить порядок составного первичного ключа для типа "паспорт". Используйте метод Колумнаттрибуте или HasKey, чтобы указать порядок для составных первичных ключей.*

Чтобы использовать составные ключи, Entity Framework необходимо определить порядок для ключевых свойств. Это можно сделать, используя заметку столбца для указания порядка.

>[!NOTE]
> Значение порядка является относительным (а не основанным на индексе), чтобы можно было использовать любые значения. Например, 100 и 200 будут приемлемыми вместо 1 и 2.

``` csharp
    public class Passport
    {
        [Key]
        [Column(Order=1)]
        public int PassportNumber { get; set; }
        [Key]
        [Column(Order = 2)]
        public string IssuingCountry { get; set; }
        public DateTime Issued { get; set; }
        public DateTime Expires { get; set; }
    }
```

При наличии сущностей с составными внешними ключами необходимо указать тот же порядок столбцов, который использовался для соответствующих свойств первичного ключа.

Только относительный порядок в свойствах внешнего ключа должен быть одинаковым, точные значения, назначенные **заказу** , не должны совпадать. Например, в следующем классе можно использовать 3 и 4 вместо 1 и 2.

``` csharp
    public class PassportStamp
    {
        [Key]
        public int StampId { get; set; }
        public DateTime Stamped { get; set; }
        public string StampingCountry { get; set; }

        [ForeignKey("Passport")]
        [Column(Order = 1)]
        public int PassportNumber { get; set; }

        [ForeignKey("Passport")]
        [Column(Order = 2)]
        public string IssuingCountry { get; set; }

        public Passport Passport { get; set; }
    }
```

## <a name="required"></a>Обязательно

`Required`Заметка сообщает EF, что требуется определенное свойство.

Добавление, обязательное к свойству Title, заставит EF (и MVC) убедиться, что свойство содержит данные.

``` csharp
    [Required]
    public string Title { get; set; }
```

При отсутствии в приложении дополнительного кода или изменений разметки приложение MVC выполняет проверку на стороне клиента, даже динамически создавая сообщение, используя имена свойств и заметок.

![Ошибка при создании страницы с заголовком](~/ef6/media/jj591583-figure02.png)

Обязательный атрибут также влияет на созданную базу данных, делая сопоставленное свойство не допускающим значение null. Обратите внимание, что поле заголовка изменено на «NOT NULL».

>[!NOTE]
> В некоторых случаях для столбца в базе данных может оказаться невозможным значение null, даже если свойство является обязательным. Например, при использовании ИЕРАРХИческих данных стратегии наследования для нескольких типов хранится в одной таблице. Если производный тип содержит обязательное свойство, столбец не может быть сделан пустым, так как не все типы в иерархии будут иметь это свойство.

 

![Таблица блогов](~/ef6/media/jj591583-figure03.png)

 

## <a name="maxlength-and-minlength"></a>MaxLength и MinLength

`MaxLength`Атрибуты и `MinLength` позволяют указать дополнительные проверки свойств так же, как и в случае с `Required` .

Ниже приведены Блогжернаме требования к длине. В примере также показано, как комбинировать атрибуты.

``` csharp
    [MaxLength(10),MinLength(5)]
    public string BloggerName { get; set; }
```

Аннотация MaxLength повлияет на базу данных, устанавливая для свойства длину значение 10.

![Таблица блогов, в которой отображается максимальная длина столбца Блогжернаме](~/ef6/media/jj591583-figure04.png)

В аннотации на стороне клиента MVC и на стороне сервера EF 4,1 будет выполняться проверка, а также динамическое создание сообщения об ошибке: "поле Блогжернаме должно быть строкой или типом массива с максимальной длиной" 10 ". Это сообщение имеет небольшой формат. Многие аннотации позволяют указать сообщение об ошибке с атрибутом ErrorMessage.

``` csharp
    [MaxLength(10, ErrorMessage="BloggerName must be 10 characters or less"),MinLength(5)]
    public string BloggerName { get; set; }
```

Можно также указать ErrorMessage в требуемой аннотации.

![Страница создания с настраиваемым сообщением об ошибке](~/ef6/media/jj591583-figure05.png)

 

## <a name="notmapped"></a>нотмаппед

Первое соглашение Code определяет, что каждое свойство, имеющее поддерживаемый тип данных, представлено в базе данных. Но это не всегда так в приложениях. Например, в классе блога может быть свойство, которое создает код на основе полей Title и Блогжернаме. Это свойство может быть создано динамически и не должно сохраняться. Можно пометить все свойства, которые не сопоставляются с базой данных, с аннотацией Нотмаппед, например с этим свойством Блогкоде.

``` csharp
    [NotMapped]
    public string BlogCode
    {
        get
        {
            return Title.Substring(0, 1) + ":" + BloggerName.Substring(0, 1);
        }
    }
```

 

## <a name="complextype"></a>ComplexType

Нередко описать сущности предметной области в наборе классов, а затем послойировать эти классы для описания готовой сущности. Например, в модель можно добавить класс с именем Блогдетаилс.

``` csharp
    public class BlogDetails
    {
        public DateTime? DateCreated { get; set; }

        [MaxLength(250)]
        public string Description { get; set; }
    }
```

Обратите внимание, что не `BlogDetails` имеет какого либо типа ключевого свойства. При проектировании на основе домена `BlogDetails` называется объектом значения. Entity Framework относится к объектам значений как к сложным типам.Сложные типы не могут быть записаны самостоятельно.

Однако, как свойство в `Blog` классе, `BlogDetails` будет относиться к объекту в виде части `Blog` объекта. Чтобы код сначала распознал это, необходимо пометить `BlogDetails` класс как `ComplexType` .

``` csharp
    [ComplexType]
    public class BlogDetails
    {
        public DateTime? DateCreated { get; set; }

        [MaxLength(250)]
        public string Description { get; set; }
    }
```

Теперь можно добавить свойство в `Blog` класс для представления `BlogDetails` для этого блога.

``` csharp
        public BlogDetails BlogDetail { get; set; }
```

В базе данных `Blog` таблица будет содержать все свойства блога, включая свойства, содержащиеся в его `BlogDetail` свойстве. По умолчанию каждому из них предшествуют имя сложного типа «Блогдетаил».

![Таблица блога со сложным типом](~/ef6/media/jj591583-figure06.png)


## <a name="concurrencycheck"></a>ConcurrencyCheck

`ConcurrencyCheck`Заметка позволяет пометить одно или несколько свойств, которые будут использоваться для проверки параллелизма в базе данных, когда пользователь редактирует или удаляет сущность. Если вы работали с конструктором EF, то при этом выполняется сопоставление с установкой свойства в значение `ConcurrencyMode` `Fixed` .

Давайте посмотрим, как `ConcurrencyCheck` работает, добавив его в `BloggerName` свойство.

``` csharp
    [ConcurrencyCheck, MaxLength(10, ErrorMessage="BloggerName must be 10 characters or less"),MinLength(5)]
    public string BloggerName { get; set; }
```

При `SaveChanges` вызове метода из-за `ConcurrencyCheck` аннотации `BloggerName` поля исходное значение этого свойства будет использоваться в обновлении. Команда попытается выбрать правильную строку, отфильтровывая не только значение ключа, но и исходное значение `BloggerName` .Ниже приведены критические части команды UPDATE, отправленной в базу данных, на которой можно увидеть, что команда обновит строку, имеющую значение, `PrimaryTrackingKey` равную 1, и значение `BloggerName` «Юлия», которое было исходным значением при извлечении этого блога из базы данных.

``` SQL
    where (([PrimaryTrackingKey] = @4) and ([BloggerName] = @5))
    @4=1,@5=N'Julie'
```

Если кто-то изменил имя блоггера для этого блога, это обновление завершится ошибкой, и вы получите **дбупдатеконкурренциексцептион** , который вам потребуется справиться.

 

## <a name="timestamp"></a>TimeStamp

Чаще всего для проверки параллелизма используются поля rowversion или timestamp. Но вместо использования `ConcurrencyCheck` аннотации можно использовать более конкретную `TimeStamp` аннотацию, если тип свойства — байтовый массив. Code First будет рассматривать `Timestamp` свойства так же `ConcurrencyCheck` , как свойства, но также гарантирует, что поле базы данных, которое создает код, не допускает значения NULL. В данном классе может быть только одно свойство timestamp.

Добавление следующего свойства в класс Blog:

``` csharp
    [Timestamp]
    public Byte[] TimeStamp { get; set; }
```

в коде сначала создается столбец метки времени, не допускающий значения NULL, в таблице базы данных.

![Таблица блогов со столбцом временной метки](~/ef6/media/jj591583-figure07.png)

 

## <a name="table-and-column"></a>Таблица и столбец

Если вы разрешаете Code First создать базу данных, может потребоваться изменить имя создаваемых таблиц и столбцов. Можно также использовать Code First с существующей базой данных. Но в этом случае имена классов и свойств в домене не всегда совпадают с именами таблиц и столбцов в базе данных.

Мой класс имеет имя `Blog` и по соглашению, код First предполагает, что это будет сопоставляться с таблицей с именем `Blogs` . Если это не так, можно указать имя таблицы с `Table` атрибутом. Например, заметка указывает, что имя таблицы — **интерналблогс**.

``` csharp
    [Table("InternalBlogs")]
    public class Blog
```

`Column`Заметка является более умелыми при указании атрибутов сопоставленного столбца. Можно указать имя, тип данных или даже порядок, в котором столбец отображается в таблице. Ниже приведен пример `Column` атрибута.

``` csharp
    [Column("BlogDescription", TypeName="ntext")]
    public String Description {get;set;}
```

Не путайте атрибут столбца `TypeName` с аннотацией DataType. DataType — это заметка, используемая в пользовательском интерфейсе и игнорируемая Code First.

Ниже приведена таблица, созданная после повторного создания. Имя таблицы изменилось на **интерналблогс** , а `Description` столбец из сложного типа теперь имеет значение `BlogDescription` . Поскольку имя было указано в аннотации, код First не будет использовать соглашение о начале имени столбца с именем сложного типа.

![Таблица и столбец блогов переименованы](~/ef6/media/jj591583-figure08.png)

 

## <a name="databasegenerated"></a>датабасеженератед

Важным компонентом базы данных является возможность иметь вычисленные свойства. При сопоставлении классов Code First с таблицами, содержащими вычисленные столбцы, не нужно Entity Framework пытаться обновить эти столбцы. Однако необходимо, чтобы EF возвращал эти значения из базы данных после вставки или обновления данных. Заметку можно использовать `DatabaseGenerated` для пометки этих свойств в классе вместе с `Computed` перечислением. Другие перечисления — `None` и `Identity` .

``` csharp
    [DatabaseGenerated(DatabaseGeneratedOption.Computed)]
    public DateTime DateCreated { get; set; }
```

Базу данных, созданную для столбцов типа Byte или timestamp, можно использовать при первом создании базы данных с помощью Code. в противном случае ее следует использовать только при указании существующих баз данных, так как код сначала не сможет определить формулу для вычисляемого столбца.

По умолчанию, ключевое свойство, которое является целым числом, станет ключом удостоверения в базе данных. Это будет то же самое, что и параметр `DatabaseGenerated` `DatabaseGeneratedOption.Identity` . Если вы не хотите, чтобы он был ключом удостоверения, можно задать значение `DatabaseGeneratedOption.None` .

 

## <a name="index"></a>Индекс

> [!NOTE]
> **EF 6.1 только в сторону** — `Index` атрибут был введен в Entity Framework 6,1. Если вы используете более раннюю версию, сведения в этом разделе не применяются.

Можно создать индекс для одного или нескольких столбцов с помощью **индексаттрибуте**. Добавление атрибута в одно или несколько свойств приведет к тому, что EF создаст соответствующий индекс в базе данных при создании базы данных, или сформировать шаблон для соответствующих вызовов **CreateIndex** , если используется Code First migrations.

Например, следующий код приведет к созданию индекса для `Rating` столбца `Posts` таблицы в базе данных.

``` csharp
    public class Post
    {
        public int Id { get; set; }
        public string Title { get; set; }
        public string Content { get; set; }
        [Index]
        public int Rating { get; set; }
        public int BlogId { get; set; }
    }
```

По умолчанию индекс будет называться ** \_ &lt; имя &gt; Свойства IX** (рейтинг IX \_ в приведенном выше примере). Однако можно также указать имя для индекса. В следующем примере указывается, что индекс должен иметь имя `PostRatingIndex` .

``` csharp
    [Index("PostRatingIndex")]
    public int Rating { get; set; }
```

По умолчанию индексы не являются уникальными, но можно использовать `IsUnique` именованный параметр, чтобы указать, что индекс должен быть уникальным. В следующем примере представлен уникальный индекс для `User` имени входа.

``` csharp
    public class User
    {
        public int UserId { get; set; }

        [Index(IsUnique = true)]
        [StringLength(200)]
        public string Username { get; set; }

        public string DisplayName { get; set; }
    }
```

### <a name="multiple-column-indexes"></a>Индексы с несколькими столбцами

Индексы, охватывающие несколько столбцов, задаются с одним и тем же именем в нескольких аннотациях индекса для данной таблицы. При создании индексов с несколькими столбцами необходимо указать порядок столбцов в индексе. Например, следующий код создает индекс с несколькими столбцами для `Rating` и, `BlogId` именуемый **IX \_ блогидандратинг**. `BlogId` — Это первый столбец в индексе, а `Rating` — второй.

``` csharp
    public class Post
    {
        public int Id { get; set; }
        public string Title { get; set; }
        public string Content { get; set; }
        [Index("IX_BlogIdAndRating", 2)]
        public int Rating { get; set; }
        [Index("IX_BlogIdAndRating", 1)]
        public int BlogId { get; set; }
    }
```

 

## <a name="relationship-attributes-inverseproperty-and-foreignkey"></a>Атрибуты отношений: Инверсепроперти и Фореигнкэй

> [!NOTE]
> На этой странице содержатся сведения о настройке связей в модели Code First с помощью заметок к данным. Общие сведения о связях в EF и доступе к данным и управлении ими с помощью связей см. в разделе [связи & свойства навигации](xref:ef6/fundamentals/relationships). *

Первое соглашение Code позаботится о наиболее распространенных отношениях в модели, но в некоторых случаях требуется помощь.

При изменении имени ключевого свойства в `Blog` классе возникла проблема со связью `Post` . 

При формировании базы данных код сначала видит `BlogId` свойство в классе Post и распознает его, согласно соглашению, что оно соответствует имени класса плюс **идентификатор**, в качестве внешнего ключа для `Blog` класса. Но `BlogId` в классе блога нет свойства. Решением этой проблемы является создание свойства навигации в `Post` и использование `ForeignKey` аннотации данных для того, чтобы понять, как создать связь между двумя классами (с помощью `Post.BlogId` Свойства), а также как задать ограничения в базе.

``` csharp
    public class Post
    {
            public int Id { get; set; }
            public string Title { get; set; }
            public DateTime DateCreated { get; set; }
            public string Content { get; set; }
            public int BlogId { get; set; }
            [ForeignKey("BlogId")]
            public Blog Blog { get; set; }
            public ICollection<Comment> Comments { get; set; }
    }
```

Ограничение в базе данных показывает связь между `InternalBlogs.PrimaryTrackingKey` и `Posts.BlogId` . 

![отношение между Интерналблогс. Примаритраккингкэй и posts. Блогид](~/ef6/media/jj591583-figure09.png)

`InverseProperty`Используется при наличии нескольких связей между классами.

В `Post` классе может быть необходимо отследить, кто написал запись блога, а также кто ее редактировал. Ниже приведены два новых свойства навигации для класса Post.

``` csharp
    public Person CreatedBy { get; set; }
    public Person UpdatedBy { get; set; }
```

Также необходимо добавить в `Person` класс, на который ссылаются эти свойства. `Person`Класс имеет свойства навигации обратно `Post` , один для всех записей, записанных человеком, а другой — для всех записей, обновленных этим человеком.

``` csharp
    public class Person
    {
            public int Id { get; set; }
            public string Name { get; set; }
            public List<Post> PostsWritten { get; set; }
            public List<Post> PostsUpdated { get; set; }
    }
```

Код сначала не способен сопоставлять свойства в двух классах самостоятельно. Таблица базы данных для `Posts` пользователя должна иметь один внешний ключ `CreatedBy` и один для `UpdatedBy` пользователя, но сначала код создаст четыре свойства внешнего ключа: ** \_ идентификатор пользователя**, **пользователь \_ id1**, ** \_ идентификатор CreatedBy** и ** \_ идентификатор упдатедби**.

![Отправляет таблицу с дополнительными внешними ключами](~/ef6/media/jj591583-figure10.png)

Чтобы устранить эти проблемы, можно использовать `InverseProperty` заметку для указания выравнивания свойств.

``` csharp
    [InverseProperty("CreatedBy")]
    public List<Post> PostsWritten { get; set; }

    [InverseProperty("UpdatedBy")]
    public List<Post> PostsUpdated { get; set; }
```

Так как `PostsWritten` это свойство знает, что это относится к `Post` типу, он создает связь с `Post.CreatedBy` . Аналогично, `PostsUpdated` будет подключен к `Post.UpdatedBy` . И Code First не будет создавать дополнительные внешние ключи.

![Таблица posts без дополнительных внешних ключей](~/ef6/media/jj591583-figure11.png)

 

## <a name="summary"></a>Сводка

Аннотации данных не только позволяют описать клиентскую и серверную проверку в первых классах кода, но они также позволяют улучшать и даже исправлять предположения о том, что код сначала будет делаться с вашими классами в соответствии с его соглашениями. С помощью аннотаций к данным можно не только создать схему базы данных, но и связать сначала классы Code с уже существующей базой данных.

Хотя они являются очень гибкими, помните, что аннотации в виде примечаний предоставляют только наиболее распространенные изменения конфигурации, которые можно внести в первые классы кода. Чтобы настроить классы для некоторых из пограничных вариантов, следует обратить внимание на альтернативный механизм настройки, API-интерфейс Code First Fluent.
