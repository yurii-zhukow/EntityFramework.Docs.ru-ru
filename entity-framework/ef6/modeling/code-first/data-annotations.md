---
title: Заметки к данным First - EF6 Code
author: divega
ms.date: 2016-10-23
ms.assetid: 80abefbd-23c9-4fce-9cd3-520e5df9856e
ms.openlocfilehash: 57e2b988f81d9c82e10a07a5cd4f3a1decfd838a
ms.sourcegitcommit: 0d36e8ff0892b7f034b765b15e041f375f88579a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/09/2018
ms.locfileid: "44251210"
---
# <a name="code-first-data-annotations"></a>Заметки данных Code First
> [!NOTE]
> **EF4.1 и более поздних версий только** -функции, интерфейсы API, и т.д., описанных на этой странице появились в версии 4.1 платформы Entity Framework. При использовании более ранней версии, некоторые или все эти сведения не применяются.

Содержимое на этой странице взят из статьи, первоначально написан Майклом Джули Лерман (\<http://thedatafarm.com>).

Entity Framework Code First позволяет использовать собственные классы домена для представления модели EF полагается на выполнять запросы, изменение отслеживания и обновления функций. Код сначала использует шаблон программирования, называется «соглашение относительно настройки». Код сначала будет предполагается, что ваши классы соответствуют соглашениям об платформы Entity Framework и в этом случае будут автоматически работать способа выполнения задания его. Тем не менее если ваши классы не выполняйте эти соглашения, вы можете для добавления конфигурации к классам, чтобы предоставить EF требуемую информацию.

Во-первых, код предоставляет два способа добавления этих конфигураций в пользовательские классы. Один с помощью простых атрибутов, вызывается DataAnnotations, а второй с помощью Code First Fluent API, который предоставляет способ описания конфигураций, принудительно, в коде.

В этой статье основное внимание уделяется с помощью DataAnnotations (в пространстве имен System.ComponentModel.DataAnnotations) для настройки классов — выделение наиболее общие конфигурации. DataAnnotations также понимает ряд приложений .NET, таких как ASP.NET MVC, который позволяет этим приложениям использовать одинаковые примечания для проверки на стороне клиента.


## <a name="the-model"></a>Модель

Я продемонстрирую DataAnnotations первого кода с парой простых классов: блог и Post.

``` csharp
    public class Blog
    {
        public int Id { get; set; }
        public string Title { get; set; }
        public string BloggerName { get; set;}
        public virtual ICollection<Post> Posts { get; set; }
    }

    public class Post
    {
        public int Id { get; set; }
        public string Title { get; set; }
        public DateTime DateCreated { get; set; }
        public string Content { get; set; }
        public int BlogId { get; set; }
        public ICollection<Comment> Comments { get; set; }
    }
```

Значения, блог и Post классы удобно соответствуют соглашению об первый код и требуют нет изменений для включения совместимости EF. Тем не менее можно также использовать заметки для предоставления EF Дополнительные сведения о классах и базы данных, к которому они сопоставлены.

 

## <a name="key"></a>Ключ

Платформа Entity Framework использует каждой сущности, который используется для отслеживания сущности значение ключа. Одно соглашение о Code First — неявное ключевых свойств; Код сначала ищет свойство с именем «Id», или сочетание имени класса и «Id», например «BlogId». Это свойство сопоставляется столбцом первичного ключа в базе данных.

Блог и Post классов следуют соглашению. Что делать, если они не? Что делать, если имя используется блог *PrimaryTrackingKey* вместо, или даже *foo*? Если код сначала не удается найти свойство, которое соответствует этому соглашению вызовет исключение из-за требования платформы Entity Framework, что необходимо иметь ключевое свойство. Ключа заметки можно использовать для указания того, какое свойство будет использоваться в качестве EntityKey.

``` csharp
    public class Blog
    {
        [Key]
        public int PrimaryTrackingKey { get; set; }
        public string Title { get; set; }
        public string BloggerName { get; set;}
        public virtual ICollection<Post> Posts { get; set; }
    }
```

Если вы являетесь сначала с помощью кода — использовать функцию создания базы данных, в блоге таблице будет иметь столбец первичного ключа с именем PrimaryTrackingKey, который также определен как удостоверение по умолчанию.

![Блог таблицы с первичным ключом](~/ef6/media/jj591583-figure01.png)

### <a name="composite-keys"></a>Составные ключи

Платформа Entity Framework поддерживает составные ключи - первичные ключи, которые состоят из нескольких свойств. Например можно создать первичный ключ которой представляет собой сочетание PassportNumber и IssuingCountry класс Passport.

``` csharp
    public class Passport
    {
        [Key]
        public int PassportNumber { get; set; }
        [Key]
        public string IssuingCountry { get; set; }
        public DateTime Issued { get; set; }
        public DateTime Expires { get; set; }
    }
```

Попытка использовать приведенного выше класса в модели EF приведет к `InvalidOperationException`:

*Не удалось определить составного первичного ключа упорядочения для типа «Passport». Чтобы указать порядок для составные первичные ключи, используя ColumnAttribute или метод HasKey.*

Чтобы использовать составные ключи, Entity Framework необходимо определять порядок ключевых свойств. Это можно сделать с помощью заметок к столбцам, чтобы задать порядок.

>[!NOTE]
> Порядок сортировки является относительным (а не на базе индекса), чтобы использовать все значения. Например 100 и 200 подойдет вместо 1 и 2.

``` csharp
    public class Passport
    {
        [Key]
        [Column(Order=1)]
        public int PassportNumber { get; set; }
        [Key]
        [Column(Order = 2)]
        public string IssuingCountry { get; set; }
        public DateTime Issued { get; set; }
        public DateTime Expires { get; set; }
    }
```

При наличии сущностей с помощью составного внешние ключи, необходимо указать тот же столбец, упорядочение, которое использовалось для соответствующего свойства первичного ключа.

Только относительный порядок в пределах свойств внешнего ключа должен быть тем же, точные значения, присвоенные **порядок** не обязательно должны совпадать. Например в следующем классе, 3 и 4 может использоваться вместо 1 и 2.

``` csharp
    public class PassportStamp
    {
        [Key]
        public int StampId { get; set; }
        public DateTime Stamped { get; set; }
        public string StampingCountry { get; set; }

        [ForeignKey("Passport")]
        [Column(Order = 1)]
        public int PassportNumber { get; set; }

        [ForeignKey("Passport")]
        [Column(Order = 2)]
        public string IssuingCountry { get; set; }

        public Passport Passport { get; set; }
    }
```

## <a name="required"></a>Обязательно

Требуется аннотация указывает EF, что определенное свойство является обязательным.

Добавление необходимых для свойства Title приведет к EF (и MVC), чтобы убедиться, что свойство имеет данные в ней.

``` csharp
    [Required]
    public string Title { get; set; }
```

Нет дополнительных нет изменений кода или разметки в приложении, MVC-приложении будет выполнять проверки на стороне клиента, даже динамическое создание сообщения с использованием имени свойства и заметки.

![Создать страницу с названием является обязательным ошибки](~/ef6/media/jj591583-figure02.png)

Обязательный атрибут также повлияет на создаваемой базы данных, сделав сопоставленного свойства не допускающие значения NULL. Обратите внимание на то, что поле заголовка изменилось на «не null».

>[!NOTE]
> В некоторых случаях может оказаться невозможным для столбца в базе данных и не допускало, несмотря на то, что свойство является обязательным. Например, когда с помощью данных стратегии наследование TPH для нескольких типов хранится в одной таблице. Если производный тип содержит свойство столбца невозможно не допускающие значения NULL, так как не все типы в иерархии, это свойство будет задано.

 

![Блоги по таблице](~/ef6/media/jj591583-figure03.png)

 

## <a name="maxlength-and-minlength"></a>MaxLength и MinLength

MaxLength и MinLength атрибуты позволяют пользователю указать дополнительных свойств в комплексе, как это делалось с обязательным.

Вот BloggerName с требования к длине. Пример также демонстрирует использование атрибутов.

``` csharp
    [MaxLength(10),MinLength(5)]
    public string BloggerName { get; set; }
```

Заметка MaxLength повлияет на базе данных путем задания свойства длины 10.

![Блоги таблица, показывающая Максимальная длина столбца BloggerName](~/ef6/media/jj591583-figure04.png)

Заметки клиентские MVC и EF 4.1 заметки на сервере оба учитывает проверки снова динамическое создание сообщение об ошибке: «поле BloggerName должно быть типом строки или массива с максимальной длиной "10".» Это сообщение имеет несколько большую длину. Многие заметки позволяют указать сообщение об ошибке с атрибутом ErrorMessage.

``` csharp
    [MaxLength(10, ErrorMessage="BloggerName must be 10 characters or less"),MinLength(5)]
    public string BloggerName { get; set; }
```

Сообщение об ошибке можно также указать необходимые заметки.

![Создание страницы с настраиваемым сообщением об ошибке](~/ef6/media/jj591583-figure05.png)

 

## <a name="notmapped"></a>NotMapped

Соглашение об первый код определяет, что каждое свойство, которое имеет тип данных, поддерживаемых представляется в базе данных. Но это не всегда так, в ваших приложениях. Например можно использовать свойство в классе блог, который создает код, основанный на поля Title и BloggerName. Это свойство можно создавать динамически и не должны храниться. Можно пометить все свойства, которые не сопоставляются с аннотацией NotMapped, например, это свойство BlogCode базы данных.

``` csharp
    [NotMapped]
    public string BlogCode
    {
        get
        {
            return Title.Substring(0, 1) + ":" + BloggerName.Substring(0, 1);
        }
    }
```

 

## <a name="complextype"></a>ComplexType

Нередко для описания сущности предметной области через набор классов и затем уровня этих классов для описания в завершенную сущность. Например может добавьте класс с именем BlogDetails в модель.

``` csharp
    public class BlogDetails
    {
        public DateTime? DateCreated { get; set; }

        [MaxLength(250)]
        public string Description { get; set; }
    }
```

Обратите внимание на то, что BlogDetails не имеет ключевого свойства любого типа. В предметно-ориентированное проектирование BlogDetails упоминается как объект значения. Платформа Entity Framework ссылается на объекты-значения как сложные типы.  Сложные типы не отслеживается сами по себе.

Тем не менее как свойство в классе блог BlogDetails, он будет отслеживаться как часть объекта блога. В порядке для code first для распознавания это BlogDetails класс необходимо пометить как ComplexType.

``` csharp
    [ComplexType]
    public class BlogDetails
    {
        public DateTime? DateCreated { get; set; }

        [MaxLength(250)]
        public string Description { get; set; }
    }
```

Теперь можно добавить свойство в блоге классу для представления BlogDetails для этого блога.

``` csharp
        public BlogDetails BlogDetail { get; set; }
```

В базе данных блог таблица будет содержать все свойства блога, включая свойства, содержащиеся в его свойстве BlogDetail. По умолчанию каждый из них предшествует имя сложного типа, BlogDetail.

![Блог таблицы со сложным типом](~/ef6/media/jj591583-figure06.png)

Другой Интересно отметить, что несмотря на то, что свойство DateCreated было определено как не допускающие значения NULL даты и времени в классе, поле соответствующей базы данных допускает значения NULL. Если вы хотите повлиять на схему базы данных, необходимо использовать необходимые заметки.

 

## <a name="concurrencycheck"></a>ConcurrencyCheck

Заметка ConcurrencyCheck позволяет пометить одно или несколько свойств, используемый для проверки в базе данных, когда пользователь изменяет или удаляет сущность параллелизма. Если вы работали с конструктором, EF, это соответствует соглашению присвоить свойство ConcurrencyMode значение Fixed.

Давайте посмотрим, как работает ConcurrencyCheck, добавьте его в свойство BloggerName.

``` csharp
    [ConcurrencyCheck, MaxLength(10, ErrorMessage="BloggerName must be 10 characters or less"),MinLength(5)]
    public string BloggerName { get; set; }
```

При вызове метода SaveChanges, из-за Аннотация ConcurrencyCheck в поле BloggerName исходное значение этого свойства будет использоваться в обновлении. Команда попытается найти правильные строки путем фильтрации не только на значение ключа, но также и на ее оригинальном значении BloggerName.  Ниже приведены важные обновления команда, Посланная в базу данных, где вы увидите, команда будет обновить строку, которая имеет PrimaryTrackingKey — 1 и BloggerName «Julie», который был исходное значение, при блоге был извлечен из базы данных.

``` SQL
    where (([PrimaryTrackingKey] = @4) and ([BloggerName] = @5))
    @4=1,@5=N'Julie'
```

Если кто-то изменил название блоггер для блога, в то же время, это обновление завершится сбоем, и вы получите DbUpdateConcurrencyException, которые потребуются для обработки.

 

## <a name="timestamp"></a>Метка времени

Это чаще всего используется поля rowversion или метку времени для проверки параллелизма. Но вместо использования ConcurrencyCheck заметки, можно использовать более конкретные заметки отметки времени, до тех пор, пока тип свойства — массив байтов. Код сначала будет обрабатывать Timestamp свойства так же, как свойства ConcurrencyCheck, но также гарантирует, что поле базы данных, код сначала создает не допускающие значения NULL. В одном классе может иметь только одно свойство метки времени.

Добавление в класс блог следующее свойство:

``` csharp
    [Timestamp]
    public Byte[] TimeStamp { get; set; }
```

в результате получается код сначала создается столбец типа timestamp, не допускающие значения NULL в таблице базы данных.

![Блоги по таблице с столбец временной метки](~/ef6/media/jj591583-figure07.png)

 

## <a name="table-and-column"></a>Таблицы и столбца

Если вы предоставляете Code First создания базы данных, можно изменить имя таблицы и столбцы, которые он создает. Можно также использовать Code First с существующей базы данных. Но это не всегда так, что имена классов и свойств в вашем домене соответствуют именам таблиц и столбцов базы данных.

Мой класс называется блог и по соглашению, код сначала рассматривает это приведет к сопоставлению в таблицу с именем блоги. Если это не так с атрибутом таблицы можно указать имя таблицы. Здесь к примеру, заметка указывается, что имя таблицы является InternalBlogs.

``` csharp
    [Table("InternalBlogs")]
    public class Blog
```

Пометка столбца является более детальное представление при указании атрибутов сопоставленного столбца. Можно указать имя, тип данных или даже порядок, в котором отображается столбец в таблице. Вот пример атрибута.

``` csharp
    [Column(“BlogDescription", TypeName="ntext")]
    public String Description {get;set;}
```

Не путайте атрибут TypeName столбца с типом данных DataAnnotation. Тип данных является заметки, используемый для пользовательского интерфейса и поэтому пропускается при Code First.

Здесь приведена таблица после его генерируется. Имя таблицы изменилось на InternalBlogs и описание столбца из сложного типа теперь BlogDescription. Так как имя указано в аннотации, код сначала не будет использовать соглашение для имени столбца, начиная с имени сложного типа.

![Блоги таблиц и столбцов, которые переименован](~/ef6/media/jj591583-figure08.png)

 

## <a name="databasegenerated"></a>DatabaseGenerated

Функции важные базы данных является возможность вычисляемые свойства. При сопоставлении Code First классы для таблиц, содержащих вычисляемые столбцы, Entity Framework, чтобы попытаться обновить эти столбцы не нужно. Но вы хотите EF для получения этих значений из базы данных после были вставлены или обновлены данные. DatabaseGenerated заметки можно использовать для пометки этих свойств в классе, а также перечисления вычисленные. Другие перечисления являются None и удостоверений.

``` csharp
    [DatabaseGenerated(DatabaseGenerationOption.Computed)]
    public DateTime DateCreated { get; set; }
```

Можно использовать базу данных, создается байтов или метки времени столбцов при код сначала создает базу данных, в противном случае вам следует использовать только при указывает на существующие базы данных, так как код сначала не сможет определить формулу для данного вычисляемого столбца.

Ключевое свойство, которое должно быть целым числом, уже говорилось, по умолчанию станет ключа удостоверения в базе данных. Что бы так же, как присвоить DatabaseGenerated DatabaseGenerationOption.Identity. Если вы не хотите его ключ удостоверения, можно задать значение для DatabaseGenerationOption.None.

 

## <a name="index"></a>Индекс

> [!NOTE]
> **EF6.1 и более поздних версий только** -индекс, представляющий атрибут появился в Entity Framework 6.1. При использовании более ранней версии сведения в этом разделе не применяется.

Можно создать индекс для одного или нескольких столбцов с помощью **IndexAttribute**. Добавление атрибута в один или несколько свойств будет приводит к EF для создания соответствующего индекса в базе данных, при создании базы данных, или сформировать шаблон соответствующего **CreateIndex** вызывает при использовании Code First Migrations.

Например, следующий код приведет к индекса при создании на основе **Оценка** столбец **сообщения** таблицы в базе данных.

``` csharp
    public class Post
    {
        public int Id { get; set; }
        public string Title { get; set; }
        public string Content { get; set; }
        [Index]
        public int Rating { get; set; }
        public int BlogId { get; set; }
    }
```

По умолчанию будут присваиваться индекс **IX\_&lt;имя свойства&gt;**  (IX\_оценка в приведенном выше примере). Можно также указать имя индекса хотя. В следующем примере указывается, что индекс должен быть назван **PostRatingIndex**.

``` csharp
    [Index("PostRatingIndex")]
    public int Rating { get; set; }
```

По умолчанию, неуникальных индексов, но можно использовать **IsUnique** именованный параметр, чтобы указать, что индекс должен быть уникальным. В следующем примере представлены уникальный индекс на **пользователя**на имя входа.

``` csharp
    public class User
    {
        public int UserId { get; set; }

        [Index(IsUnique = true)]
        [StringLength(200)]
        public string Username { get; set; }

        public string DisplayName { get; set; }
    }
```

### <a name="multiple-column-indexes"></a>Индексы с несколькими столбцами

Индексы, которые охватывают несколько столбцов, указываются с помощью тем же именем в несколько заметок индекса для данной таблицы. Создавая индексы с несколькими столбцами, необходимо указать порядок для столбцов в индексе. Например, следующий код создает многостолбцовый индекс для **Оценка** и **BlogId** вызывается **IX\_BlogAndRating**. **BlogId** является первым столбцом в индексе и **Оценка** является вторым.

``` csharp
    public class Post
    {
        public int Id { get; set; }
        public string Title { get; set; }
        public string Content { get; set; }
        [Index("IX_BlogIdAndRating", 2)]
        public int Rating { get; set; }
        [Index("IX_BlogIdAndRating", 1)]
        public int BlogId { get; set; }
    }
```

 

## <a name="relationship-attributes-inverseproperty-and-foreignkey"></a>Связь атрибутов: InverseProperty и ForeignKey

> [!NOTE]
> Эта страница содержит сведения о настройке связи в модели Code First с помощью заметок к данным. Общие сведения о связях в EF и способах доступа к данных и управления ими с помощью связей см. в разделе [связей и свойств навигации](~/ef6/fundamentals/relationships.md). *

Соглашение об первый кода позаботится о наиболее распространенных связи в модели, но существуют случаи, где он нуждается в помощи.

Изменение имени ключевого свойства в класс блог, созданный на проблему с его связь с Post. 

При создании базы данных, код сначала увидит BlogId свойства в классе Post и распознает ее, по соглашению, что он соответствует имени класса, а также «Id», как внешний ключ к классу блога. Но нет BlogId свойства в классе блога. Решением будет создать свойство навигации в блога и использовать внешний DataAnnotation для кода сначала понять, как создать связь между двумя классами, используя свойство Post.BlogId — а также способы указания ограничений в База данных.

``` csharp
    public class Post
    {
            public int Id { get; set; }
            public string Title { get; set; }
            public DateTime DateCreated { get; set; }
            public string Content { get; set; }
            public int BlogId { get; set; }
            [ForeignKey("BlogId")]
            public Blog Blog { get; set; }
            public ICollection<Comment> Comments { get; set; }
    }
```

Ограничение в базе данных отображает связь между InternalBlogs.PrimaryTrackingKey и Posts.BlogId. 

![отношение между InternalBlogs.PrimaryTrackingKey и Posts.BlogId](~/ef6/media/jj591583-figure09.png)

InverseProperty используется в том случае, если у вас есть несколько связей между классами.

В классе Post, может потребоваться хранить список кто написал в блоге и кто его изменить. Ниже приведены два новых свойства навигации для класса Post.

``` csharp
    public Person CreatedBy { get; set; }
    public Person UpdatedBy { get; set; }
```

Также необходимо добавить в класс Person, ссылается на эти свойства. Класс Person имеет свойства навигации обратно к записи, одну для всех записей, написанной person и одну для всех записей, обновлены этим пользователем.

``` csharp
    public class Person
    {
            public int Id { get; set; }
            public string Name { get; set; }
            public List<Post> PostsWritten { get; set; }
            public List<Post> PostsUpdated { get; set; }
    }
```

Сначала код не сможет сопоставлять свойства в класс сам по себе. В таблице базы данных для записей должны иметь один внешний ключ для пользователя, Кем создано и один для UpdatedBy человека, но код сначала создать свойства внешнего ключа четыре будет: Person\_идентификатор, Person\_Id1, Кем создано\_идентификатор и UpdatedBy\_идентификатор.

![Таблице Posts с очень внешние ключи](~/ef6/media/jj591583-figure10.png)

Чтобы устранить эти проблемы, InverseProperty заметки можно использовать для указания выравнивания свойств.

``` csharp
    [InverseProperty("CreatedBy")]
    public List<Post> PostsWritten { get; set; }

    [InverseProperty("UpdatedBy")]
    public List<Post> PostsUpdated { get; set; }
```

Так как свойство PostsWritten лично знает, что это относится к типу Post, сборка будет связи Post.CreatedBy. Аналогичным образом PostsUpdated будут подключены к Post.UpdatedBy. И код сначала не создает дополнительных внешних ключей.

![Таблице Posts без дополнительных внешних ключей](~/ef6/media/jj591583-figure11.png)

 

## <a name="summary"></a>Сводка

DataAnnotations не только позволяют описывают проверки на стороне клиента и сервера в классах первый код, но они также позволяют улучшать и даже устранить предположения, которые код сначала облегчат о классов на основе его соглашений. С помощью DataAnnotations вы можете не только обеспечивать создание схемы базы данных, но также можно сопоставить классы первый код и уже существующей базы данных.

Хотя они являются достаточно гибкими, помните, что DataAnnotations предоставляют только наиболее часто используемые конфигурации изменения, внесенные в классах первого кода. Чтобы настроить свои классы для некоторых крайних случаев, следует проверить механизм альтернативная конфигурация, Code First Fluent API.
