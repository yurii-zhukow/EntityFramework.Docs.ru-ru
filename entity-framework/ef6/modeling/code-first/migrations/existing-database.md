---
title: Code First Migrations с существующей базой данных — EF6
author: divega
ms.date: 10/23/2016
ms.assetid: f0cc4f93-67dd-4664-9753-0a9f913814db
ms.openlocfilehash: eb7948eafb1322cabcf69b47bd5411f762fe8498
ms.sourcegitcommit: cc0ff36e46e9ed3527638f7208000e8521faef2e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78415697"
---
# <a name="code-first-migrations-with-an-existing-database"></a>Code First Migrations с существующей базой данных
> [!NOTE]
> **EF 4.3 только в сторону** — функции, API и т. д., обсуждаемые на этой странице, появились в Entity Framework 4,1. При использовании более ранней версии могут быть неприменимы некоторые или все сведения.

В этой статье рассматривается использование Code First Migrations с существующей базой данных, которая не была создана с помощью Entity Framework.

> [!NOTE]
> В этой статье предполагается, что вы умеете использовать Code First Migrations в основных сценариях. В противном случае необходимо прочитать [Code First migrations](~/ef6/modeling/code-first/migrations/index.md) , прежде чем продолжить.

## <a name="screencasts"></a>Демонстрационные ролики

Если бы вы хотели Смотреть ролик, чем читать эту статью, в следующих двух видеороликах будет рассмотрено то же содержимое, что и в этой статье.

### <a name="video-one-migrations---under-the-hood"></a>Видеоматериалы: «миграция — внутри себя»

В [этой презентации](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood) рассматривается, как миграция отслеживает и использует сведения о модели для обнаружения изменений модели.

### <a name="video-two-migrations---existing-databases"></a>Видео 2: "миграция — существующие базы данных"

С помощью [этой презентации](https://channel9.msdn.com/blogs/ef/migrations-existing-databases) вы узнаете о том, как включить и использовать миграцию с существующей базой данных, основываясь на концепциях предыдущего видео.

## <a name="step-1-create-a-model"></a>Шаг 1. Создание модели

Первым шагом будет создание модели Code First, предназначенной для существующей базы данных. В разделе [Code First к существующей базе данных](~/ef6/modeling/code-first/workflows/existing-database.md) содержится подробное руководство по выполнению этой задачи.

>[!NOTE]
> Прежде чем вносить изменения в модель, требующую внесения изменений в схему базы данных, важно выполнить остальные действия, описанные в этом разделе. Для выполнения следующих действий необходимо, чтобы модель была синхронизирована со схемой базы данных.

## <a name="step-2-enable-migrations"></a>Шаг 2. Включение миграции

Следующим шагом является включение миграции. Это можно сделать, запустив команду " **включить миграцию** " в консоли диспетчера пакетов.

Эта команда создаст папку в решении с именем Migrations и поместит в нее один класс с именем Configuration. Класс конфигурации — это место настройки миграции для приложения. Дополнительные сведения см. в [Code First migrations](~/ef6/modeling/code-first/migrations/index.md) разделе.

## <a name="step-3-add-an-initial-migration"></a>Шаг 3. добавление начальной миграции

После создания и применения миграций к локальной базе данных может также потребоваться применить эти изменения к другим базам данных. Например, локальная база данных может быть тестовой базой данных, и в конечном итоге потребуется применить изменения к рабочей базе данных и (или) другим разработчикам тестовых баз данных. Существует два варианта этого шага, и тот, который следует выбрать, зависит от того, является ли схема любых других баз данных пустой или в текущий момент соответствует схеме локальной базы данных.

-   **Вариант 1. использование существующей схемы в качестве начальной точки.** Этот подход следует использовать при условии, что в будущем для других баз данных, к которым будут применяться миграции, будет та же схема, что и в текущей базе данных. Например, вы можете использовать этот параметр, если локальная тестовая база данных в настоящее время соответствует версии 1 рабочей базы данных, и позже эти миграции будут применены для обновления рабочей базы данных до v2.
-   **Вариант 2. используйте пустую базу данных в качестве начальной точки.** Этот подход следует использовать в том случае, если другие базы данных, к которым будут применяться миграции в будущем, будут пустыми (или еще не существовать). Например, вы можете использовать его, если вы начали разрабатывать приложение с помощью тестовой базы данных, но без использования миграций, и позднее потребуется создать рабочую базу данных с нуля.

### <a name="option-one-use-existing-schema-as-a-starting-point"></a>Вариант 1. использование существующей схемы в качестве отправной точки

Code First Migrations использует моментальный снимок модели, сохраненной в самой последней миграции, для обнаружения изменений в модели (подробные сведения об этом см. в [Code First migrations в средах команд](~/ef6/modeling/code-first/migrations/teams.md)). Поскольку предполагается, что базы данных уже имеют схему текущей модели, будет создана пустая миграция (без операций), в которой текущая модель является моментальным снимком.

1.  Выполните команду **Add-Migration InitialCreate – игноречанжес** в консоли диспетчера пакетов. При этом создается пустой перенос с текущей моделью в виде моментального снимка.
2.  Выполните команду **обновления базы данных** в консоли диспетчера пакетов. Это приведет к применению InitialCreate миграции к базе данных. Поскольку фактическая миграция не содержит каких-либо изменений, она просто добавляет строку в \_\_таблицу Мигратионшистори, указывающую, что эта миграция уже применена.

### <a name="option-two-use-empty-database-as-a-starting-point"></a>Вариант 2. используйте пустую базу данных в качестве отправной точки

В этом сценарии необходимо выполнить миграцию, чтобы создать всю базу данных с нуля, включая таблицы, уже имеющиеся в нашей локальной базе данных. Мы создадим InitialCreate миграцию, которая включает логику для создания существующей схемы. Теперь наша существующая база данных будет выглядеть так, как эта миграция уже была применена.

1.  Выполните команду **Add-Migration InitialCreate** в консоли диспетчера пакетов. Будет создана миграция для создания существующей схемы.
2.  Закомментируйте весь код в методе up созданной миграции. Это позволит нам применить миграцию к локальной базе данных, не пытаясь повторно создавать все таблицы и т. д., которые уже существуют.
3.  Выполните команду **обновления базы данных** в консоли диспетчера пакетов. Это приведет к применению InitialCreate миграции к базе данных. Поскольку фактическая миграция не содержит каких-либо изменений (так как мы временно закомментируем их), она просто добавляет строку в \_\_таблицу Мигратионшистори, указывающую на то, что эта миграция уже применена.
4.  Отмена комментария к коду в методе up. Это означает, что если миграция применяется к будущим базам данных, то схема, которая уже существовала в локальной базе данных, будет создана при миграции.

## <a name="things-to-be-aware-of"></a>Необходимо учитывать следующие моменты:

При использовании миграции к существующей базе данных необходимо учитывать некоторые моменты.

### <a name="defaultcalculated-names-may-not-match-existing-schema"></a>Значения по умолчанию или вычисляемые имена не могут соответствовать существующей схеме

При миграции явно указываются имена столбцов и таблиц при формировании операций миграции. Однако существуют и другие объекты базы данных, которые используются при миграции для вычисления имени по умолчанию при применении миграции. Сюда входят индексы и ограничения внешнего ключа. При нацеливании на существующую схему эти вычисляемые имена могут не совпадать с данными, которые действительно существуют в базе данных.

Ниже приведены некоторые примеры того, когда необходимо помнить об этом.

**Если вы использовали параметр "вариант 1: использовать существующую схему в качестве начальной точки" из шага 3:**

-   Если будущие изменения в модели требуют изменения или удаления одного из объектов базы данных, названных по-другому, необходимо изменить шаблонную миграцию, указав правильное имя. API-интерфейсы миграции имеют необязательный параметр name, позволяющий сделать это.
    Например, существующая схема может содержать таблицу Post со столбцом внешнего ключа Блогид, имеющего индекс с именем Индексфк\_Блогид. Однако миграция по умолчанию предполагает, что этот индекс будет называться IX\_Блогид. При внесении изменений в модель, которая приводит к удалению этого индекса, необходимо изменить сформированный вызов событие DropIndex, указав имя Индексфк\_Блогид.

**Если вы использовали команду "параметр 2: использовать пустую базу данных как начальную точку" из шага 3:**

-   Попытка запустить метод down первоначальной миграции (то есть возврат к пустой базе данных) в локальной базе данных может завершиться неудачей, так как при миграции будет предпринята попытка удалить индексы и ограничения внешнего ключа с использованием неверных имен. Это повлияет только на локальную базу данных, так как другие базы данных будут создаваться с нуля с помощью метода первоначальной миграции.
    Если вы хотите понизить уровень существующей локальной базы данных до пустого состояния, проще всего сделать это вручную, удалив базу данных или удалив все таблицы. После первоначального перехода все объекты базы данных будут созданы заново с именами по умолчанию, поэтому эта проблема не будет представлена повторно.
-   Если будущие изменения в модели нуждаются в изменении или удалении одного из объектов базы данных, названных по-другому, это не будет работать для существующей локальной базы данных, так как имена не будут соответствовать значениям по умолчанию. Однако он будет работать с базами данных, созданными "с нуля", так как они будут использовать имена по умолчанию, выбранные при миграции.
    Можно либо вручную внести эти изменения в локальную существующую базу данных, либо рассмотреть возможность повторного создания базы данных с нуля, так как она будет создана на других компьютерах.
-   Базы данных, созданные с помощью метода up начальной миграции, могут немного отличаться от локальной базы данных, так как будут использоваться вычисляемые имена по умолчанию для индексов и ограничения внешнего ключа. Кроме того, можно получить дополнительные индексы, так как миграция будет создавать индексы внешних ключевых столбцов по умолчанию — это может быть не так в исходной локальной базе данных.

### <a name="not-all-database-objects-are-represented-in-the-model"></a>Не все объекты базы данных представлены в модели

Объекты базы данных, не являющиеся частью модели, не будут обрабатываться миграцией. Это могут быть представления, хранимые процедуры, разрешения, таблицы, не являющиеся частью модели, дополнительные индексы и т. д.

Ниже приведены некоторые примеры того, когда необходимо помнить об этом.

-   Независимо от варианта, выбранного на шаге 3, если будущие изменения в модели нуждаются в изменении или удалении этих дополнительных объектов, миграция не будет затруднить внесение этих изменений. Например, если удалить столбец с дополнительным индексом, то при миграции не будет известно, что он удаляет индекс. Его необходимо будет добавить в шаблон миграции вручную.
-   При использовании параметра "вариант 2: использовать пустую базу данных в качестве начальной точки" эти дополнительные объекты не будут созданы методом первоначальной миграции.
    При необходимости вы можете изменить методы up и Down, чтобы позаботиться об этих дополнительных объектах. Для объектов, которые изначально не поддерживаются в API-интерфейсе миграции (например, представления), можно использовать метод [SQL](https://msdn.microsoft.com/library/system.data.entity.migrations.dbmigration.sql.aspx) для выполнения необработанных операций SQL для их создания или удаления.
