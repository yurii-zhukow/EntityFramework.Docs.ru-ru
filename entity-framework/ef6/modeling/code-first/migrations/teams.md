---
title: Code First Migrations в средах группы — EF6
description: Code First Migrations в средах Team в Entity Framework 6
author: divega
ms.date: 10/23/2016
ms.assetid: 4c2d9a95-de6f-4e97-9738-c1f8043eff69
uid: ef6/modeling/code-first/migrations/teams
ms.openlocfilehash: ec382ecb0b7c99e57447ee50119fc3699fe1f324
ms.sourcegitcommit: 7c3939504bb9da3f46bea3443638b808c04227c2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/09/2020
ms.locfileid: "89617048"
---
# <a name="code-first-migrations-in-team-environments"></a>Code First Migrations в командных средах
> [!NOTE]
> В этой статье предполагается, что вы умеете использовать Code First Migrations в основных сценариях. В противном случае необходимо прочитать [Code First migrations](xref:ef6/modeling/code-first/migrations/index) , прежде чем продолжить.

## <a name="grab-a-coffee-you-need-to-read-this-whole-article"></a>Возьмите кофе, вы должны прочитать эту статью целиком

Проблемы в средах группы в основном связаны с слиянием миграций, когда два разработчика создавали миграции в своем локальном коде. Хотя действия, необходимые для решения этих задач, довольно просты, они должны иметь четкое представление о том, как работает миграция. Не стоит просто перейти к концу — Потратьте время на чтение всей статьи, чтобы убедиться в успешном выполнении.

## <a name="some-general-guidelines"></a>Некоторые общие рекомендации

Прежде чем приступить к изучению способов управления слиянием миграций, созданных несколькими разработчиками, ниже приведены некоторые общие рекомендации по настройке успеха.

### <a name="each-team-member-should-have-a-local-development-database"></a>У каждого члена команды должна быть локальная база данных разработки

В процессе миграции используется таблица ** \_ \_ мигратионшистори** для хранения данных, к которым применены миграции. Если у вас есть несколько разработчиков, создающих различные миграции при попытке ориентироваться на одну и ту же базу данных (и, таким же, совместно использовать ** \_ \_ мигратионшистори** таблицу), миграция будет очень запутанной.

Конечно, если у вас есть члены команды, которые не создают миграцию, то нет проблем с предоставлением общего доступа к центральной базе данных разработки.

### <a name="avoid-automatic-migrations"></a>Предотвращение автоматической миграции

В результате автоматических миграций, которые изначально выглядят хорошо в средах группы, в реальности они просто не работают. Если вы хотите получить сведения о том, почему, продолжите чтение — если нет, то можете перейти к следующему разделу.

Автоматическая миграция позволяет обновить схему базы данных в соответствии с текущей моделью без необходимости создавать файлы кода (переносы на основе кода). Автоматическая миграция будет хорошо работать в среде группы, если вы только когда-либо использовали их и никогда не создавали переносы на основе кода. Проблема заключается в том, что автоматическая миграция ограничена и не обрабатывает ряд операций: Переименование свойств и столбцов, перемещение данных в другую таблицу и т. д. Для обработки этих сценариев вы в итоге создаете переносы на основе кода (и редактируете шаблонный код), которые находятся в разных изменениях, которые обрабатываются автоматическими миграциями. Это делает невозможным слияние изменений, когда два разработчика проверяют миграцию.

## <a name="screencasts"></a>Демонстрационные ролики

Если бы вы хотели Смотреть ролик, чем читать эту статью, в следующих двух видеороликах будет рассмотрено то же содержимое, что и в этой статье.

### <a name="video-one-migrations---under-the-hood"></a>Видеоматериалы: «миграция — внутри себя»

В [этой презентации](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood) рассматривается, как миграция отслеживает и использует сведения о модели для обнаружения изменений модели.

### <a name="video-two-migrations---team-environments"></a>Видео 2: "миграции — среды группы"

На основе концепций из предыдущего видео в [этой презентации](https://channel9.msdn.com/blogs/ef/migrations-team-environments) рассматриваются проблемы, возникающие в среде группы, и способы их решения.

## <a name="understanding-how-migrations-works"></a>Основные сведения о принципах работы миграции

Ключом к успешному использованию миграций в среде рабочей группы является простое понимание того, как миграция отслеживает и использует сведения о модели для обнаружения изменений модели.

### <a name="the-first-migration"></a>Первая миграция

При добавлении первой миграции в проект в консоли диспетчера пакетов сначала выполняется нечто вроде **Add-Migration** . Ниже показаны действия высокого уровня, выполняемые этой командой.

![Первая миграция](~/ef6/media/firstmigration.png)

Текущая модель вычисляется из кода (1). Объекты базы данных, которые затем рассчитываются моделью, отличаются (2) — поскольку это первая миграция, то модель отличается только пустой моделью для сравнения. Необходимые изменения передаются генератору кода для создания необходимого кода миграции (3), который затем добавляется в решение Visual Studio (4).

В дополнение к фактическому коду переноса, который хранится в основном файле кода, при миграции также создаются некоторые дополнительные файлы кода программной части. Эти файлы являются метаданными, используемыми для миграций и которые не нужно изменять. Один из этих файлов представляет собой файл ресурсов (RESX), который содержит моментальный снимок модели на момент создания миграции. Вы увидите, как это используется на следующем шаге.

На этом этапе вы, вероятно, запустили **Обновление** базы данных, чтобы применить изменения к базе данных, а затем — к реализации других областей приложения.

### <a name="subsequent-migrations"></a>Последующие миграции

Позже вы вернетесь к модели и внесете в нее некоторые изменения. в нашем примере мы добавим в **блог**свойство **URL-адреса** . Затем выполните команду **Add-Migration аддурл** , чтобы сформировать шаблон миграции, чтобы применить соответствующие изменения базы данных. Ниже показаны действия высокого уровня, выполняемые этой командой.

![Вторая миграция](~/ef6/media/secondmigration.png)

Как и в последнем времени, текущая модель вычисляется по коду (1). Однако на этот раз существуют миграция, поэтому Предыдущая модель извлекается из последней миграции (2). Эти две модели различны для поиска необходимых изменений базы данных (3), после чего процесс завершается как раньше.

Этот же процесс используется для последующих миграций, добавляемых в проект.

### <a name="why-bother-with-the-model-snapshot"></a>Зачем нужна моментальный снимок модели?

Возможно, вас интересует, почему EF оба с моментальным снимком модели — не просто взгляните на базу данных. Если это так, читайте на. Если вас не интересует, этот раздел можно пропустить.

Существует ряд причин, по которым EF сохраняет моментальный снимок модели:

-   Это позволяет базе данных отменять модель EF. Эти изменения можно вносить непосредственно в базу данных, или же можно изменить сформированный код в миграции, чтобы внести изменения. Вот несколько примеров этого на практике.
    -   Необходимо добавить столбец inserted и updated в одну или несколько таблиц, но не нужно включать эти столбцы в модель EF. Если миграция выполнялась в базе данных, она будет непрерывно пытаться удалить эти столбцы при каждом формировании процесса миграции. При использовании моментального снимка модели EF будет только обнаруживать допустимые изменения модели.
    -   Необходимо изменить текст хранимой процедуры, используемой для обновления, чтобы включить некоторые журналы. Если миграции Просмотрели эту хранимую процедуру из базы данных, она будет постоянно пытаться вернуться к определению, которое предполагается EF. С помощью моментального снимка модели EF будет только код формирования кода для изменения хранимой процедуры при изменении формы процедуры в модели EF.
    -   Эти же принципы применяются для добавления дополнительных индексов, включая дополнительные таблицы в базе данных, сопоставления EF с представлением базы данных, расположенным над таблицей, и т. д.
-   Модель EF содержит не только форму базы данных. Наличие всей модели позволяет выполнять миграцию для просмотра сведений о свойствах и классах в модели, а также о том, как они сопоставляются со столбцами и таблицами. Эти сведения обеспечивают более интеллектуальную миграцию в коде, который он формирует. Например, если изменить имя столбца, сопоставляемое свойству с миграцией, может обнаружить переименование, просматривая то же самое свойство — что не может быть выполнено, если имеется только схема базы данных. 

## <a name="what-causes-issues-in-team-environments"></a>Причины проблем в средах группы

Рабочий процесс, описанный в предыдущем разделе, отлично работает, если вы работаете над приложением с помощью одного разработчика. Это также хорошо работает в среде группы, если вы единственный пользователь, который вносит изменения в модель. В этом сценарии можно вносить изменения в модель, создавать миграции и отправлять их в систему управления версиями. Другие разработчики могут синхронизировать изменения и выполнить **Обновление базы данных** , чтобы применить изменения схемы.

Проблемы начинают возникать, когда несколько разработчиков вносит изменения в модель EF и одновременно отправляются в систему управления версиями. Нехватка EF — первый классовый способ слияния локальных миграций с миграцией, которые другой разработчик отправил в систему управления версиями с момента последней синхронизации.

## <a name="an-example-of-a-merge-conflict"></a>Пример конфликта слияния

Сначала давайте рассмотрим конкретный пример такого конфликта слияния. Мы будем продолжать работу с примером, который мы рассматривали ранее. В качестве отправной точки Предположим, что изменения из предыдущего раздела были возвращены исходным разработчиком. Мы будем отслеживанием двух разработчиков при внесении изменений в базу кода.

Мы будем относиться к модели EF и миграции с учетом ряда изменений. В качестве отправной точки оба разработчика были синхронизированы с репозиторием системы управления версиями, как показано на следующем рисунке.

![Начальная точка](~/ef6/media/startingpoint.png)

Разработчик \# 1 и разработчик \# 2 теперь вносит некоторые изменения в модель EF в своей локальной базе кода. Разработчик \# 1 добавляет свойство **рейтинга** в **блог** — и создает **аддратинг** миграцию для применения изменений к базе данных. Разработчик \# 2 добавляет в **блог** свойство " **читатели** " и создает соответствующую **аддреадерс** миграцию. Оба разработчика выполняют **Обновление базы данных**, применяют изменения к их локальным базам данных, а затем продолжают разработку приложения.

> [!NOTE]
> Для миграции используется префикс отметок времени, поэтому наш график представляет, что Аддреадерс миграция от разработчика \# 2 происходит после аддратинг миграции от разработчика \# 1. Если разработчик \# 1 или \# 2 создал миграцию, то в первую очередь не повлияет на проблемы, связанные с работой в команде, или на процесс их слияния, который мы рассмотрим в следующем разделе.

![Локальные изменения](~/ef6/media/localchanges.png)

Это самый счастливой день для разработчика \# 1, так как он посылает свои изменения первыми. Так как никто из других пользователей не вернул, так как он синхронизирует свой репозиторий, он может просто отправить свои изменения без выполнения слияния.

![Отправка изменений](~/ef6/media/submit.png)

Пришло время отправить разработчику \# 2. Они не так счастливы. Так как кто-то другой отправил изменения с момента их синхронизации, им потребуется извлечь изменения и выполнить слияние. Система управления версиями, скорее всего, сможет автоматически объединить изменения на уровне кода, так как они очень просты. Состояние \# локального репозитория разработчика 2 после синхронизации показано на следующем рисунке. 

![Извлечь из системы управления версиями](~/ef6/media/pull.png)

На этом этапе разработчик \# 2 может выполнить **Update-Database** , который обнаружит новую миграцию **аддратинг** (которая не была применена к \# базе данных разработчика 2) и применит ее. Теперь столбец **рейтинга** добавляется в таблицу **блоги** , и база данных синхронизируется с моделью.

Существует несколько проблем:

1.  Несмотря на то, что **Update-Database** будет применять **аддратинг** миграцию, также будет выдано предупреждение: *невозможно обновить базу данных в соответствии с текущей моделью, так как имеются ожидающие изменения и отключена автоматическая миграция...*
    Проблема заключается в том, что для моментального снимка модели, хранящегося в последней миграции (**аддреадер**), отсутствует свойство **рейтинга** в **блоге** (поскольку оно не было частью модели при создании миграции). Code First обнаруживает, что модель в последней миграции не соответствует текущей модели и вызывает предупреждение.
2.  Запуск приложения приведет к тому, что "*модель резервного копирования контекста" BloggingContext "изменилась с момента создания базы данных. Попробуйте использовать Code First Migrations для обновления базы данных... "*
    Опять же, проблема заключается в том, что моментальный снимок модели, хранящийся в последней миграции, не соответствует текущей модели.
3.  Наконец, мы предполагаем, что при выполнении **Add-Migration** будет создан пустой перенос (поскольку нет изменений, применимых к базе данных). Но поскольку миграция сравнивает текущую модель с последней миграцией (в которой отсутствует свойство **рейтинга** ), она фактически формирует формирование шаблона другого вызова **addColumn** для добавления в столбец **рейтинга** . Разумеется, эта миграция может завершиться ошибкой во время **обновления базы данных** , поскольку столбец **рейтинга** уже существует.

## <a name="resolving-the-merge-conflict"></a>Разрешение конфликта слияния

Хорошая новость заключается в том, что не слишком сложно работать с слиянием вручную — при условии, что вы понимаете, как работает миграция. Итак, если вы пропустили этот раздел... к сожалению, сначала необходимо ознакомиться с оставшейся частью статьи!

Существует два варианта: проще всего создать пустую миграцию с правильной текущей моделью в виде моментального снимка. Второй вариант — обновить моментальный снимок в последней миграции, чтобы он имел правильный моментальный снимок модели. Второй вариант — немного сложнее, и его нельзя использовать в каждом сценарии, но это также может быть вызвано тем, что не требует добавления дополнительной миграции.

### <a name="option-1-add-a-blank-merge-migration"></a>Вариант 1. Добавление пустого переноса слиянием

В этом варианте создается пустая миграция только для того, чтобы гарантировать, что последняя миграция будет иметь нужный моментальный снимок модели.

Этот параметр можно использовать независимо от того, кто создал последнюю миграцию. В примере мы сделали так, что разработчик \# 2 выполняет слияние, и он создавался для создания последней миграции. Но эти же действия можно использовать, если разработчик \# 1 создал последнюю миграцию. Эти шаги также применяются, если участвуют несколько миграций — мы только что видели два, чтобы они были простыми.

Для этого подхода можно использовать следующий процесс, начиная с того времени, когда вы понимаете, какие изменения необходимо синхронизировать с системой управления версиями.

1.  Убедитесь, что все ожидающие изменения модели в локальной базе кода были записаны в миграцию. Этот шаг гарантирует, что вы не пропустили какие – либо допустимые изменения, когда поступает время создания пустой миграции.
2.  Синхронизация с системой управления версиями.
3.  Выполните **Обновление базы данных** , чтобы применить новые миграции, которые были возвращены другими разработчиками.
    **_Примечание._** *Если вы не получаете предупреждения от команды Update-Database, то не существовали новые миграции от других разработчиков и нет необходимости выполнять дальнейшее слияние.*
4.  Выполните команду **Добавить-миграцию &lt; выберите \_ \_ имя &gt; — игноречанжес** (например, **Слияние с добавлением миграции – игноречанжес**). При этом создается миграция со всеми метаданными (включая моментальный снимок текущей модели), но игнорируются все изменения, обнаруженные при сравнении текущей модели с моментальным снимком при последнем переносе (это означает, что вы получаете пустой метод " **вверх** и **вниз** ").
5.  Выполните **Обновление базы данных** , чтобы повторно применить последнюю миграцию с обновленными метаданными.
6.  Продолжить разработку или отправить в систему управления версиями (после выполнения модульных тестов курса).

Ниже приведено состояние \# локальной базы кода разработчика 2 после использования этого подхода.

![Миграция слиянием](~/ef6/media/mergemigration.png)

### <a name="option-2-update-the-model-snapshot-in-the-last-migration"></a>Вариант 2. обновление моментального снимка модели при последней миграции

Этот параметр очень похож на вариант 1, но удаляет лишнюю пустую миграцию, так как давайте ему требуется дополнительный файл кода в своем решении.

**Этот подход допустим, только если последняя миграция существует только в локальной базе кода и еще не была отправлена в систему управления версиями (например, если последняя миграция была создана пользователем, выполняющим слияние)**. Изменение метаданных миграций, которые другие разработчики могли уже применить к своей базе данных для разработки, или, что еще хуже, примененные к рабочей базе данных, может привести к непредвиденным побочным эффектам. Во время процесса мы будем выполнять откат последней миграции в локальной базе данных и повторно применять ее с обновленными метаданными.

Хотя последняя миграция должна быть только в локальной базе кода, нет ограничений на число или порядок миграции, которые его проводят. Существует несколько переходов от разных разработчиков и одних и тех же действий — мы только что видели два, чтобы обеспечить простоту.

Для этого подхода можно использовать следующий процесс, начиная с того времени, когда вы понимаете, какие изменения необходимо синхронизировать с системой управления версиями.

1.  Убедитесь, что все ожидающие изменения модели в локальной базе кода были записаны в миграцию. Этот шаг гарантирует, что вы не пропустили какие – либо допустимые изменения, когда поступает время создания пустой миграции.
2.  Синхронизация с системой управления версиями.
3.  Выполните **Обновление базы данных** , чтобы применить новые миграции, которые были возвращены другими разработчиками.
    **_Примечание._** *Если вы не получаете предупреждения от команды Update-Database, то не существовали новые миграции от других разработчиков и нет необходимости выполнять дальнейшее слияние.*
4.  Выполнение **обновления-база данных — &lt; таржетмигратион \_ Вторая \_ &gt; Миграция** (в нашем примере мы собрались бы **обновлением базы данных — таржетмигратион аддратинг**). Это приводит к возврату базы данных к состоянию второй последней миграции — эффективному отмене применения последней миграции из базы данных.
    **_Примечание._** *этот шаг необходим для безопасного изменения метаданных миграции, так как метаданные также хранятся в \_ \_ мигратионшисторитабле базы данных. Именно поэтому этот параметр следует использовать только в том случае, если последняя миграция выполняется только в локальной базе кода. Если в других базах данных была применена последняя миграция, также потребуется выполнить откат и повторно применить последнюю миграцию для обновления метаданных.* 
5.  Выполните команду " **Добавить &lt; полное \_ имя миграции" \_ \_ , включая метку времени \_ \_ последней \_ миграции** &gt; (в примере мы собрались вот что, например, **Add-Migration 201311062215252 \_ аддреадерс**).
    **_Примечание._** необходимо *включить метку времени, чтобы при миграции было известно, что необходимо изменить существующую миграцию, а не создать формирование шаблонов.*
    При этом метаданные для последней миграции будут обновлены в соответствии с текущей моделью. При завершении команды вы получите следующее предупреждение, но это именно то, что вам нужно. *Был изменен шаблон "только код конструктора для миграции" 201311062215252 \_ аддреадерс ". Чтобы изменить формирование шаблонов для всей миграции, используйте параметр-Force.*
6.  Выполните **Обновление базы данных** , чтобы повторно применить последнюю миграцию с обновленными метаданными.
7.  Продолжить разработку или отправить в систему управления версиями (после выполнения модульных тестов курса).

Ниже приведено состояние \# локальной базы кода разработчика 2 после использования этого подхода.

![Обновленные метаданные](~/ef6/media/updatedmetadata.png)

## <a name="summary"></a>Итоги

При использовании Code First Migrations в среде группы возникают некоторые сложности. Тем не менее, основное представление о том, как работает миграция, и некоторые простые подходы к устранению конфликтов слияния позволяют легко преодолеть эти трудности.

Фундаментальная ошибка — неправильные метаданные, хранящиеся в последней миграции. Это приводит к тому, что Code First неправильно обнаруживает, что текущая модель и схема базы данных не совпадают и для формирования неверного кода при следующей миграции. Эту ситуацию можно преодолеть, создав пустую миграцию с правильной моделью или обновив метаданные в последней миграции.
