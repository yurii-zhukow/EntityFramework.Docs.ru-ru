---
title: Сущности с самостоятельным отслеживанием в EF6
description: Самостоятельное отслеживание сущностей в Entity Framework 6
author: divega
ms.date: 10/23/2016
uid: ef6/fundamentals/disconnected-entities/self-tracking-entities/index
ms.openlocfilehash: 9d5985a3f66b58a74536a1a56486bfc37c3f9f4d
ms.sourcegitcommit: abda0872f86eefeca191a9a11bfca976bc14468b
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/14/2020
ms.locfileid: "90070592"
---
# <a name="self-tracking-entities"></a>Сущности с самостоятельным отслеживанием

> [!IMPORTANT]
> Больше не рекомендуется использовать шаблон сущностей с самостоятельным отслеживанием. Он по-прежнему будет доступен только для поддержки существующих приложений. Если приложению необходимо работать с отключенными графами сущностей, рассмотрите другие варианты, такие как [отслеживаемые сущности](https://trackableentities.github.io/), которые технологически эквивалентны сущностям с самостоятельным отслеживанием, активно разрабатываемым сообществом. Или остановитесь на написании пользовательского кода с помощью API-интерфейсов отслеживания изменений низкого уровня.

В приложении на базе Entity Framework контекст отвечает за отслеживание изменений в объектах. Затем изменения сохраняются в базе данных с помощью метода SaveChanges. При работе с многоуровневыми приложениями объекты сущностей, как правило, отключаются от контекста и необходимо решить, как отслеживать изменения и передавать эти изменения обратно в контекст. Сущности с самостоятельным отслеживанием (STE) могут помочь отслеживать изменения на любом уровне и затем воспроизводить их в контексте для сохранения.  

Используйте сущности с самостоятельным отслеживанием, только если контекст недоступен на том уровне, где вносятся изменения в граф объекта. Если контекст доступен, использовать эти сущности нет необходимости, так как отслеживать изменения будет контекст.  

Этот элемент шаблона создает два TT-файла (text template).  

- Файл **\<model name\>.tt** создает типы сущностей и вспомогательный класс, который содержит логику отслеживания изменений, используемую в сущностях с самостоятельным отслеживанием, и методы расширения, позволяющие задавать состояние этих сущностей.  
- Файл **\<model name\>.Context.tt** создает производный контекст и класс расширения, который содержит методы **ApplyChanges** для классов **ObjectContext** и **ObjectSet**. Эти методы проверяют сведения об отслеживании изменений, которые содержатся в графе сущностей с самостоятельным отслеживанием, чтобы вывести набор операций, которые следует выполнить для сохранения изменений в базе данных.  

## <a name="get-started"></a>Приступая к работе  

Чтобы приступить к работе, посетите страницу с [пошаговым руководством по использованию сущностей с самостоятельным отслеживанием](xref:ef6/fundamentals/disconnected-entities/self-tracking-entities/walkthrough).  

## <a name="functional-considerations-when-working-with-self-tracking-entities"></a>Рекомендации по функциям при работе с сущностями с автоматическим отслеживанием  
> [!IMPORTANT]
> Больше не рекомендуется использовать шаблон сущностей с самостоятельным отслеживанием. Он по-прежнему будет доступен только для поддержки существующих приложений. Если приложению необходимо работать с отключенными графами сущностей, рассмотрите другие варианты, такие как [отслеживаемые сущности](https://trackableentities.github.io/), которые технологически эквивалентны сущностям с самостоятельным отслеживанием, активно разрабатываемым сообществом. Или остановитесь на написании пользовательского кода с помощью API-интерфейсов отслеживания изменений низкого уровня.

При работе с сущностями с самостоятельным отслеживанием нужно принимать во внимание следующие соображения.  

- Убедитесь в том, что в клиентском проекте имеется ссылка на сборку, содержащую типы сущностей. Если в клиентский проект будет добавлена только ссылка на службу, то в клиентском проекте будут использоваться прокси-типы WCF, а не действительные типы сущностей с самостоятельным отслеживанием. Это означает, что не будут получены средства автоматизированного уведомления, которые управляют отслеживанием сущностей на клиенте. Если сознательно решено не включать типы сущностей, то придется вручную задавать сведения отслеживания на клиенте, чтобы изменения передавались обратно в службу.  
- Вызовы этой операции службы должны быть не поддерживающими состояние и создавать новый экземпляр контекста объекта. Также рекомендуется создавать контекст объекта в блоке **using**.  
- Если после отправки измененного на клиенте графа службе вы намерены продолжать работу с тем же графом на клиенте, то вам придется вручную провести итерацию по графу на клиенте, вызывая для каждого объекта метод **AcceptChanges** для сброса состояния объекта отслеживания изменений.  

    > Если объекты в графе содержат свойства со значениями, формируемыми базой данных (например, значения удостоверения или параллелизма), то после вызова метода **SaveChanges** Entity Framework заменит значения этих свойств значениями, сформированными базой данных. Предусмотрена возможность реализовать собственную операцию службы для возврата клиенту сохраненных объектов или списка сформированных значений свойств для объекта. Затем клиенту потребуется заменить экземпляры объектов или значения свойств объектов теми объектами или значениями свойств, которые были возвращены из операции службы.  
- Объединение графов из нескольких запросов к службе может привести к появлению в итоговом графе повторяющихся значений ключей. Entity Framework не удаляет объекты с повторяющимися ключами при вызове метода **ApplyChanges**. Вместо этого формируется исключение. Для предотвращения появления графов с повторяющимися значениями ключей придерживайтесь одного из шаблонов, описанных в следующем блоге: [Сущности с самостоятельным отслеживанием. Сущности ApplyChanges и повторяющиеся сущности](https://go.microsoft.com/fwlink/?LinkID=205119&clcid=0x409).  
- При изменении связи между объектами путем задания свойства внешнего ключа ссылка на свойство навигации задается равной NULL и не синхронизируется с основной сущностью на клиенте. После присоединения графа к контексту объекта (например, после вызова метода **ApplyChanges**) свойства внешнего ключа и свойства навигации синхронизируются.  

    > Отсутствие синхронизации свойства навигации ссылки с соответствующим основным объектом может стать причиной проблем, если задано каскадное удаление по связи по внешнему ключу. Если будет удален основной объект, операция удаления не распространится на зависимые объекты. Если заданы каскадные удаления, то для изменения связей следует использовать свойства навигации, а не задавать свойство внешнего ключа.  
- Сущностям с самостоятельным отслеживанием не разрешается использовать отложенную загрузку.  
- Сущности с самостоятельным отслеживанием не поддерживают двоичную сериализацию и сериализацию в объекты управления состоянием ASP.NET. Тем не менее этот шаблон можно изменить в целях добавления поддержки двоичной сериализации. Дополнительные сведения см. в статье [Using Binary Serialization and ViewState with Self-Tracking Entities](https://go.microsoft.com/fwlink/?LinkId=199208) (Использование двоичной сериализации и ViewState с сущностями с самостоятельным отслеживанием).  

## <a name="security-considerations"></a>Вопросы безопасности  

При работе с сущностями с самостоятельным отслеживанием следует учитывать следующие рекомендации по безопасности.  

- Служба не должна доверять запросам на получение или обновление данных, исходящим от клиентов и каналов, не являющихся доверенными. Клиент должен пройти проверку подлинности; следует пользоваться безопасным каналом или конвертом сообщения. Запросы клиентов на обновление или получение данных следует проверять на соответствие ожидаемым и разрешенным изменениям для данного сценария.  
- Не следует использовать в качестве ключей сущностей конфиденциальных сведений (например, номера карточек социального страхования). Тогда конфиденциальные сведения не смогут случайно подвергнуться сериализации в графах сущностей с самостоятельным отслеживанием и попасть к клиенту, который не является полностью доверенным. При использовании независимых сопоставлений исходный ключ сущности, сопоставляемый с сериализуемым, также может быть отправлен клиенту.  
- Чтобы избежать передачи сообщений об исключениях, содержащих конфиденциальные данные, на клиентский уровень, вызовы методов **ApplyChanges** и **SaveChanges** на уровне сервера следует упаковывать в код обработки исключений.  
