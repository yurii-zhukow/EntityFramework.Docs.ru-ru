---
title: Сущности с самостоятельным отслеживанием в EF6
author: divega
ms.date: 2016-10-23
ms.prod: entity-framework
ms.author: divega
ms.manager: avickers
ms.technology: entity-framework-6
ms.topic: article
ms.assetid: 5e60f5be-7bbb-4bf8-835e-0ac808d6c84a
caps.latest.revision: 3
ms.openlocfilehash: 2fb4e9f4d4008c57e90c49a011bebb320eb2bb58
ms.sourcegitcommit: 45494121254ad4fdcec613d1dd22d850068d6f39
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/08/2018
ms.locfileid: "37913529"
---
# <a name="self-tracking-entities"></a>Сущности с самостоятельным отслеживанием

> [!IMPORTANT]
> Больше не рекомендуется использовать шаблон сущностей с самостоятельным отслеживанием. Он по-прежнему будет доступен только для поддержки существующих приложений. Если приложению необходимо работать с отключенными графами сущностей, рассмотрите другие варианты, такие как [отслеживаемые сущности](http://trackableentities.github.io/), которые технологически эквивалентны сущностям с самостоятельным отслеживанием, активно разрабатываемым сообществом. Или остановитесь на написании пользовательского кода с помощью API-интерфейсов отслеживания изменений низкого уровня.

В приложении на базе Entity Framework контекст отвечает за отслеживание изменений в объектах. Затем изменения сохраняются в базе данных с помощью метода SaveChanges. При работе с многоуровневыми приложениями объекты сущностей, как правило, отключаются от контекста и необходимо решить, как отслеживать изменения и передавать эти изменения обратно в контекст. Сущности с самостоятельным отслеживанием (STE) могут помочь отслеживать изменения на любом уровне и затем воспроизводить их в контексте для сохранения.  

Используйте сущности с самостоятельным отслеживанием, только если контекст недоступен на том уровне, где вносятся изменения в граф объекта. Если контекст доступен, использовать эти сущности нет необходимости, так как отслеживать изменения будет контекст.  

Этот элемент шаблона создает два TT-файла (text template).  

- Файл **\<имя_модели \>.tt** создает типы сущности и вспомогательный класс, содержащий логику отслеживания изменений, используемую в сущностях с самостоятельным отслеживанием, и методы расширения, позволяющие задавать состояние этих сущностей.  
- Файл **\<имя_модели\>.Context.tt** создает производный контекст и класс расширения, который содержит методы **ApplyChanges** для классов **ObjectContext** и **ObjectSet**. Эти методы проверяют сведения об отслеживании изменений, которые содержатся в графе сущностей с самостоятельным отслеживанием, чтобы вывести набор операций, которые следует выполнить для сохранения изменений в базе данных.  

## <a name="get-started"></a>Приступая к работе  

Чтобы приступить к работе, посетите страницу с [пошаговым руководством по использованию сущностей с самостоятельным отслеживанием](walkthrough.md).  

## <a name="considerations-when-working-with-self-tracking-entities"></a>Общие соображения при работе с сущностями с самостоятельным отслеживанием  
> [!IMPORTANT]
> Больше не рекомендуется использовать шаблон сущностей с самостоятельным отслеживанием. Он по-прежнему будет доступен только для поддержки существующих приложений. Если приложению необходимо работать с отключенными графами сущностей, рассмотрите другие варианты, такие как [отслеживаемые сущности](http://trackableentities.github.io/), которые технологически эквивалентны сущностям с самостоятельным отслеживанием, активно разрабатываемым сообществом. Или остановитесь на написании пользовательского кода с помощью API-интерфейсов отслеживания изменений низкого уровня.

При работе с сущностями с самостоятельным отслеживанием нужно принимать во внимание следующие соображения.  

- Убедитесь в том, что в клиентском проекте имеется ссылка на сборку, содержащую типы сущностей. Если в клиентский проект будет добавлена только ссылка на службу, то в клиентском проекте будут использоваться прокси-типы WCF, а не действительные типы сущностей с самостоятельным отслеживанием. Это означает, что не будут получены средства автоматизированного уведомления, которые управляют отслеживанием сущностей на клиенте. Если сознательно решено не включать типы сущностей, то придется вручную задавать сведения отслеживания на клиенте, чтобы изменения передавались обратно в службу.  
- Вызовы этой операции службы должны быть не поддерживающими состояние и создавать новый экземпляр контекста объекта. Также рекомендуется создавать контекст объекта в блоке **using**.  
- Если после отправки измененного на клиенте графа службе вы намерены продолжать работу с тем же графом на клиенте, то вам придется вручную провести итерацию по графу на клиенте, вызывая для каждого объекта метод **AcceptChanges** для сброса состояния объекта отслеживания изменений.  

    > Если объекты в графе содержат свойства со значениями, формируемыми базой данных (например, значения удостоверения или параллелизма), то после вызова метода **SaveChanges** Entity Framework заменит значения этих свойств значениями, сформированными базой данных. Предусмотрена возможность реализовать собственную операцию службы для возврата клиенту сохраненных объектов или списка сформированных значений свойств для объекта. Затем клиенту потребуется заменить экземпляры объектов или значения свойств объектов теми объектами или значениями свойств, которые были возвращены из операции службы.  
- Объединение графов из нескольких запросов к службе может привести к появлению в итоговом графе повторяющихся значений ключей. Entity Framework не удаляет объекты с повторяющимися ключами при вызове метода **ApplyChanges**. Вместо этого формируется исключение. Для предотвращения появления графов с повторяющимися значениями ключей придерживайтесь одного из шаблонов, описанных в следующем блоге: [Сущности с самостоятельным отслеживанием. Сущности ApplyChanges и повторяющиеся сущности](http://go.microsoft.com/fwlink/?LinkID=205119&clcid=0x409).  
- При изменении связи между объектами путем задания свойства внешнего ключа ссылка на свойство навигации задается равной NULL и не синхронизируется с основной сущностью на клиенте. После присоединения графа к контексту объекта (например, после вызова метода **ApplyChanges**) свойства внешнего ключа и свойства навигации синхронизируются.  

    > Отсутствие синхронизации свойства навигации ссылки с соответствующим основным объектом может стать причиной проблем, если задано каскадное удаление по связи по внешнему ключу. Если будет удален основной объект, операция удаления не распространится на зависимые объекты. Если заданы каскадные удаления, то для изменения связей следует использовать свойства навигации, а не задавать свойство внешнего ключа.  
- Сущностям с самостоятельным отслеживанием не разрешается использовать отложенную загрузку.  
- Сущности с самостоятельным отслеживанием не поддерживают двоичную сериализацию и сериализацию в объекты управления состоянием ASP.NET. Тем не менее этот шаблон можно изменить в целях добавления поддержки двоичной сериализации. Дополнительные сведения см. в статье [Using Binary Serialization and ViewState with Self-Tracking Entities](http://go.microsoft.com/fwlink/?LinkId=199208) (Использование двоичной сериализации и ViewState с сущностями с самостоятельным отслеживанием).  

### <a name="security-considerations"></a>Вопросы безопасности  

При работе с сущностями с самостоятельным отслеживанием следует учитывать следующие рекомендации по безопасности.  

- Служба не должна доверять запросам на получение или обновление данных, исходящим от клиентов и каналов, не являющихся доверенными. Клиент должен пройти проверку подлинности; следует пользоваться безопасным каналом или конвертом сообщения. Запросы клиентов на обновление или получение данных следует проверять на соответствие ожидаемым и разрешенным изменениям для данного сценария.  
- Не следует использовать в качестве ключей сущностей конфиденциальных сведений (например, номера карточек социального страхования). Тогда конфиденциальные сведения не смогут случайно подвергнуться сериализации в графах сущностей с самостоятельным отслеживанием и попасть к клиенту, который не является полностью доверенным. При использовании независимых сопоставлений исходный ключ сущности, сопоставляемый с сериализуемым, также может быть отправлен клиенту.  
- Чтобы избежать передачи сообщений об исключениях, содержащих конфиденциальные данные, на клиентский уровень, вызовы методов **ApplyChanges** и **SaveChanges** на уровне сервера следует упаковывать в код обработки исключений.  
