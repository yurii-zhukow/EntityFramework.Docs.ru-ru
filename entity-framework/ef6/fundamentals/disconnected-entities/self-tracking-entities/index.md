---
title: Сущности с самостоятельным отслеживанием в EF6
description: Самостоятельное отслеживание сущностей в Entity Framework 6
author: divega
ms.date: 10/23/2016
ms.assetid: 5e60f5be-7bbb-4bf8-835e-0ac808d6c84a
uid: ef6/fundamentals/disconnected-entities/self-tracking-entities/index
ms.openlocfilehash: 0e771c0f147589112779359ab8c06344eb05b8fc
ms.sourcegitcommit: 7c3939504bb9da3f46bea3443638b808c04227c2
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/09/2020
ms.locfileid: "89616180"
---
# <a name="self-tracking-entities"></a><span data-ttu-id="55dc2-103">Сущности с самостоятельным отслеживанием</span><span class="sxs-lookup"><span data-stu-id="55dc2-103">Self-tracking entities</span></span>

> [!IMPORTANT]
> <span data-ttu-id="55dc2-104">Больше не рекомендуется использовать шаблон сущностей с самостоятельным отслеживанием.</span><span class="sxs-lookup"><span data-stu-id="55dc2-104">We no longer recommend using the self-tracking-entities template.</span></span> <span data-ttu-id="55dc2-105">Он по-прежнему будет доступен только для поддержки существующих приложений.</span><span class="sxs-lookup"><span data-stu-id="55dc2-105">It will only continue to be available to support existing applications.</span></span> <span data-ttu-id="55dc2-106">Если приложению необходимо работать с отключенными графами сущностей, рассмотрите другие варианты, такие как [отслеживаемые сущности](https://trackableentities.github.io/), которые технологически эквивалентны сущностям с самостоятельным отслеживанием, активно разрабатываемым сообществом. Или остановитесь на написании пользовательского кода с помощью API-интерфейсов отслеживания изменений низкого уровня.</span><span class="sxs-lookup"><span data-stu-id="55dc2-106">If your application requires working with disconnected graphs of entities, consider other alternatives such as [Trackable Entities](https://trackableentities.github.io/), which is a technology similar to Self-Tracking-Entities that is more actively developed by the community, or writing custom code using the low-level change tracking APIs.</span></span>

<span data-ttu-id="55dc2-107">В приложении на базе Entity Framework контекст отвечает за отслеживание изменений в объектах.</span><span class="sxs-lookup"><span data-stu-id="55dc2-107">In an Entity Framework-based application, a context is responsible for tracking changes in your objects.</span></span> <span data-ttu-id="55dc2-108">Затем изменения сохраняются в базе данных с помощью метода SaveChanges.</span><span class="sxs-lookup"><span data-stu-id="55dc2-108">You then use the SaveChanges method to persist the changes to the database.</span></span> <span data-ttu-id="55dc2-109">При работе с многоуровневыми приложениями объекты сущностей, как правило, отключаются от контекста и необходимо решить, как отслеживать изменения и передавать эти изменения обратно в контекст.</span><span class="sxs-lookup"><span data-stu-id="55dc2-109">When working with N-Tier applications, the entity objects are usually disconnected from the context and you must decide how to track changes and report those changes back to the context.</span></span> <span data-ttu-id="55dc2-110">Сущности с самостоятельным отслеживанием (STE) могут помочь отслеживать изменения на любом уровне и затем воспроизводить их в контексте для сохранения.</span><span class="sxs-lookup"><span data-stu-id="55dc2-110">Self-Tracking Entities (STEs) can help you track changes in any tier and then replay these changes into a context to be saved.</span></span>  

<span data-ttu-id="55dc2-111">Используйте сущности с самостоятельным отслеживанием, только если контекст недоступен на том уровне, где вносятся изменения в граф объекта.</span><span class="sxs-lookup"><span data-stu-id="55dc2-111">Use STEs only if the context is not available on a tier where the changes to the object graph are made.</span></span> <span data-ttu-id="55dc2-112">Если контекст доступен, использовать эти сущности нет необходимости, так как отслеживать изменения будет контекст.</span><span class="sxs-lookup"><span data-stu-id="55dc2-112">If the context is available, there is no need to use STEs because the context will take care of tracking changes.</span></span>  

<span data-ttu-id="55dc2-113">Этот элемент шаблона создает два TT-файла (text template).</span><span class="sxs-lookup"><span data-stu-id="55dc2-113">This template item generates two .tt (text template) files:</span></span>  

- <span data-ttu-id="55dc2-114">Файл **\<model name\>.tt** создает типы сущностей и вспомогательный класс, который содержит логику отслеживания изменений, используемую в сущностях с самостоятельным отслеживанием, и методы расширения, позволяющие задавать состояние этих сущностей.</span><span class="sxs-lookup"><span data-stu-id="55dc2-114">The **\<model name\>.tt** file generates the entity types and a helper class that contains the change-tracking logic that is used by self-tracking entities and the extension methods that allow setting state on self-tracking entities.</span></span>  
- <span data-ttu-id="55dc2-115">Файл **\<model name\>.Context.tt** создает производный контекст и класс расширения, который содержит методы **ApplyChanges** для классов **ObjectContext** и **ObjectSet**.</span><span class="sxs-lookup"><span data-stu-id="55dc2-115">The **\<model name\>.Context.tt** file generates a derived context and an extension class that contains **ApplyChanges** methods for the **ObjectContext** and **ObjectSet** classes.</span></span> <span data-ttu-id="55dc2-116">Эти методы проверяют сведения об отслеживании изменений, которые содержатся в графе сущностей с самостоятельным отслеживанием, чтобы вывести набор операций, которые следует выполнить для сохранения изменений в базе данных.</span><span class="sxs-lookup"><span data-stu-id="55dc2-116">These methods examine the change-tracking information that is contained in the graph of self-tracking entities to infer the set of operations that must be performed to save the changes in the database.</span></span>  

## <a name="get-started"></a><span data-ttu-id="55dc2-117">Приступая к работе</span><span class="sxs-lookup"><span data-stu-id="55dc2-117">Get Started</span></span>  

<span data-ttu-id="55dc2-118">Чтобы приступить к работе, посетите страницу с [пошаговым руководством по использованию сущностей с самостоятельным отслеживанием](xref:ef6/fundamentals/disconnected-entities/self-tracking-entities/walkthrough).</span><span class="sxs-lookup"><span data-stu-id="55dc2-118">To get started, visit the [Self-Tracking Entities Walkthrough](xref:ef6/fundamentals/disconnected-entities/self-tracking-entities/walkthrough) page.</span></span>  

## <a name="functional-considerations-when-working-with-self-tracking-entities"></a><span data-ttu-id="55dc2-119">Рекомендации по функциям при работе с сущностями с автоматическим отслеживанием</span><span class="sxs-lookup"><span data-stu-id="55dc2-119">Functional Considerations When Working with Self-Tracking Entities</span></span>  
> [!IMPORTANT]
> <span data-ttu-id="55dc2-120">Больше не рекомендуется использовать шаблон сущностей с самостоятельным отслеживанием.</span><span class="sxs-lookup"><span data-stu-id="55dc2-120">We no longer recommend using the self-tracking-entities template.</span></span> <span data-ttu-id="55dc2-121">Он по-прежнему будет доступен только для поддержки существующих приложений.</span><span class="sxs-lookup"><span data-stu-id="55dc2-121">It will only continue to be available to support existing applications.</span></span> <span data-ttu-id="55dc2-122">Если приложению необходимо работать с отключенными графами сущностей, рассмотрите другие варианты, такие как [отслеживаемые сущности](https://trackableentities.github.io/), которые технологически эквивалентны сущностям с самостоятельным отслеживанием, активно разрабатываемым сообществом. Или остановитесь на написании пользовательского кода с помощью API-интерфейсов отслеживания изменений низкого уровня.</span><span class="sxs-lookup"><span data-stu-id="55dc2-122">If your application requires working with disconnected graphs of entities, consider other alternatives such as [Trackable Entities](https://trackableentities.github.io/), which is a technology similar to Self-Tracking-Entities that is more actively developed by the community, or writing custom code using the low-level change tracking APIs.</span></span>

<span data-ttu-id="55dc2-123">При работе с сущностями с самостоятельным отслеживанием нужно принимать во внимание следующие соображения.</span><span class="sxs-lookup"><span data-stu-id="55dc2-123">Consider the following when working with self-tracking entities:</span></span>  

- <span data-ttu-id="55dc2-124">Убедитесь в том, что в клиентском проекте имеется ссылка на сборку, содержащую типы сущностей.</span><span class="sxs-lookup"><span data-stu-id="55dc2-124">Make sure that your client project has a reference to the assembly containing the entity types.</span></span> <span data-ttu-id="55dc2-125">Если в клиентский проект будет добавлена только ссылка на службу, то в клиентском проекте будут использоваться прокси-типы WCF, а не действительные типы сущностей с самостоятельным отслеживанием.</span><span class="sxs-lookup"><span data-stu-id="55dc2-125">If you add only the service reference to the client project, the client project will use the WCF proxy types and not the actual self-tracking entity types.</span></span> <span data-ttu-id="55dc2-126">Это означает, что не будут получены средства автоматизированного уведомления, которые управляют отслеживанием сущностей на клиенте.</span><span class="sxs-lookup"><span data-stu-id="55dc2-126">This means that you will not get the automated notification features that manage the tracking of the entities on the client.</span></span> <span data-ttu-id="55dc2-127">Если сознательно решено не включать типы сущностей, то придется вручную задавать сведения отслеживания на клиенте, чтобы изменения передавались обратно в службу.</span><span class="sxs-lookup"><span data-stu-id="55dc2-127">If you intentionally do not want to include the entity types, you will have to manually set change-tracking information on the client for the changes to be sent back to the service.</span></span>  
- <span data-ttu-id="55dc2-128">Вызовы этой операции службы должны быть не поддерживающими состояние и создавать новый экземпляр контекста объекта.</span><span class="sxs-lookup"><span data-stu-id="55dc2-128">Calls to the service operation should be stateless and create a new instance of object context.</span></span> <span data-ttu-id="55dc2-129">Также рекомендуется создавать контекст объекта в блоке **using**.</span><span class="sxs-lookup"><span data-stu-id="55dc2-129">We also recommend that you create object context in a **using** block.</span></span>  
- <span data-ttu-id="55dc2-130">Если после отправки измененного на клиенте графа службе вы намерены продолжать работу с тем же графом на клиенте, то вам придется вручную провести итерацию по графу на клиенте, вызывая для каждого объекта метод **AcceptChanges** для сброса состояния объекта отслеживания изменений.</span><span class="sxs-lookup"><span data-stu-id="55dc2-130">When you send the graph that was modified on the client to the service and then intend to continue working with the same graph on the client, you have to manually iterate through the graph and call the **AcceptChanges** method on each object to reset the change tracker.</span></span>  

    > <span data-ttu-id="55dc2-131">Если объекты в графе содержат свойства со значениями, формируемыми базой данных (например, значения удостоверения или параллелизма), то после вызова метода **SaveChanges** Entity Framework заменит значения этих свойств значениями, сформированными базой данных.</span><span class="sxs-lookup"><span data-stu-id="55dc2-131">If objects in your graph contain properties with database-generated values (for example, identity or concurrency values), Entity Framework will replace values of these properties with the database-generated values after the **SaveChanges** method is called.</span></span> <span data-ttu-id="55dc2-132">Предусмотрена возможность реализовать собственную операцию службы для возврата клиенту сохраненных объектов или списка сформированных значений свойств для объекта.</span><span class="sxs-lookup"><span data-stu-id="55dc2-132">You can implement your service operation to return saved objects or a list of generated property values for the objects back to the client.</span></span> <span data-ttu-id="55dc2-133">Затем клиенту потребуется заменить экземпляры объектов или значения свойств объектов теми объектами или значениями свойств, которые были возвращены из операции службы.</span><span class="sxs-lookup"><span data-stu-id="55dc2-133">The client would then need to replace the object instances or object property values with the objects or property values returned from the service operation.</span></span>  
- <span data-ttu-id="55dc2-134">Объединение графов из нескольких запросов к службе может привести к появлению в итоговом графе повторяющихся значений ключей.</span><span class="sxs-lookup"><span data-stu-id="55dc2-134">Merging graphs from multiple service requests may introduce objects with duplicate key values in the resulting graph.</span></span> <span data-ttu-id="55dc2-135">Entity Framework не удаляет объекты с повторяющимися ключами при вызове метода **ApplyChanges**. Вместо этого формируется исключение.</span><span class="sxs-lookup"><span data-stu-id="55dc2-135">Entity Framework does not remove the objects with duplicate keys when you call the **ApplyChanges** method but instead throws an exception.</span></span> <span data-ttu-id="55dc2-136">Для предотвращения появления графов с повторяющимися значениями ключей придерживайтесь одного из шаблонов, описанных в следующем блоге: [Сущности с самостоятельным отслеживанием. Сущности ApplyChanges и повторяющиеся сущности](https://go.microsoft.com/fwlink/?LinkID=205119&clcid=0x409).</span><span class="sxs-lookup"><span data-stu-id="55dc2-136">To avoid having graphs with duplicate key values follow one of the patterns described in the following blog: [Self-Tracking Entities: ApplyChanges and duplicate entities](https://go.microsoft.com/fwlink/?LinkID=205119&clcid=0x409).</span></span>  
- <span data-ttu-id="55dc2-137">При изменении связи между объектами путем задания свойства внешнего ключа ссылка на свойство навигации задается равной NULL и не синхронизируется с основной сущностью на клиенте.</span><span class="sxs-lookup"><span data-stu-id="55dc2-137">When you change the relationship between objects by setting the foreign key property, the reference navigation property is set to null and not synchronized to the appropriate principal entity on the client.</span></span> <span data-ttu-id="55dc2-138">После присоединения графа к контексту объекта (например, после вызова метода **ApplyChanges**) свойства внешнего ключа и свойства навигации синхронизируются.</span><span class="sxs-lookup"><span data-stu-id="55dc2-138">After the graph is attached to the object context (for example, after you call the **ApplyChanges** method), the foreign key properties and navigation properties are synchronized.</span></span>  

    > <span data-ttu-id="55dc2-139">Отсутствие синхронизации свойства навигации ссылки с соответствующим основным объектом может стать причиной проблем, если задано каскадное удаление по связи по внешнему ключу.</span><span class="sxs-lookup"><span data-stu-id="55dc2-139">Not having a reference navigation property synchronized with the appropriate principal object could be an issue if you have specified cascade delete on the foreign key relationship.</span></span> <span data-ttu-id="55dc2-140">Если будет удален основной объект, операция удаления не распространится на зависимые объекты.</span><span class="sxs-lookup"><span data-stu-id="55dc2-140">If you delete the principal, the delete will not be propagated to the dependent objects.</span></span> <span data-ttu-id="55dc2-141">Если заданы каскадные удаления, то для изменения связей следует использовать свойства навигации, а не задавать свойство внешнего ключа.</span><span class="sxs-lookup"><span data-stu-id="55dc2-141">If you have cascade deletes specified, use navigation properties to change relationships instead of setting the foreign key property.</span></span>  
- <span data-ttu-id="55dc2-142">Сущностям с самостоятельным отслеживанием не разрешается использовать отложенную загрузку.</span><span class="sxs-lookup"><span data-stu-id="55dc2-142">Self-tracking entities are not enabled to perform lazy loading.</span></span>  
- <span data-ttu-id="55dc2-143">Сущности с самостоятельным отслеживанием не поддерживают двоичную сериализацию и сериализацию в объекты управления состоянием ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="55dc2-143">Binary serialization and serialization to ASP.NET state management objects is not supported by self-tracking entities.</span></span> <span data-ttu-id="55dc2-144">Тем не менее этот шаблон можно изменить в целях добавления поддержки двоичной сериализации.</span><span class="sxs-lookup"><span data-stu-id="55dc2-144">However, you can customize the template to add the binary serialization support.</span></span> <span data-ttu-id="55dc2-145">Дополнительные сведения см. в статье [Using Binary Serialization and ViewState with Self-Tracking Entities](https://go.microsoft.com/fwlink/?LinkId=199208) (Использование двоичной сериализации и ViewState с сущностями с самостоятельным отслеживанием).</span><span class="sxs-lookup"><span data-stu-id="55dc2-145">For more information, see [Using Binary Serialization and ViewState with Self-Tracking Entities](https://go.microsoft.com/fwlink/?LinkId=199208).</span></span>  

## <a name="security-considerations"></a><span data-ttu-id="55dc2-146">Вопросы безопасности</span><span class="sxs-lookup"><span data-stu-id="55dc2-146">Security Considerations</span></span>  

<span data-ttu-id="55dc2-147">При работе с сущностями с самостоятельным отслеживанием следует учитывать следующие рекомендации по безопасности.</span><span class="sxs-lookup"><span data-stu-id="55dc2-147">The following security considerations should be taken into account when working with self-tracking entities:</span></span>  

- <span data-ttu-id="55dc2-148">Служба не должна доверять запросам на получение или обновление данных, исходящим от клиентов и каналов, не являющихся доверенными.</span><span class="sxs-lookup"><span data-stu-id="55dc2-148">A service should not trust requests to retrieve or update data from a non-trusted client or through a non-trusted channel.</span></span> <span data-ttu-id="55dc2-149">Клиент должен пройти проверку подлинности; следует пользоваться безопасным каналом или конвертом сообщения.</span><span class="sxs-lookup"><span data-stu-id="55dc2-149">A client must be authenticated: a secure channel or message envelope should be used.</span></span> <span data-ttu-id="55dc2-150">Запросы клиентов на обновление или получение данных следует проверять на соответствие ожидаемым и разрешенным изменениям для данного сценария.</span><span class="sxs-lookup"><span data-stu-id="55dc2-150">Clients' requests to update or retrieve data must be validated to ensure they conform to expected and legitimate changes for the given scenario.</span></span>  
- <span data-ttu-id="55dc2-151">Не следует использовать в качестве ключей сущностей конфиденциальных сведений (например, номера карточек социального страхования).</span><span class="sxs-lookup"><span data-stu-id="55dc2-151">Avoid using sensitive information as entity keys (for example, social security numbers).</span></span> <span data-ttu-id="55dc2-152">Тогда конфиденциальные сведения не смогут случайно подвергнуться сериализации в графах сущностей с самостоятельным отслеживанием и попасть к клиенту, который не является полностью доверенным.</span><span class="sxs-lookup"><span data-stu-id="55dc2-152">This mitigates the possibility of inadvertently serializing sensitive information in the self-tracking entity graphs to a client that is not fully trusted.</span></span> <span data-ttu-id="55dc2-153">При использовании независимых сопоставлений исходный ключ сущности, сопоставляемый с сериализуемым, также может быть отправлен клиенту.</span><span class="sxs-lookup"><span data-stu-id="55dc2-153">With independent associations, the original key of an entity that is related to the one that is being serialized might be sent to the client as well.</span></span>  
- <span data-ttu-id="55dc2-154">Чтобы избежать передачи сообщений об исключениях, содержащих конфиденциальные данные, на клиентский уровень, вызовы методов **ApplyChanges** и **SaveChanges** на уровне сервера следует упаковывать в код обработки исключений.</span><span class="sxs-lookup"><span data-stu-id="55dc2-154">To avoid propagating exception messages that contain sensitive data to the client tier, calls to **ApplyChanges** and **SaveChanges** on the server tier should be wrapped in exception-handling code.</span></span>  
