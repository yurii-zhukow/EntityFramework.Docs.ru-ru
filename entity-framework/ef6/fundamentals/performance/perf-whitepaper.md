---
title: Соображения производительности для EF4, EF5 и EF6 - EF6
author: divega
ms.date: 10/23/2016
ms.assetid: d6d5a465-6434-45fa-855d-5eb48c61a2ea
ms.openlocfilehash: 0ece383bb5083b41c7a2636c009473333af6d3e2
ms.sourcegitcommit: 144edccf9b29a7ffad119c235ac9808ec1a46193
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2020
ms.locfileid: "81434343"
---
# <a name="performance-considerations-for-ef-4-5-and-6"></a><span data-ttu-id="a51a5-102">Соображения производительности для EF 4, 5 и 6</span><span class="sxs-lookup"><span data-stu-id="a51a5-102">Performance considerations for EF 4, 5, and 6</span></span>
<span data-ttu-id="a51a5-103">Дэвид Оландо, Эрик Деттингер и другие</span><span class="sxs-lookup"><span data-stu-id="a51a5-103">By David Obando, Eric Dettinger and others</span></span>

<span data-ttu-id="a51a5-104">Опубликовано: Апрель 2012</span><span class="sxs-lookup"><span data-stu-id="a51a5-104">Published: April 2012</span></span>

<span data-ttu-id="a51a5-105">Последнее обновление: май 2014 г.</span><span class="sxs-lookup"><span data-stu-id="a51a5-105">Last updated: May 2014</span></span>

------------------------------------------------------------------------

## <a name="1-introduction"></a><span data-ttu-id="a51a5-106">1. Введение</span><span class="sxs-lookup"><span data-stu-id="a51a5-106">1. Introduction</span></span>

<span data-ttu-id="a51a5-107">Платформы объектно-реляционного картирования — это удобный способ обеспечить абстракцию для доступа к данным в объектно-ориентированном приложении.</span><span class="sxs-lookup"><span data-stu-id="a51a5-107">Object-Relational Mapping frameworks are a convenient way to provide an abstraction for data access in an object-oriented application.</span></span> <span data-ttu-id="a51a5-108">Для приложений .NET рекомендуемая корпорация Майкрософт O/RM является системой Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="a51a5-108">For .NET applications, Microsoft's recommended O/RM is Entity Framework.</span></span> <span data-ttu-id="a51a5-109">С любой абстракции, хотя, производительность может стать проблемой.</span><span class="sxs-lookup"><span data-stu-id="a51a5-109">With any abstraction though, performance can become a concern.</span></span>

<span data-ttu-id="a51a5-110">Этот документ был написан, чтобы показать соображения производительности при разработке приложений с использованием Entity Framework, дать разработчикам представление о внутренних алгоритмах Entity Framework, которые могут повлиять на производительность, и предоставить советы по исследованию и повышению производительности в своих приложениях, использующих рамки сущности.</span><span class="sxs-lookup"><span data-stu-id="a51a5-110">This whitepaper was written to show the performance considerations when developing applications using Entity Framework, to give developers an idea of the Entity Framework internal algorithms that can affect performance, and to provide tips for investigation and improving performance in their applications that use Entity Framework.</span></span> <span data-ttu-id="a51a5-111">Есть ряд хороших тем по производительности уже доступны в Интернете, и мы также пытались указывая на эти ресурсы, где это возможно.</span><span class="sxs-lookup"><span data-stu-id="a51a5-111">There are a number of good topics on performance already available on the web, and we've also tried pointing to these resources where possible.</span></span>

<span data-ttu-id="a51a5-112">Производительность является сложной темой.</span><span class="sxs-lookup"><span data-stu-id="a51a5-112">Performance is a tricky topic.</span></span> <span data-ttu-id="a51a5-113">Этот информационный документ предназначен в качестве ресурса, который поможет вам принимать решения, связанные с производительностью, для приложений, которые используют рамки сущности.</span><span class="sxs-lookup"><span data-stu-id="a51a5-113">This whitepaper is intended as a resource to help you make performance related decisions for your applications that use Entity Framework.</span></span> <span data-ttu-id="a51a5-114">Мы включили некоторые тестовые метрики, чтобы продемонстрировать производительность, но эти показатели не предназначены в качестве абсолютных показателей производительности, которые вы увидите в приложении.</span><span class="sxs-lookup"><span data-stu-id="a51a5-114">We have included some test metrics to demonstrate performance, but these metrics aren't intended as absolute indicators of the performance you will see in your application.</span></span>

<span data-ttu-id="a51a5-115">Для практических целей этот документ предполагает, что Рамочная система сущности 4 работает в соответствии с .NET 4.0, а Рамочная система сущности 5 и 6 — под .NET 4.5.</span><span class="sxs-lookup"><span data-stu-id="a51a5-115">For practical purposes, this document assumes Entity Framework 4 is run under .NET 4.0 and Entity Framework 5 and 6 are run under .NET 4.5.</span></span> <span data-ttu-id="a51a5-116">Многие улучшения производительности, сделанные для Entity Framework 5, находятся в основных компонентах, которые появляются с .NET 4.5.</span><span class="sxs-lookup"><span data-stu-id="a51a5-116">Many of the performance improvements made for Entity Framework 5 reside within the core components that ship with .NET 4.5.</span></span>

<span data-ttu-id="a51a5-117">Entity Framework 6 является выходом из диапазона и не зависит от компонентов Entity Framework, которые появляются с .NET.</span><span class="sxs-lookup"><span data-stu-id="a51a5-117">Entity Framework 6 is an out of band release and does not depend on the Entity Framework components that ship with .NET.</span></span> <span data-ttu-id="a51a5-118">Система Entity Framework 6 работает как на .NET 4.0, так и на .NET 4.5, и может предложить большую выгоду для производительности для тех, кто еще не обновился с .NET 4.0, но хочет последние биты Entity Framework в их приложении.</span><span class="sxs-lookup"><span data-stu-id="a51a5-118">Entity Framework 6 work on both .NET 4.0 and .NET 4.5, and can offer a big performance benefit to those who haven’t upgraded from .NET 4.0 but want the latest Entity Framework bits in their application.</span></span> <span data-ttu-id="a51a5-119">Когда в этом документе упоминается рамка сущности 6, он ссылается на последнюю версию, доступную на момент написания настоящего письма: версия 6.1.0.</span><span class="sxs-lookup"><span data-stu-id="a51a5-119">When this document mentions Entity Framework 6, it refers to the latest version available at the time of this writing: version 6.1.0.</span></span>

## <a name="2-cold-vs-warm-query-execution"></a><span data-ttu-id="a51a5-120">2. Холод против теплого исполнения запросов</span><span class="sxs-lookup"><span data-stu-id="a51a5-120">2. Cold vs. Warm Query Execution</span></span>

<span data-ttu-id="a51a5-121">При первом запросе, который выполняется в отношении данной модели, система entity Framework выполняет большую работу за кулисами для загрузки и проверки модели.</span><span class="sxs-lookup"><span data-stu-id="a51a5-121">The very first time any query is made against a given model, the Entity Framework does a lot of work behind the scenes to load and validate the model.</span></span> <span data-ttu-id="a51a5-122">Мы часто называем этот первый запрос «холодным».</span><span class="sxs-lookup"><span data-stu-id="a51a5-122">We frequently refer to this first query as a "cold" query.</span></span><span data-ttu-id="a51a5-123">Дальнейшие запросы в отношении уже загруженной модели известны как "теплые" запросы и гораздо быстрее.</span><span class="sxs-lookup"><span data-stu-id="a51a5-123">  Further queries against an already loaded model are known as "warm" queries, and are much faster.</span></span>

<span data-ttu-id="a51a5-124">Давайте рассмотрим, где время тратится на выполнение запроса с использованием рамочного образования, и посмотрим, где ситуация улучшается в рамках entity 6.</span><span class="sxs-lookup"><span data-stu-id="a51a5-124">Let’s take a high-level view of where time is spent when executing a query using Entity Framework, and see where things are improving in Entity Framework 6.</span></span>

<span data-ttu-id="a51a5-125">**Первое выполнение запроса - холодный запрос**</span><span class="sxs-lookup"><span data-stu-id="a51a5-125">**First Query Execution – cold query**</span></span>

| <span data-ttu-id="a51a5-126">Записывает код пользователя</span><span class="sxs-lookup"><span data-stu-id="a51a5-126">Code User Writes</span></span>                                                                                     | <span data-ttu-id="a51a5-127">Действие</span><span class="sxs-lookup"><span data-stu-id="a51a5-127">Action</span></span>                    | <span data-ttu-id="a51a5-128">Влияние производительности EF4</span><span class="sxs-lookup"><span data-stu-id="a51a5-128">EF4 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                        | <span data-ttu-id="a51a5-129">Влияние производительности EF5</span><span class="sxs-lookup"><span data-stu-id="a51a5-129">EF5 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                    | <span data-ttu-id="a51a5-130">Влияние производительности EF6</span><span class="sxs-lookup"><span data-stu-id="a51a5-130">EF6 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | <span data-ttu-id="a51a5-131">Создание контекста</span><span class="sxs-lookup"><span data-stu-id="a51a5-131">Context creation</span></span>          | <span data-ttu-id="a51a5-132">Средний</span><span class="sxs-lookup"><span data-stu-id="a51a5-132">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                        | <span data-ttu-id="a51a5-133">Средний</span><span class="sxs-lookup"><span data-stu-id="a51a5-133">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | <span data-ttu-id="a51a5-134">Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-134">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | <span data-ttu-id="a51a5-135">Создание выражения запроса</span><span class="sxs-lookup"><span data-stu-id="a51a5-135">Query expression creation</span></span> | <span data-ttu-id="a51a5-136">Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-136">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           | <span data-ttu-id="a51a5-137">Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-137">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | <span data-ttu-id="a51a5-138">Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-138">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var c1 = q1.First();`                                                                             | <span data-ttu-id="a51a5-139">Выполнение запроса LIN's</span><span class="sxs-lookup"><span data-stu-id="a51a5-139">LINQ query execution</span></span>      | <span data-ttu-id="a51a5-140">- Метаданные загрузки: высокая, но кэшированная</span><span class="sxs-lookup"><span data-stu-id="a51a5-140">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="a51a5-141">- Представление поколения: Потенциально очень высокий, но кэшированный</span><span class="sxs-lookup"><span data-stu-id="a51a5-141">- View generation: Potentially very high but cached</span></span> <br/> <span data-ttu-id="a51a5-142">- Оценка параметров: Средний</span><span class="sxs-lookup"><span data-stu-id="a51a5-142">- Parameter evaluation: Medium</span></span> <br/> <span data-ttu-id="a51a5-143">- Перевод запроса: Средний</span><span class="sxs-lookup"><span data-stu-id="a51a5-143">- Query translation: Medium</span></span> <br/> <span data-ttu-id="a51a5-144">- Материализатор поколения: Средний, но кэшированный</span><span class="sxs-lookup"><span data-stu-id="a51a5-144">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="a51a5-145">- Выполнение запроса базы данных: потенциально высокий</span><span class="sxs-lookup"><span data-stu-id="a51a5-145">- Database query execution: Potentially high</span></span> <br/> <span data-ttu-id="a51a5-146">Подключение.Открытый</span><span class="sxs-lookup"><span data-stu-id="a51a5-146">+ Connection.Open</span></span> <br/> <span data-ttu-id="a51a5-147">- Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="a51a5-147">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="a51a5-148">- DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="a51a5-148">+ DataReader.Read</span></span> <br/> <span data-ttu-id="a51a5-149">Материализация объекта: Средний</span><span class="sxs-lookup"><span data-stu-id="a51a5-149">Object materialization: Medium</span></span> <br/> <span data-ttu-id="a51a5-150">- Идентификационный поиск: Средний</span><span class="sxs-lookup"><span data-stu-id="a51a5-150">- Identity lookup: Medium</span></span> | <span data-ttu-id="a51a5-151">- Метаданные загрузки: высокая, но кэшированная</span><span class="sxs-lookup"><span data-stu-id="a51a5-151">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="a51a5-152">- Представление поколения: Потенциально очень высокий, но кэшированный</span><span class="sxs-lookup"><span data-stu-id="a51a5-152">- View generation: Potentially very high but cached</span></span> <br/> <span data-ttu-id="a51a5-153">- Оценка параметров: Низкая</span><span class="sxs-lookup"><span data-stu-id="a51a5-153">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="a51a5-154">- Перевод запроса: Средний, но кэшированный</span><span class="sxs-lookup"><span data-stu-id="a51a5-154">- Query translation: Medium but cached</span></span> <br/> <span data-ttu-id="a51a5-155">- Материализатор поколения: Средний, но кэшированный</span><span class="sxs-lookup"><span data-stu-id="a51a5-155">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="a51a5-156">- Выполнение запроса базы данных: потенциально высокий (лучшие запросы в некоторых ситуациях)</span><span class="sxs-lookup"><span data-stu-id="a51a5-156">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="a51a5-157">Подключение.Открытый</span><span class="sxs-lookup"><span data-stu-id="a51a5-157">+ Connection.Open</span></span> <br/> <span data-ttu-id="a51a5-158">- Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="a51a5-158">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="a51a5-159">- DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="a51a5-159">+ DataReader.Read</span></span> <br/> <span data-ttu-id="a51a5-160">Материализация объекта: Средний</span><span class="sxs-lookup"><span data-stu-id="a51a5-160">Object materialization: Medium</span></span> <br/> <span data-ttu-id="a51a5-161">- Идентификационный поиск: Средний</span><span class="sxs-lookup"><span data-stu-id="a51a5-161">- Identity lookup: Medium</span></span> | <span data-ttu-id="a51a5-162">- Метаданные загрузки: высокая, но кэшированная</span><span class="sxs-lookup"><span data-stu-id="a51a5-162">- Metadata loading: High but cached</span></span> <br/> <span data-ttu-id="a51a5-163">- Представление поколения: Средний, но кэшированный</span><span class="sxs-lookup"><span data-stu-id="a51a5-163">- View generation: Medium but cached</span></span> <br/> <span data-ttu-id="a51a5-164">- Оценка параметров: Низкая</span><span class="sxs-lookup"><span data-stu-id="a51a5-164">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="a51a5-165">- Перевод запроса: Средний, но кэшированный</span><span class="sxs-lookup"><span data-stu-id="a51a5-165">- Query translation: Medium but cached</span></span> <br/> <span data-ttu-id="a51a5-166">- Материализатор поколения: Средний, но кэшированный</span><span class="sxs-lookup"><span data-stu-id="a51a5-166">- Materializer generation: Medium but cached</span></span> <br/> <span data-ttu-id="a51a5-167">- Выполнение запроса базы данных: потенциально высокий (лучшие запросы в некоторых ситуациях)</span><span class="sxs-lookup"><span data-stu-id="a51a5-167">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="a51a5-168">Подключение.Открытый</span><span class="sxs-lookup"><span data-stu-id="a51a5-168">+ Connection.Open</span></span> <br/> <span data-ttu-id="a51a5-169">- Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="a51a5-169">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="a51a5-170">- DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="a51a5-170">+ DataReader.Read</span></span> <br/> <span data-ttu-id="a51a5-171">Материализация объекта: Средний (Быстрее, чем EF5)</span><span class="sxs-lookup"><span data-stu-id="a51a5-171">Object materialization: Medium (Faster than EF5)</span></span> <br/> <span data-ttu-id="a51a5-172">- Идентификационный поиск: Средний</span><span class="sxs-lookup"><span data-stu-id="a51a5-172">- Identity lookup: Medium</span></span> |
| `}`                                                                                                  | <span data-ttu-id="a51a5-173">Соединение.Закрыть</span><span class="sxs-lookup"><span data-stu-id="a51a5-173">Connection.Close</span></span>          | <span data-ttu-id="a51a5-174">Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-174">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                           | <span data-ttu-id="a51a5-175">Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-175">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | <span data-ttu-id="a51a5-176">Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-176">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |


<span data-ttu-id="a51a5-177">**Выполнение второго запроса — теплый запрос**</span><span class="sxs-lookup"><span data-stu-id="a51a5-177">**Second Query Execution – warm query**</span></span>

| <span data-ttu-id="a51a5-178">Записывает код пользователя</span><span class="sxs-lookup"><span data-stu-id="a51a5-178">Code User Writes</span></span>                                                                                     | <span data-ttu-id="a51a5-179">Действие</span><span class="sxs-lookup"><span data-stu-id="a51a5-179">Action</span></span>                    | <span data-ttu-id="a51a5-180">Влияние производительности EF4</span><span class="sxs-lookup"><span data-stu-id="a51a5-180">EF4 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | <span data-ttu-id="a51a5-181">Влияние производительности EF5</span><span class="sxs-lookup"><span data-stu-id="a51a5-181">EF5 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | <span data-ttu-id="a51a5-182">Влияние производительности EF6</span><span class="sxs-lookup"><span data-stu-id="a51a5-182">EF6 Performance Impact</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | <span data-ttu-id="a51a5-183">Создание контекста</span><span class="sxs-lookup"><span data-stu-id="a51a5-183">Context creation</span></span>          | <span data-ttu-id="a51a5-184">Средний</span><span class="sxs-lookup"><span data-stu-id="a51a5-184">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | <span data-ttu-id="a51a5-185">Средний</span><span class="sxs-lookup"><span data-stu-id="a51a5-185">Medium</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | <span data-ttu-id="a51a5-186">Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-186">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | <span data-ttu-id="a51a5-187">Создание выражения запроса</span><span class="sxs-lookup"><span data-stu-id="a51a5-187">Query expression creation</span></span> | <span data-ttu-id="a51a5-188">Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-188">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | <span data-ttu-id="a51a5-189">Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-189">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | <span data-ttu-id="a51a5-190">Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-190">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var c1 = q1.First();`                                                                             | <span data-ttu-id="a51a5-191">Выполнение запроса LIN's</span><span class="sxs-lookup"><span data-stu-id="a51a5-191">LINQ query execution</span></span>      | <span data-ttu-id="a51a5-192">- Метаданные ~~загрузки~~ поиска: ~~Высокий, но кэшированный~~ Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-192">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="a51a5-193">- Просмотр ~~поколения~~ поиска: ~~Потенциально очень высокий, но кэшированный~~ Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-193">- View ~~generation~~ lookup: ~~Potentially very high but cached~~ Low</span></span> <br/> <span data-ttu-id="a51a5-194">- Оценка параметров: Средний</span><span class="sxs-lookup"><span data-stu-id="a51a5-194">- Parameter evaluation: Medium</span></span> <br/> <span data-ttu-id="a51a5-195">- Поиск ~~перевода~~ запроса: Средний</span><span class="sxs-lookup"><span data-stu-id="a51a5-195">- Query ~~translation~~ lookup: Medium</span></span> <br/> <span data-ttu-id="a51a5-196">- Materializer ~~поколения~~ поиска: ~~Средний, но кэшированный~~ Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-196">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="a51a5-197">- Выполнение запроса базы данных: потенциально высокий</span><span class="sxs-lookup"><span data-stu-id="a51a5-197">- Database query execution: Potentially high</span></span> <br/> <span data-ttu-id="a51a5-198">Подключение.Открытый</span><span class="sxs-lookup"><span data-stu-id="a51a5-198">+ Connection.Open</span></span> <br/> <span data-ttu-id="a51a5-199">- Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="a51a5-199">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="a51a5-200">- DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="a51a5-200">+ DataReader.Read</span></span> <br/> <span data-ttu-id="a51a5-201">Материализация объекта: Средний</span><span class="sxs-lookup"><span data-stu-id="a51a5-201">Object materialization: Medium</span></span> <br/> <span data-ttu-id="a51a5-202">- Идентификационный поиск: Средний</span><span class="sxs-lookup"><span data-stu-id="a51a5-202">- Identity lookup: Medium</span></span> | <span data-ttu-id="a51a5-203">- Метаданные ~~загрузки~~ поиска: ~~Высокий, но кэшированный~~ Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-203">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="a51a5-204">- Просмотр ~~поколения~~ поиска: ~~Потенциально очень высокий, но кэшированный~~ Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-204">- View ~~generation~~ lookup: ~~Potentially very high but cached~~ Low</span></span> <br/> <span data-ttu-id="a51a5-205">- Оценка параметров: Низкая</span><span class="sxs-lookup"><span data-stu-id="a51a5-205">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="a51a5-206">- Поиск ~~перевода~~ запроса: ~~Средний, но кэшированный~~ Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-206">- Query ~~translation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="a51a5-207">- Materializer ~~поколения~~ поиска: ~~Средний, но кэшированный~~ Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-207">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="a51a5-208">- Выполнение запроса базы данных: потенциально высокий (лучшие запросы в некоторых ситуациях)</span><span class="sxs-lookup"><span data-stu-id="a51a5-208">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="a51a5-209">Подключение.Открытый</span><span class="sxs-lookup"><span data-stu-id="a51a5-209">+ Connection.Open</span></span> <br/> <span data-ttu-id="a51a5-210">- Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="a51a5-210">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="a51a5-211">- DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="a51a5-211">+ DataReader.Read</span></span> <br/> <span data-ttu-id="a51a5-212">Материализация объекта: Средний</span><span class="sxs-lookup"><span data-stu-id="a51a5-212">Object materialization: Medium</span></span> <br/> <span data-ttu-id="a51a5-213">- Идентификационный поиск: Средний</span><span class="sxs-lookup"><span data-stu-id="a51a5-213">- Identity lookup: Medium</span></span> | <span data-ttu-id="a51a5-214">- Метаданные ~~загрузки~~ поиска: ~~Высокий, но кэшированный~~ Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-214">- Metadata ~~loading~~ lookup: ~~High but cached~~ Low</span></span> <br/> <span data-ttu-id="a51a5-215">- Просмотр ~~поколения~~ поиска: ~~Средний, но кэшированный~~ Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-215">- View ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="a51a5-216">- Оценка параметров: Низкая</span><span class="sxs-lookup"><span data-stu-id="a51a5-216">- Parameter evaluation: Low</span></span> <br/> <span data-ttu-id="a51a5-217">- Поиск ~~перевода~~ запроса: ~~Средний, но кэшированный~~ Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-217">- Query ~~translation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="a51a5-218">- Materializer ~~поколения~~ поиска: ~~Средний, но кэшированный~~ Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-218">- Materializer ~~generation~~ lookup: ~~Medium but cached~~ Low</span></span> <br/> <span data-ttu-id="a51a5-219">- Выполнение запроса базы данных: потенциально высокий (лучшие запросы в некоторых ситуациях)</span><span class="sxs-lookup"><span data-stu-id="a51a5-219">- Database query execution: Potentially high (Better queries in some situations)</span></span> <br/> <span data-ttu-id="a51a5-220">Подключение.Открытый</span><span class="sxs-lookup"><span data-stu-id="a51a5-220">+ Connection.Open</span></span> <br/> <span data-ttu-id="a51a5-221">- Command.ExecuteReader</span><span class="sxs-lookup"><span data-stu-id="a51a5-221">+ Command.ExecuteReader</span></span> <br/> <span data-ttu-id="a51a5-222">- DataReader.Read</span><span class="sxs-lookup"><span data-stu-id="a51a5-222">+ DataReader.Read</span></span> <br/> <span data-ttu-id="a51a5-223">Материализация объекта: Средний (Быстрее, чем EF5)</span><span class="sxs-lookup"><span data-stu-id="a51a5-223">Object materialization: Medium (Faster than EF5)</span></span> <br/> <span data-ttu-id="a51a5-224">- Идентификационный поиск: Средний</span><span class="sxs-lookup"><span data-stu-id="a51a5-224">- Identity lookup: Medium</span></span> |
| `}`                                                                                                  | <span data-ttu-id="a51a5-225">Соединение.Закрыть</span><span class="sxs-lookup"><span data-stu-id="a51a5-225">Connection.Close</span></span>          | <span data-ttu-id="a51a5-226">Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-226">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | <span data-ttu-id="a51a5-227">Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-227">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | <span data-ttu-id="a51a5-228">Низкий</span><span class="sxs-lookup"><span data-stu-id="a51a5-228">Low</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |


<span data-ttu-id="a51a5-229">Существует несколько способов снижения эксплуатационных расходов как холодных, так и теплых запросов, и мы рассмотрим их в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="a51a5-229">There are several ways to reduce the performance cost of both cold and warm queries, and we'll take a look at these in the following section.</span></span> <span data-ttu-id="a51a5-230">В частности, мы рассмотрим снижение стоимости загрузки модели в холодных запросах с помощью предварительно созданных представлений, которые должны помочь облегчить работу с нагрузками, испытываемыми во время генерации представления.</span><span class="sxs-lookup"><span data-stu-id="a51a5-230">Specifically, we'll look at reducing the cost of model loading in cold queries by using pre-generated views, which should help alleviate performance pains experienced during view generation.</span></span> <span data-ttu-id="a51a5-231">Для теплых запросов мы рассмотрим кэширование плана запросов, отсутствие запросов отслеживания и различные параметры выполнения запросов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-231">For warm queries, we'll cover query plan caching, no tracking queries, and different query execution options.</span></span>

### <a name="21-what-is-view-generation"></a><span data-ttu-id="a51a5-232">2.1 Что такое поколение представления?</span><span class="sxs-lookup"><span data-stu-id="a51a5-232">2.1 What is View Generation?</span></span>

<span data-ttu-id="a51a5-233">Для того, чтобы понять, что такое генерация представления, мы должны сначала понять, что такое "Картирование просмотров".</span><span class="sxs-lookup"><span data-stu-id="a51a5-233">In order to understand what view generation is, we must first understand what “Mapping Views” are.</span></span> <span data-ttu-id="a51a5-234">Представления отображения являются исполняемыми представлениями преобразований, указанных в отображении для каждого набора и ассоциации сущности.</span><span class="sxs-lookup"><span data-stu-id="a51a5-234">Mapping Views are executable representations of the transformations specified in the mapping for each entity set and association.</span></span> <span data-ttu-id="a51a5-235">Внутренне эти отображающие представления принимают форму КТ (канонических деревьев запросов).</span><span class="sxs-lookup"><span data-stu-id="a51a5-235">Internally, these mapping views take the shape of CQTs (canonical query trees).</span></span> <span data-ttu-id="a51a5-236">Существует два типа картографических представлений:</span><span class="sxs-lookup"><span data-stu-id="a51a5-236">There are two types of mapping views:</span></span>

-   <span data-ttu-id="a51a5-237">Представления запросов: они представляют собой преобразование, необходимое для перехода от схемы базы данных к концептуальной модели.</span><span class="sxs-lookup"><span data-stu-id="a51a5-237">Query views: these represent the transformation necessary to go from the database schema to the conceptual model.</span></span>
-   <span data-ttu-id="a51a5-238">Обновления представлений: они представляют собой преобразование, необходимое для перехода от концептуальной модели к схеме базы данных.</span><span class="sxs-lookup"><span data-stu-id="a51a5-238">Update views: these represent the transformation necessary to go from the conceptual model to the database schema.</span></span>

<span data-ttu-id="a51a5-239">Имейте в виду, что концептуальная модель может отличаться от схемы базы данных различными способами.</span><span class="sxs-lookup"><span data-stu-id="a51a5-239">Keep in mind that the conceptual model might differ from the database schema in various ways.</span></span> <span data-ttu-id="a51a5-240">Например, для хранения данных для двух типов различных сущностей может использоваться одна таблица.</span><span class="sxs-lookup"><span data-stu-id="a51a5-240">For example, one single table might be used to store the data for two different entity types.</span></span> <span data-ttu-id="a51a5-241">Наследование и нетривиальные отображения играют определенную роль в сложности представлений отображения.</span><span class="sxs-lookup"><span data-stu-id="a51a5-241">Inheritance and non-trivial mappings play a role in the complexity of the mapping views.</span></span>

<span data-ttu-id="a51a5-242">Процесс вычисления этих представлений на основе спецификации отображения является то, что мы называем генерации представления.</span><span class="sxs-lookup"><span data-stu-id="a51a5-242">The process of computing these views based on the specification of the mapping is what we call view generation.</span></span> <span data-ttu-id="a51a5-243">Генерация представления может происходить динамически при загрузке модели или во время сборки, используя "предварительно созданные представления"; последние сериализируются в виде инструкций Entity\# S'L к файлу C или VB.</span><span class="sxs-lookup"><span data-stu-id="a51a5-243">View generation can either take place dynamically when a model is loaded, or at build time, by using "pre-generated views"; the latter are serialized in the form of Entity SQL statements to a C\# or VB file.</span></span>

<span data-ttu-id="a51a5-244">При сгенерировании представлений они также проверяются.</span><span class="sxs-lookup"><span data-stu-id="a51a5-244">When views are generated, they are also validated.</span></span> <span data-ttu-id="a51a5-245">С точки зрения производительности, подавляющее большинство затрат генерации представления на самом деле является проверка представлений, которая гарантирует, что соединения между объектами имеют смысл и имеют правильную кардинальность для всех поддерживаемых операций.</span><span class="sxs-lookup"><span data-stu-id="a51a5-245">From a performance standpoint, the vast majority of the cost of view generation is actually the validation of the views which ensures that the connections between the entities make sense and have the correct cardinality for all the supported operations.</span></span>

<span data-ttu-id="a51a5-246">При выполнении запроса над набором сущности запрос сочетается с соответствующим представлением запроса, и результат этой композиции выполняется через компилятор плана для создания представления запроса, который может понять резервный магазин.</span><span class="sxs-lookup"><span data-stu-id="a51a5-246">When a query over an entity set is executed, the query is combined with the corresponding query view, and the result of this composition is run through the plan compiler to create the representation of the query that the backing store can understand.</span></span> <span data-ttu-id="a51a5-247">Для сервера S'L, конечным результатом этой компиляции будет заявление T-S'L SELECT.</span><span class="sxs-lookup"><span data-stu-id="a51a5-247">For SQL Server, the final result of this compilation will be a T-SQL SELECT statement.</span></span> <span data-ttu-id="a51a5-248">При первом выполнении обновления набора сущности представление обновления выполняется аналогичным процессом для преобразования его в DML-выписки для целевой базы данных.</span><span class="sxs-lookup"><span data-stu-id="a51a5-248">The first time an update over an entity set is performed, the update view is run through a similar process to transform it into DML statements for the target database.</span></span>

### <a name="22-factors-that-affect-view-generation-performance"></a><span data-ttu-id="a51a5-249">2.2 Факторы, влияющие на производительность генерации представления</span><span class="sxs-lookup"><span data-stu-id="a51a5-249">2.2 Factors that affect View Generation performance</span></span>

<span data-ttu-id="a51a5-250">Производительность шага генерации представления зависит не только от размера модели, но и от того, насколько взаимосвязана модель.</span><span class="sxs-lookup"><span data-stu-id="a51a5-250">The performance of view generation step not only depends on the size of your model but also on how interconnected the model is.</span></span> <span data-ttu-id="a51a5-251">Если две Сущности связаны через цепочку наследования или Ассоциацию, они, как утверждается, связаны между собой.</span><span class="sxs-lookup"><span data-stu-id="a51a5-251">If two Entities are connected via an inheritance chain or an Association, they are said to be connected.</span></span> <span data-ttu-id="a51a5-252">Аналогичным образом, если две таблицы соединены через иностранный ключ, они соединены.</span><span class="sxs-lookup"><span data-stu-id="a51a5-252">Similarly if two tables are connected via a foreign key, they are connected.</span></span> <span data-ttu-id="a51a5-253">По мере увеличения числа подключенных сущностей и таблиц в схемах увеличивается стоимость генерации представления.</span><span class="sxs-lookup"><span data-stu-id="a51a5-253">As the number of connected Entities and tables in your schemas increase, the view generation cost increases.</span></span>

<span data-ttu-id="a51a5-254">Алгоритм, который мы используем для генерации и проверки представлений, является экспоненциальным в худшем случае, хотя мы используем некоторые оптимизации для улучшения этого.</span><span class="sxs-lookup"><span data-stu-id="a51a5-254">The algorithm that we use to generate and validate views is exponential in the worst case, though we do use some optimizations to improve this.</span></span> <span data-ttu-id="a51a5-255">Самые большие факторы, которые, как представляется, негативно влияют на производительность являются:</span><span class="sxs-lookup"><span data-stu-id="a51a5-255">The biggest factors that seem to negatively affect performance are:</span></span>

-   <span data-ttu-id="a51a5-256">Размер модели, относящийся к количеству сущностей и количеству ассоциаций между этими сущностями.</span><span class="sxs-lookup"><span data-stu-id="a51a5-256">Model size, referring to the number of entities and the amount of associations between these entities.</span></span>
-   <span data-ttu-id="a51a5-257">Сложность модели, в частности наследования с большим количеством типов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-257">Model complexity, specifically inheritance involving a large number of types.</span></span>
-   <span data-ttu-id="a51a5-258">Использование независимых ассоциаций, а не иностранных ключевых ассоциаций.</span><span class="sxs-lookup"><span data-stu-id="a51a5-258">Using Independent Associations, instead of Foreign Key Associations.</span></span>

<span data-ttu-id="a51a5-259">Для небольших, простых моделей стоимость может быть достаточно небольшой, чтобы не беспокоить с помощью предварительно сгенерированных представлений.</span><span class="sxs-lookup"><span data-stu-id="a51a5-259">For small, simple models the cost may be small enough to not bother using pre-generated views.</span></span> <span data-ttu-id="a51a5-260">По мере увеличения размера и сложности модели существует несколько вариантов снижения стоимости генерации и проверки представления.</span><span class="sxs-lookup"><span data-stu-id="a51a5-260">As model size and complexity increase, there are several options available to reduce the cost of view generation and validation.</span></span>

### <a name="23-using-pre-generated-views-to-decrease-model-load-time"></a><span data-ttu-id="a51a5-261">2.3 Использование предгенерированных представлений для уменьшения времени загрузки модели</span><span class="sxs-lookup"><span data-stu-id="a51a5-261">2.3 Using Pre-Generated Views to decrease model load time</span></span>

<span data-ttu-id="a51a5-262">Для получения подробной информации о том, как использовать предварительно созданные представления на рамках Entity Framework 6, посетите [предварительно созданные представления о сопоставлении](~/ef6/fundamentals/performance/pre-generated-views.md)</span><span class="sxs-lookup"><span data-stu-id="a51a5-262">For detailed information on how to use pre-generated views on Entity Framework 6 visit [Pre-Generated Mapping Views](~/ef6/fundamentals/performance/pre-generated-views.md)</span></span>

#### <a name="231-pre-generated-views-using-the-entity-framework-power-tools-community-edition"></a><span data-ttu-id="a51a5-263">2.3.1 Предварительно созданные представления с помощью сообщества Entity Framework Power Tools Edition</span><span class="sxs-lookup"><span data-stu-id="a51a5-263">2.3.1 Pre-Generated views using the Entity Framework Power Tools Community Edition</span></span>

<span data-ttu-id="a51a5-264">Вы можете использовать [Entity Framework 6 Power Tools Community Edition](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) для генерации представлений моделей EDMX и Code First, нажав правой кнопкой мыши на файл класса модели и используя меню Entity Framework для выбора "Generate Views".</span><span class="sxs-lookup"><span data-stu-id="a51a5-264">You can use the [Entity Framework 6 Power Tools Community Edition](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) to generate views of EDMX and Code First models by right-clicking the model class file and using the Entity Framework menu to select “Generate Views”.</span></span> <span data-ttu-id="a51a5-265">Сообщество Power Tools Community Edition работает только на контекстах, полученных из DbContext.</span><span class="sxs-lookup"><span data-stu-id="a51a5-265">The Entity Framework Power Tools Community Edition work only on DbContext-derived contexts.</span></span>

#### <a name="232-how-to-use-pre-generated-views-with-a-model-created-by-edmgen"></a><span data-ttu-id="a51a5-266">2.3.2 Как использовать предгенерированные представления с моделью, созданной EDMGen</span><span class="sxs-lookup"><span data-stu-id="a51a5-266">2.3.2 How to use Pre-generated views with a model created by EDMGen</span></span>

<span data-ttu-id="a51a5-267">EDMGen — это утилита, которая поставляется с .NET и работает с Entity Framework 4 и 5, но не с Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="a51a5-267">EDMGen is a utility that ships with .NET and works with Entity Framework 4 and 5, but not with Entity Framework 6.</span></span> <span data-ttu-id="a51a5-268">EDMGen позволяет создавать файл модели, слой объекта и представления из командной строки.</span><span class="sxs-lookup"><span data-stu-id="a51a5-268">EDMGen allows you to generate a model file, the object layer and the views from the command line.</span></span> <span data-ttu-id="a51a5-269">Одним из выходов будет файл просмотров на вашем языке\#выбора, VB или C .</span><span class="sxs-lookup"><span data-stu-id="a51a5-269">One of the outputs will be a Views file in your language of choice, VB or C\#.</span></span> <span data-ttu-id="a51a5-270">Это кодовый файл, содержащий фрагменты entity S'L для каждого набора сущностей.</span><span class="sxs-lookup"><span data-stu-id="a51a5-270">This is a code file containing Entity SQL snippets for each entity set.</span></span> <span data-ttu-id="a51a5-271">Для включения предварительно созданных представлений вы просто включаете файл в проект.</span><span class="sxs-lookup"><span data-stu-id="a51a5-271">To enable pre-generated views, you simply include the file in your project.</span></span>

<span data-ttu-id="a51a5-272">Если вы вручную внесете теки в файлы схемы для модели, необходимо повторно создать файл представлений.</span><span class="sxs-lookup"><span data-stu-id="a51a5-272">If you manually make edits to the schema files for the model, you will need to re-generate the views file.</span></span> <span data-ttu-id="a51a5-273">Вы можете сделать это, запустив EDMGen с **флагом /mode:ViewGeneration.**</span><span class="sxs-lookup"><span data-stu-id="a51a5-273">You can do this by running EDMGen with the **/mode:ViewGeneration** flag.</span></span>

#### <a name="233-how-to-use-pre-generated-views-with-an-edmx-file"></a><span data-ttu-id="a51a5-274">2.3.3 Как использовать предгенерированные представления с файлом EDMX</span><span class="sxs-lookup"><span data-stu-id="a51a5-274">2.3.3 How to use Pre-Generated Views with an EDMX file</span></span>

<span data-ttu-id="a51a5-275">Вы также можете использовать EDMGen для создания представлений для файла EDMX - ранее ссылалась тема MSDN описывает, как добавить событие предварительной сборки, чтобы сделать это, - но это сложно, и Есть некоторые случаи, когда это невозможно.</span><span class="sxs-lookup"><span data-stu-id="a51a5-275">You can also use EDMGen to generate views for an EDMX file - the previously referenced MSDN topic describes how to add a pre-build event to do this - but this is complicated and there are some cases where it isn't possible.</span></span> <span data-ttu-id="a51a5-276">Как правило, проще использовать шаблон T4 для генерации представлений, когда модель находится в файле edmx.</span><span class="sxs-lookup"><span data-stu-id="a51a5-276">It's generally easier to use a T4 template to generate the views when your model is in an edmx file.</span></span>

<span data-ttu-id="a51a5-277">В блоге ADO.NET команды есть пост, который описывает, как \< https://docs.microsoft.com/archive/blogs/adonet/how-to-use-a-t4-template-for-view-generation>)использовать шаблон T4 для представления поколения ( .</span><span class="sxs-lookup"><span data-stu-id="a51a5-277">The ADO.NET team blog has a post that describes how to use a T4 template for view generation ( \<https://docs.microsoft.com/archive/blogs/adonet/how-to-use-a-t4-template-for-view-generation>).</span></span> <span data-ttu-id="a51a5-278">Эта публикация включает в себя шаблон, который можно загрузить и добавить в ваш проект.</span><span class="sxs-lookup"><span data-stu-id="a51a5-278">This post includes a template that can be downloaded and added to your project.</span></span> <span data-ttu-id="a51a5-279">Шаблон был написан для первой версии Системы сущности, поэтому они не гарантированно работают с последними версиями Рамочной системы сущности.</span><span class="sxs-lookup"><span data-stu-id="a51a5-279">The template was written for the first version of Entity Framework, so they aren’t guaranteed to work with the latest versions of Entity Framework.</span></span> <span data-ttu-id="a51a5-280">Тем не менее, вы можете скачать более современный набор шаблонов генерации представлений для Entity Framework 4 и 5 из галереи Visual Studio:</span><span class="sxs-lookup"><span data-stu-id="a51a5-280">However, you can download a more up-to-date set of view generation templates for Entity Framework 4 and 5from the Visual Studio Gallery:</span></span>

-   <span data-ttu-id="a51a5-281">VB.NET:\<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d></span><span class="sxs-lookup"><span data-stu-id="a51a5-281">VB.NET: \<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d></span></span>
-   <span data-ttu-id="a51a5-282">C\#:\<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d></span><span class="sxs-lookup"><span data-stu-id="a51a5-282">C\#: \<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d></span></span>

<span data-ttu-id="a51a5-283">Если вы используете Entity Framework 6, вы можете получить шаблоны поколения \< http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f>представления T4 из галереи Visual Studio Gallery в .</span><span class="sxs-lookup"><span data-stu-id="a51a5-283">If you’re using Entity Framework 6 you can get the view generation T4 templates from the Visual Studio Gallery at \<http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f>.</span></span>

### <a name="24-reducing-the-cost-of-view-generation"></a><span data-ttu-id="a51a5-284">2.4 Снижение стоимости генерации представлений</span><span class="sxs-lookup"><span data-stu-id="a51a5-284">2.4 Reducing the cost of view generation</span></span>

<span data-ttu-id="a51a5-285">Использование предварительно сгенерированных представлений перемещает стоимость генерации представления от загрузки модели (время выполнения) к времени проектирования.</span><span class="sxs-lookup"><span data-stu-id="a51a5-285">Using pre-generated views moves the cost of view generation from model loading (run time) to design time.</span></span> <span data-ttu-id="a51a5-286">Хотя это улучшает производительность запуска во время выполнения, вы все равно будете испытывать боль поколения представлений, пока вы развиваетесь.</span><span class="sxs-lookup"><span data-stu-id="a51a5-286">While this improves startup performance at runtime, you will still experience the pain of view generation while you are developing.</span></span> <span data-ttu-id="a51a5-287">Есть несколько дополнительных приемов, которые могут помочь снизить стоимость генерации представления, как во время компиляции, так и во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="a51a5-287">There are several additional tricks that can help reduce the cost of view generation, both at compile time and run time.</span></span>

#### <a name="241-using-foreign-key-associations-to-reduce-view-generation-cost"></a><span data-ttu-id="a51a5-288">2.4.1 Использование ассоциаций иностранных ключей для снижения стоимости генерации представления</span><span class="sxs-lookup"><span data-stu-id="a51a5-288">2.4.1 Using Foreign Key Associations to reduce view generation cost</span></span>

<span data-ttu-id="a51a5-289">Мы видели ряд случаев, когда переключение ассоциаций в модели с независимых ассоциаций на иностранные ключевые ассоциации резко улучшили время, проведенное в виде поколения.</span><span class="sxs-lookup"><span data-stu-id="a51a5-289">We have seen a number of cases where switching the associations in the model from Independent Associations to Foreign Key Associations dramatically improved the time spent in view generation.</span></span>

<span data-ttu-id="a51a5-290">Чтобы продемонстрировать это улучшение, мы создали две версии модели Navision с помощью EDMGen.</span><span class="sxs-lookup"><span data-stu-id="a51a5-290">To demonstrate this improvement, we generated two versions of the Navision model by using EDMGen.</span></span> <span data-ttu-id="a51a5-291">*Примечание: см. приложение C для описания модели Navision.*</span><span class="sxs-lookup"><span data-stu-id="a51a5-291">*Note: see appendix C for a description of the Navision model.*</span></span> <span data-ttu-id="a51a5-292">Модель Navision интересна для этого упражнения из-за его очень большого количества сущностей и отношений между ними.</span><span class="sxs-lookup"><span data-stu-id="a51a5-292">The Navision model is interesting for this exercise due to its very large amount of entities and relationships between them.</span></span>

<span data-ttu-id="a51a5-293">Одна версия этой очень большой модели была создана с иностранными ассоциациями ключей, а другая была создана с независимыми ассоциациями.</span><span class="sxs-lookup"><span data-stu-id="a51a5-293">One version of this very large model was generated with Foreign Keys Associations and the other was generated with Independent Associations.</span></span> <span data-ttu-id="a51a5-294">Затем мы приурочили, сколько времени потребовалось для создания представлений для каждой модели.</span><span class="sxs-lookup"><span data-stu-id="a51a5-294">We then timed how long it took to generate the views for each model.</span></span> <span data-ttu-id="a51a5-295">Для генерации представлений в тесте Entity Framework 5 Была использована метод GenerateViews() из класса EntityViewGenerator, в то время как тест Entity Framework 6 использовал метод GenerateViews() из класса StorageMappingItemCollection.</span><span class="sxs-lookup"><span data-stu-id="a51a5-295">Entity Framework 5 test used the GenerateViews() method from class EntityViewGenerator to generate the views, while the Entity Framework 6 test used the GenerateViews() method from class StorageMappingItemCollection.</span></span> <span data-ttu-id="a51a5-296">Это связано с реструктуризацией кода, которая произошла в кодовой базе Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="a51a5-296">This due to code restructuring that occurred in the Entity Framework 6 codebase.</span></span>

<span data-ttu-id="a51a5-297">Использование Entity Framework 5, генерация представления для модели с иностранными ключами заняла 65 минут в лабораторной машине.</span><span class="sxs-lookup"><span data-stu-id="a51a5-297">Using Entity Framework 5, view generation for the model with Foreign Keys took 65 minutes in a lab machine.</span></span> <span data-ttu-id="a51a5-298">Неизвестно, сколько времени потребовалось бы для создания представлений для модели, которая использовала независимые ассоциации.</span><span class="sxs-lookup"><span data-stu-id="a51a5-298">It's unknown how long it would have taken to generate the views for the model that used independent associations.</span></span> <span data-ttu-id="a51a5-299">Мы оставили тест работает в течение месяца, прежде чем машина была перезагружена в нашей лаборатории для установки ежемесячных обновлений.</span><span class="sxs-lookup"><span data-stu-id="a51a5-299">We left the test running for over a month before the machine was rebooted in our lab to install monthly updates.</span></span>

<span data-ttu-id="a51a5-300">Использование Entity Framework 6, генерация представления для модели с иностранными ключами заняла 28 секунд в той же лабораторной машине.</span><span class="sxs-lookup"><span data-stu-id="a51a5-300">Using Entity Framework 6, view generation for the model with Foreign Keys took 28 seconds in the same lab machine.</span></span> <span data-ttu-id="a51a5-301">Представление поколения для модели, используюейй независимые ассоциации, заняло 58 секунд.</span><span class="sxs-lookup"><span data-stu-id="a51a5-301">View generation for the model that uses Independent Associations took 58 seconds.</span></span> <span data-ttu-id="a51a5-302">Улучшения, внесенные в систему Entity Framework 6 в коде генерации представлений, означают, что многим проектам не потребуется предварительно созданных представлений для получения более быстрого времени запуска.</span><span class="sxs-lookup"><span data-stu-id="a51a5-302">The improvements done to Entity Framework 6 on its view generation code mean that many projects won’t need pre-generated views to obtain faster startup times.</span></span>

<span data-ttu-id="a51a5-303">Важно отметить, что предварительно генерирующие представления в рамках Entity Framework 4 и 5 могут быть выполнены с помощью EDMGen или Системных Power Tools Entity.</span><span class="sxs-lookup"><span data-stu-id="a51a5-303">It’s important to remark that pre-generating views in Entity Framework 4 and 5 can be done with EDMGen or the Entity Framework Power Tools.</span></span> <span data-ttu-id="a51a5-304">Для Entity Framework 6 представление поколения может быть сделано через Entity Framework Power Tools или программно, как описано в [предварительно созданных картографических представлений](~/ef6/fundamentals/performance/pre-generated-views.md).</span><span class="sxs-lookup"><span data-stu-id="a51a5-304">For Entity Framework 6 view generation can be done via the Entity Framework Power Tools or programmatically as described in [Pre-Generated Mapping Views](~/ef6/fundamentals/performance/pre-generated-views.md).</span></span>

##### <a name="2411-how-to-use-foreign-keys-instead-of-independent-associations"></a><span data-ttu-id="a51a5-305">2.4.1.1 Как использовать иностранные ключи вместо независимых ассоциаций</span><span class="sxs-lookup"><span data-stu-id="a51a5-305">2.4.1.1 How to use Foreign Keys instead of Independent Associations</span></span>

<span data-ttu-id="a51a5-306">При использовании EDMGen или Entity Designer в Visual Studio, вы получаете FKs по умолчанию, и это займет всего один флажок или флаг командной строки для переключения между FKs и IAs.</span><span class="sxs-lookup"><span data-stu-id="a51a5-306">When using EDMGen or the Entity Designer in Visual Studio, you get FKs by default, and it only takes a single checkbox or command line flag to switch between FKs and IAs.</span></span>

<span data-ttu-id="a51a5-307">Если у вас есть большая модель Code First, использование независимых ассоциаций будет иметь такое же влияние на генерацию представления.</span><span class="sxs-lookup"><span data-stu-id="a51a5-307">If you have a large Code First model, using Independent Associations will have the same effect on view generation.</span></span> <span data-ttu-id="a51a5-308">Это влияние можно избежать, включив свойства Foreign Key в классы зависимых объектов, хотя некоторые разработчики будут считать, что это загрязняет модель их объектов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-308">You can avoid this impact by including Foreign Key properties on the classes for your dependent objects, though some developers will consider this to be polluting their object model.</span></span> <span data-ttu-id="a51a5-309">Вы можете найти более подробную информацию по этому вопросу в \< http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/>.</span><span class="sxs-lookup"><span data-stu-id="a51a5-309">You can find more information on this subject in \<http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/>.</span></span>

| <span data-ttu-id="a51a5-310">В языке</span><span class="sxs-lookup"><span data-stu-id="a51a5-310">When using</span></span>      | <span data-ttu-id="a51a5-311">выполните следующее:</span><span class="sxs-lookup"><span data-stu-id="a51a5-311">Do this</span></span>                                                                                                                                                                                                                                                                                                                              |
|:----------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="a51a5-312">Entity Designer</span><span class="sxs-lookup"><span data-stu-id="a51a5-312">Entity Designer</span></span> | <span data-ttu-id="a51a5-313">После добавления связи между двумя сущностями убедитесь, что у вас есть референциальные ограничения.</span><span class="sxs-lookup"><span data-stu-id="a51a5-313">After adding an association between two entities, make sure you have a referential constraint.</span></span> <span data-ttu-id="a51a5-314">Референтные ограничения говорят об использовании Иностранных ключей вместо независимых ассоциаций.</span><span class="sxs-lookup"><span data-stu-id="a51a5-314">Referential constraints tell Entity Framework to use Foreign Keys instead of Independent Associations.</span></span> <span data-ttu-id="a51a5-315">Для получения дополнительной \< https://docs.microsoft.com/archive/blogs/efdesign/foreign-keys-in-the-entity-framework>информации посетите .</span><span class="sxs-lookup"><span data-stu-id="a51a5-315">For additional details visit \<https://docs.microsoft.com/archive/blogs/efdesign/foreign-keys-in-the-entity-framework>.</span></span> |
| <span data-ttu-id="a51a5-316">EDMGen</span><span class="sxs-lookup"><span data-stu-id="a51a5-316">EDMGen</span></span>          | <span data-ttu-id="a51a5-317">При использовании EDMGen для генерации файлов из базы данных ваши иностранные ключи будут соблюдаться и добавлены в модель как таковую.</span><span class="sxs-lookup"><span data-stu-id="a51a5-317">When using EDMGen to generate your files from the database, your Foreign Keys will be respected and added to the model as such.</span></span> <span data-ttu-id="a51a5-318">Для получения дополнительной информации о различных [http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx)вариантах, выставленных EDMGen визита .</span><span class="sxs-lookup"><span data-stu-id="a51a5-318">For more information on the different options exposed by EDMGen visit [http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx).</span></span>                           |
| <span data-ttu-id="a51a5-319">Code First</span><span class="sxs-lookup"><span data-stu-id="a51a5-319">Code First</span></span>      | <span data-ttu-id="a51a5-320">Подробнее о том, как включать иностранные ключевые свойства в зависимые объекты при использовании Code First, читайте в разделе "Конвенция о [взаимоотношениях"](~/ef6/modeling/code-first/conventions/built-in.md) В Первом кодексе.</span><span class="sxs-lookup"><span data-stu-id="a51a5-320">See the "Relationship Convention" section of the [Code First Conventions](~/ef6/modeling/code-first/conventions/built-in.md) topic for information on how to include foreign key properties on dependent objects when using Code First.</span></span>                                                                                              |

#### <a name="242-moving-your-model-to-a-separate-assembly"></a><span data-ttu-id="a51a5-321">2.4.2 Перемещение модели в отдельную сборку</span><span class="sxs-lookup"><span data-stu-id="a51a5-321">2.4.2 Moving your model to a separate assembly</span></span>

<span data-ttu-id="a51a5-322">Когда модель включена непосредственно в проект приложения и вы генерируете представления через событие предварительной сборки или шаблон T4, генерация представления и проверка будут происходить всякий раз, когда проект перестроен, даже если модель не была изменена.</span><span class="sxs-lookup"><span data-stu-id="a51a5-322">When your model is included directly in your application's project and you generate views through a pre-build event or a T4 template, view generation and validation will take place whenever the project is rebuilt, even if the model wasn't changed.</span></span> <span data-ttu-id="a51a5-323">Если вы переместите модель в отдельную сборку и ссылаетесь на нее из проекта приложения, можно внести другие изменения в приложение без необходимости восстановления проекта, содержащего модель.</span><span class="sxs-lookup"><span data-stu-id="a51a5-323">If you move the model to a separate assembly and reference it from your application's project, you can make other changes to your application without needing to rebuild the project containing the model.</span></span>

<span data-ttu-id="a51a5-324">*Примечание:*  при перемещении модели в отдельные сборки не забудьте скопировать строки соединения для модели в файл конфигурации приложения проекта клиента.</span><span class="sxs-lookup"><span data-stu-id="a51a5-324">*Note:*  when moving your model to separate assemblies remember to copy the connection strings for the model into the application configuration file of the client project.</span></span>

#### <a name="243-disable-validation-of-an-edmx-based-model"></a><span data-ttu-id="a51a5-325">2.4.3 Отключить проверку модели на основе edmx</span><span class="sxs-lookup"><span data-stu-id="a51a5-325">2.4.3 Disable validation of an edmx-based model</span></span>

<span data-ttu-id="a51a5-326">Модели EDMX проверяются во время компиляции, даже если модель не изменина.</span><span class="sxs-lookup"><span data-stu-id="a51a5-326">EDMX models are validated at compile time, even if the model is unchanged.</span></span> <span data-ttu-id="a51a5-327">Если модель уже была проверена, можно пресечь проверку во время компиляции, установив свойство "Validate on Build" на ложное в окне свойств.</span><span class="sxs-lookup"><span data-stu-id="a51a5-327">If your model has already been validated, you can suppress validation at compile time by setting the "Validate on Build" property to false in the properties window.</span></span> <span data-ttu-id="a51a5-328">При изменении отображения или модели можно временно повторно включить проверку для проверки изменений.</span><span class="sxs-lookup"><span data-stu-id="a51a5-328">When you change your mapping or model, you can temporarily re-enable validation to verify your changes.</span></span>

<span data-ttu-id="a51a5-329">Обратите внимание, что в рамках entity Framework Designer для Entity Framework 6 были улучшены, а стоимость "Validate on Build" значительно ниже, чем в предыдущих версиях конструктора.</span><span class="sxs-lookup"><span data-stu-id="a51a5-329">Note that performance improvements were made to the Entity Framework Designer for Entity Framework 6, and the cost of the “Validate on Build” is much lower than in previous versions of the designer.</span></span>

## <a name="3-caching-in-the-entity-framework"></a><span data-ttu-id="a51a5-330">3 Кэширование в рамочной системе entity</span><span class="sxs-lookup"><span data-stu-id="a51a5-330">3 Caching in the Entity Framework</span></span>

<span data-ttu-id="a51a5-331">Система entity имеет следующие формы встроенного кэширования:</span><span class="sxs-lookup"><span data-stu-id="a51a5-331">Entity Framework has the following forms of caching built-in:</span></span>

1.  <span data-ttu-id="a51a5-332">Кэширование объектов — objectStateManager, встроенный в экземпляр ObjectContext, отслеживает память объектов, извлеченных с помощью этого экземпляра.</span><span class="sxs-lookup"><span data-stu-id="a51a5-332">Object caching – the ObjectStateManager built into an ObjectContext instance keeps track in memory of the objects that have been retrieved using that instance.</span></span> <span data-ttu-id="a51a5-333">Это также известно как кэш первого уровня.</span><span class="sxs-lookup"><span data-stu-id="a51a5-333">This is also known as first-level cache.</span></span>
2.  <span data-ttu-id="a51a5-334">Кэширование плана запроса - повторное использование генерируемой команды хранилища при выполнении запроса более одного раза.</span><span class="sxs-lookup"><span data-stu-id="a51a5-334">Query Plan Caching - reusing the generated store command when a query is executed more than once.</span></span>
3.  <span data-ttu-id="a51a5-335">Кэширование метаданных - совместное использование метаданных для модели по разным соединениям с одной и той же моделью.</span><span class="sxs-lookup"><span data-stu-id="a51a5-335">Metadata caching - sharing the metadata for a model across different connections to the same model.</span></span>

<span data-ttu-id="a51a5-336">Помимо кэшов, которые EF предоставляет из коробки, специальный вид поставщика ADO.NET данных, известный как поставщик упаковки, также может быть использован для расширения рамок Entity с помощью кэша для результатов, извлеченных из базы данных, также известного как кэширование второго уровня.</span><span class="sxs-lookup"><span data-stu-id="a51a5-336">Besides the caches that EF provides out of the box, a special kind of ADO.NET data provider known as a wrapping provider can also be used to extend Entity Framework with a cache for the results retrieved from the database, also known as second-level caching.</span></span>

### <a name="31-object-caching"></a><span data-ttu-id="a51a5-337">3.1 Кэшинг объекта</span><span class="sxs-lookup"><span data-stu-id="a51a5-337">3.1 Object Caching</span></span>

<span data-ttu-id="a51a5-338">По умолчанию, когда объект возвращается в результатах запроса, непосредственно перед его материализуемым EF, ObjectContext проверяет, была ли объект с тем же ключом уже загружен в свой ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="a51a5-338">By default when an entity is returned in the results of a query, just before EF materializes it, the ObjectContext will check if an entity with the same key has already been loaded into its ObjectStateManager.</span></span> <span data-ttu-id="a51a5-339">Если организация с теми же ключами уже присутствует, EF будет включать его в результаты запроса.</span><span class="sxs-lookup"><span data-stu-id="a51a5-339">If an entity with the same keys is already present EF will include it in the results of the query.</span></span> <span data-ttu-id="a51a5-340">Хотя EF по-прежнему будет выдавать запрос против базы данных, такое поведение может обойти большую часть затрат на материализацию сущности несколько раз.</span><span class="sxs-lookup"><span data-stu-id="a51a5-340">Although EF will still issue the query against the database, this behavior can bypass much of the cost of materializing the entity multiple times.</span></span>

#### <a name="311-getting-entities-from-the-object-cache-using-dbcontext-find"></a><span data-ttu-id="a51a5-341">3.1.1 Получение сущностей из кэша объектов с помощью DbContext Find</span><span class="sxs-lookup"><span data-stu-id="a51a5-341">3.1.1 Getting entities from the object cache using DbContext Find</span></span>

<span data-ttu-id="a51a5-342">В отличие от обычного запроса, метод Поиска в DbSet (AIS, включенный в первые разы в EF 4.1) будет выполнять поиск в памяти еще до выдачи запроса против базы данных.</span><span class="sxs-lookup"><span data-stu-id="a51a5-342">Unlike a regular query, the Find method in DbSet (APIs included for the first time in EF 4.1) will perform a search in memory before even issuing the query against the database.</span></span> <span data-ttu-id="a51a5-343">Важно отметить, что два разных экземпляра ObjectContext будут иметь два разных экземпляра ObjectStateManager, что означает, что они имеют отдельные кэши объектов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-343">It’s important to note that two different ObjectContext instances will have two different ObjectStateManager instances, meaning that they have separate object caches.</span></span>

<span data-ttu-id="a51a5-344">Find использует основное значение ключа, чтобы попытаться найти сущность, отслеживаемую контекстом.</span><span class="sxs-lookup"><span data-stu-id="a51a5-344">Find uses the primary key value to attempt to find an entity tracked by the context.</span></span> <span data-ttu-id="a51a5-345">Если сущность не находится в контексте, то запрос будет выполнен и оценен в базе данных, и нулевые возвращается, если объект не найден в контексте или в базе данных.</span><span class="sxs-lookup"><span data-stu-id="a51a5-345">If the entity is not in the context then a query will be executed and evaluated against the database, and null is returned if the entity is not found in the context or in the database.</span></span> <span data-ttu-id="a51a5-346">Обратите внимание, что Find также возвращает объекты, которые были добавлены в контекст, но еще не сохранены в базе данных.</span><span class="sxs-lookup"><span data-stu-id="a51a5-346">Note that Find also returns entities that have been added to the context but have not yet been saved to the database.</span></span>

<span data-ttu-id="a51a5-347">При использовании Find необходимо учитывать производительность.</span><span class="sxs-lookup"><span data-stu-id="a51a5-347">There is a performance consideration to be taken when using Find.</span></span> <span data-ttu-id="a51a5-348">Вызовы к этому методу по умолчанию вызовут проверку кэша объекта для обнаружения изменений, которые еще не завершены в базе данных.</span><span class="sxs-lookup"><span data-stu-id="a51a5-348">Invocations to this method by default will trigger a validation of the object cache in order to detect changes that are still pending commit to the database.</span></span> <span data-ttu-id="a51a5-349">Этот процесс может быть очень дорогим, если в кэше объекта есть очень большое количество объектов или в большой график объекта, добавляемый в кэш объекта, но он также может быть отключен.</span><span class="sxs-lookup"><span data-stu-id="a51a5-349">This process can be very expensive if there are a very large number of objects in the object cache or in a large object graph being added to the object cache, but it can also be disabled.</span></span> <span data-ttu-id="a51a5-350">В некоторых случаях вы можете воспринимать на порядок величину разницы в вызове метода Поиска, когда вы откажете сьюет изменения автоматического обнаружения.</span><span class="sxs-lookup"><span data-stu-id="a51a5-350">In certain cases, you may perceive over an order of magnitude of difference in calling the Find method when you disable auto detect changes.</span></span> <span data-ttu-id="a51a5-351">Однако второй порядок величины воспринимается, когда объект фактически находится в кэше по сравнению с тем, когда объект должен быть извлечен из базы данных.</span><span class="sxs-lookup"><span data-stu-id="a51a5-351">Yet a second order of magnitude is perceived when the object actually is in the cache versus when the object has to be retrieved from the database.</span></span> <span data-ttu-id="a51a5-352">Вот пример графика с измерениями, сделанными с использованием некоторых из наших микробенчмарков, выраженных в миллисекундах, с нагрузкой 5000 сущностей:</span><span class="sxs-lookup"><span data-stu-id="a51a5-352">Here is an example graph with measurements taken using some of our microbenchmarks, expressed in milliseconds, with a load of 5000 entities:</span></span>

<span data-ttu-id="a51a5-353">![.NET 4.5 логарифмическая шкала](~/ef6/media/net45logscale.png ".NET 4.5 - логарифмическая шкала")</span><span class="sxs-lookup"><span data-stu-id="a51a5-353">![.NET 4.5 logarithmic scale](~/ef6/media/net45logscale.png ".NET 4.5 - logarithmic scale")</span></span>

<span data-ttu-id="a51a5-354">Пример поиска с автоматическим обнаружением изменений отключен:</span><span class="sxs-lookup"><span data-stu-id="a51a5-354">Example of Find with auto-detect changes disabled:</span></span>

``` csharp
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    context.Configuration.AutoDetectChangesEnabled = true;
    ...
```

<span data-ttu-id="a51a5-355">При использовании метода «Найти» необходимо учитывать:</span><span class="sxs-lookup"><span data-stu-id="a51a5-355">What you have to consider when using the Find method is:</span></span>

1.  <span data-ttu-id="a51a5-356">Если объект не находится в кэше, преимущества Поиска сведены на нет, но синтаксис все еще проще, чем запрос ключа.</span><span class="sxs-lookup"><span data-stu-id="a51a5-356">If the object is not in the cache the benefits of Find are negated, but the syntax is still simpler than a query by key.</span></span>
2.  <span data-ttu-id="a51a5-357">Если автоматические изменения обнаруживаются, стоимость метода Поиска может увеличиться на один порядок величины или даже больше в зависимости от сложности модели и количества сущностей в кэше объектов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-357">If auto detect changes is enabled the cost of the Find method may increase by one order of magnitude, or even more depending on the complexity of your model and the amount of entities in your object cache.</span></span>

<span data-ttu-id="a51a5-358">Кроме того, имейте в виду, что Find возвращает только объект, который вы ищете, и он не загружает автоматически связанные сущности, если они еще не находятся в кэше объекта.</span><span class="sxs-lookup"><span data-stu-id="a51a5-358">Also, keep in mind that Find only returns the entity you are looking for and it does not automatically loads its associated entities if they are not already in the object cache.</span></span> <span data-ttu-id="a51a5-359">Если вам нужно получить связанные сущности, можно использовать запрос по ключу с нетерпеливой загрузкой.</span><span class="sxs-lookup"><span data-stu-id="a51a5-359">If you need to retrieve associated entities, you can use a query by key with eager loading.</span></span> <span data-ttu-id="a51a5-360">Для получения дополнительной **информации см. 8.1 Ленивая загрузка против стремятся загрузки**.</span><span class="sxs-lookup"><span data-stu-id="a51a5-360">For more information see **8.1 Lazy Loading vs. Eager Loading**.</span></span>

#### <a name="312-performance-issues-when-the-object-cache-has-many-entities"></a><span data-ttu-id="a51a5-361">3.1.2 Проблемы производительности при кэше объекта имеет много сущностей</span><span class="sxs-lookup"><span data-stu-id="a51a5-361">3.1.2 Performance issues when the object cache has many entities</span></span>

<span data-ttu-id="a51a5-362">Кэш объектов помогает повысить общую реакцию системы Entity.</span><span class="sxs-lookup"><span data-stu-id="a51a5-362">The object cache helps to increase the overall responsiveness of Entity Framework.</span></span> <span data-ttu-id="a51a5-363">Однако, когда кэш объекта имеет очень большое количество объектов загружены это может повлиять на определенные операции, такие как добавить, удалить, найти, запись, СохранитьИзменения и многое другое.</span><span class="sxs-lookup"><span data-stu-id="a51a5-363">However, when the object cache has a very large amount of entities loaded it may affect certain operations such as Add, Remove, Find, Entry, SaveChanges and more.</span></span> <span data-ttu-id="a51a5-364">В частности, операции, вызывающие вызов detectChanges, будут негативно затронуты очень большими кэшами объектов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-364">In particular, operations that trigger a call to DetectChanges will be negatively affected by very large object caches.</span></span> <span data-ttu-id="a51a5-365">DetectChanges синхронизирует график объекта с диспетчером состояния объекта, и его производительность будет определяться непосредственно размером графика объекта.</span><span class="sxs-lookup"><span data-stu-id="a51a5-365">DetectChanges synchronizes the object graph with the object state manager and its performance will determined directly by the size of the object graph.</span></span> <span data-ttu-id="a51a5-366">Для получения дополнительной информации [Tracking Changes in POCO Entities](https://msdn.microsoft.com/library/dd456848.aspx)о DetectChanges см.</span><span class="sxs-lookup"><span data-stu-id="a51a5-366">For more information about DetectChanges, see [Tracking Changes in POCO Entities](https://msdn.microsoft.com/library/dd456848.aspx).</span></span>

<span data-ttu-id="a51a5-367">При использовании Entity Framework 6 разработчики могут вызывать AddRange и RemoveRange непосредственно на DbSet, вместо того, чтобы итерировать коллекцию и вызывать Add один раз в экземпляр.</span><span class="sxs-lookup"><span data-stu-id="a51a5-367">When using Entity Framework 6, developers are able to call AddRange and RemoveRange directly on a DbSet, instead of iterating on a collection and calling Add once per instance.</span></span> <span data-ttu-id="a51a5-368">Преимущество использования методов диапазона заключается в том, что стоимость DetectChanges оплачивается только один раз за весь набор сущностей, а не один раз на каждую добавленную сущность.</span><span class="sxs-lookup"><span data-stu-id="a51a5-368">The advantage of using the range methods is that the cost of DetectChanges is only paid once for the entire set of entities as opposed to once per each added entity.</span></span>

### <a name="32-query-plan-caching"></a><span data-ttu-id="a51a5-369">3.2 Кэшинг плана запроса</span><span class="sxs-lookup"><span data-stu-id="a51a5-369">3.2 Query Plan Caching</span></span>

<span data-ttu-id="a51a5-370">При первом выполнении запроса он проходит через внутренний компилятор плана для перевода концептуального запроса в команду хранилища (например, T-S'L, который выполняется при запуске на против сервера S'L).</span><span class="sxs-lookup"><span data-stu-id="a51a5-370">The first time a query is executed, it goes through the internal plan compiler to translate the conceptual query into the store command (for example, the T-SQL which is executed when run against SQL Server).</span></span><span data-ttu-id="a51a5-371">Если кэширование плана запроса включено, следующий момент выполнения запроса команда хранилища будет извлечена непосредственно из кэша плана запроса для выполнения, минуя компилятор плана.</span><span class="sxs-lookup"><span data-stu-id="a51a5-371">  If query plan caching is enabled, the next time the query is executed the store command is retrieved directly from the query plan cache for execution, bypassing the plan compiler.</span></span>

<span data-ttu-id="a51a5-372">Кэш плана запросов используется в экземплярах ObjectContext в том же AppDomain.</span><span class="sxs-lookup"><span data-stu-id="a51a5-372">The query plan cache is shared across ObjectContext instances within the same AppDomain.</span></span> <span data-ttu-id="a51a5-373">Вам не нужно держаться за экземпляр ObjectContext, чтобы воспользоваться кэшированием плана запроса.</span><span class="sxs-lookup"><span data-stu-id="a51a5-373">You don't need to hold onto an ObjectContext instance to benefit from query plan caching.</span></span>

#### <a name="321-some-notes-about-query-plan-caching"></a><span data-ttu-id="a51a5-374">3.2.1 Некоторые заметки о кэшинге плана запросов</span><span class="sxs-lookup"><span data-stu-id="a51a5-374">3.2.1 Some notes about Query Plan Caching</span></span>

-   <span data-ttu-id="a51a5-375">Кэш плана запросов используется для всех типов запросов: Entity S'L, LIN- для организаций и объектов компилированного квиера.</span><span class="sxs-lookup"><span data-stu-id="a51a5-375">The query plan cache is shared for all query types: Entity SQL, LINQ to Entities, and CompiledQuery objects.</span></span>
-   <span data-ttu-id="a51a5-376">По умолчанию кэширование плана запросов включено для запросов Entity S'L, независимо от того, выполняется ли это через EntityCommand или через Object's..</span><span class="sxs-lookup"><span data-stu-id="a51a5-376">By default, query plan caching is enabled for Entity SQL queries, whether executed through an EntityCommand or through an ObjectQuery.</span></span> <span data-ttu-id="a51a5-377">Кроме того, по умолчанию для запросов линз для сущностей в рамках сущностей на .NET 4.5 и в рамках сущности 6</span><span class="sxs-lookup"><span data-stu-id="a51a5-377">It is also enabled by default for LINQ to Entities queries in Entity Framework on .NET 4.5, and in Entity Framework 6</span></span>
    -   <span data-ttu-id="a51a5-378">Кэширование плана запроса может быть отключено, установив свойство EnablePlanCaching (на EntityCommand или Object'ery) на ложное.</span><span class="sxs-lookup"><span data-stu-id="a51a5-378">Query plan caching can be disabled by setting the EnablePlanCaching property (on EntityCommand or ObjectQuery) to false.</span></span> <span data-ttu-id="a51a5-379">Пример:</span><span class="sxs-lookup"><span data-stu-id="a51a5-379">For example:</span></span>
``` csharp
                    var query = from customer in context.Customer
                                where customer.CustomerId == id
                                select new
                                {
                                    customer.CustomerId,
                                    customer.Name
                                };
                    ObjectQuery oQuery = query as ObjectQuery;
                    oQuery.EnablePlanCaching = false;
```
-   <span data-ttu-id="a51a5-380">Для параметризированных запросов изменение значения параметра по-прежнему будет попадание в кэшированный запрос.</span><span class="sxs-lookup"><span data-stu-id="a51a5-380">For parameterized queries, changing the parameter's value will still hit the cached query.</span></span> <span data-ttu-id="a51a5-381">Но изменение граней параметра (например, размер, точность или масштаб) ударит по другой записи в кэше.</span><span class="sxs-lookup"><span data-stu-id="a51a5-381">But changing a parameter's facets (for example, size, precision, or scale) will hit a different entry in the cache.</span></span>
-   <span data-ttu-id="a51a5-382">При использовании entity S'L строка запроса является частью ключа.</span><span class="sxs-lookup"><span data-stu-id="a51a5-382">When using Entity SQL, the query string is part of the key.</span></span> <span data-ttu-id="a51a5-383">Изменение запроса вообще приведет к различным записям кэша, даже если запросы функционально эквивалентны.</span><span class="sxs-lookup"><span data-stu-id="a51a5-383">Changing the query at all will result in different cache entries, even if the queries are functionally equivalent.</span></span> <span data-ttu-id="a51a5-384">Это включает в себя изменения в корпусе или белом пространстве.</span><span class="sxs-lookup"><span data-stu-id="a51a5-384">This includes changes to casing or whitespace.</span></span>
-   <span data-ttu-id="a51a5-385">При использовании LIN'а запрос обрабатывается для создания части ключа.</span><span class="sxs-lookup"><span data-stu-id="a51a5-385">When using LINQ, the query is processed to generate a part of the key.</span></span> <span data-ttu-id="a51a5-386">Таким образом, изменение выражения LIN'а создаст другой ключ.</span><span class="sxs-lookup"><span data-stu-id="a51a5-386">Changing the LINQ expression will therefore generate a different key.</span></span>
-   <span data-ttu-id="a51a5-387">Могут применяться и другие технические ограничения; для получения более подробной информации см.</span><span class="sxs-lookup"><span data-stu-id="a51a5-387">Other technical limitations may apply; see Autocompiled Queries for more details.</span></span>

#### <a name="322-cache-eviction-algorithm"></a><span data-ttu-id="a51a5-388">3.2.2 Алгоритм выселения кэша</span><span class="sxs-lookup"><span data-stu-id="a51a5-388">3.2.2      Cache eviction algorithm</span></span>

<span data-ttu-id="a51a5-389">Понимание того, как работает внутренний алгоритм, поможет вам выяснить, когда включить или отключить кэширование плана запроса.</span><span class="sxs-lookup"><span data-stu-id="a51a5-389">Understanding how the internal algorithm works will help you figure out when to enable or disable query plan caching.</span></span> <span data-ttu-id="a51a5-390">Алгоритм очистки заключается в следующем:</span><span class="sxs-lookup"><span data-stu-id="a51a5-390">The cleanup algorithm is as follows:</span></span>

1.  <span data-ttu-id="a51a5-391">Как только кэш содержит определенное количество записей (800), мы запускаем таймер, который периодически (раз в минуту) подметает кэш.</span><span class="sxs-lookup"><span data-stu-id="a51a5-391">Once the cache contains a set number of entries (800), we start a timer that periodically (once-per-minute) sweeps the cache.</span></span>
2.  <span data-ttu-id="a51a5-392">Во время зачисток кэша записи удаляются из кэша на основе LFRU (наименее часто используемые в последнее время).</span><span class="sxs-lookup"><span data-stu-id="a51a5-392">During cache sweeps, entries are removed from the cache on a LFRU (Least frequently – recently used) basis.</span></span> <span data-ttu-id="a51a5-393">Этот алгоритм учитывает как количество хитов, так и возраст при принятии решения о том, какие записи выбрасываются.</span><span class="sxs-lookup"><span data-stu-id="a51a5-393">This algorithm takes both hit count and age into account when deciding which entries are ejected.</span></span>
3.  <span data-ttu-id="a51a5-394">В конце каждого развертки кэша кэш снова содержит 800 записей.</span><span class="sxs-lookup"><span data-stu-id="a51a5-394">At the end of each cache sweep, the cache again contains 800 entries.</span></span>

<span data-ttu-id="a51a5-395">Все записи кэша обрабатываются одинаково при определении того, какие записи выселить.</span><span class="sxs-lookup"><span data-stu-id="a51a5-395">All cache entries are treated equally when determining which entries to evict.</span></span> <span data-ttu-id="a51a5-396">Это означает, что команда хранилища для компилированного кверкери имеет те же шансы на выселение, что и команда хранилища для запроса Entity S'L.</span><span class="sxs-lookup"><span data-stu-id="a51a5-396">This means the store command for a CompiledQuery has the same chance of eviction as the store command for an Entity SQL query.</span></span>

<span data-ttu-id="a51a5-397">Обратите внимание, что таймер выселения кэша выснется, когда в кэше находится 800 сущностей, но кэш заметен только через 60 секунд после запуска этого таймера.</span><span class="sxs-lookup"><span data-stu-id="a51a5-397">Note that the cache eviction timer is kicked in when there are 800 entities in the cache, but the cache is only swept 60 seconds after this timer is started.</span></span> <span data-ttu-id="a51a5-398">Это означает, что в течение 60 секунд ваш кэш может вырасти до довольно большого.</span><span class="sxs-lookup"><span data-stu-id="a51a5-398">That means that for up to 60 seconds your cache may grow to be quite large.</span></span>

#### <a name="323-test-metrics-demonstrating-query-plan-caching-performance"></a><span data-ttu-id="a51a5-399">3.2.3 Метрики тестирования, демонстрирующие производительность кэширования плана запросов</span><span class="sxs-lookup"><span data-stu-id="a51a5-399">3.2.3       Test Metrics demonstrating query plan caching performance</span></span>

<span data-ttu-id="a51a5-400">Чтобы продемонстрировать влияние кэширования запроса на производительность приложения, мы выполнили тест, в ходе которого выполнили ряд запросов Entity S'L против модели Navision.</span><span class="sxs-lookup"><span data-stu-id="a51a5-400">To demonstrate the effect of query plan caching on your application's performance, we performed a test where we executed a number of Entity SQL queries against the Navision model.</span></span> <span data-ttu-id="a51a5-401">Ознакомьтесь с приложением для описания модели Navision и типов запросов, которые были выполнены.</span><span class="sxs-lookup"><span data-stu-id="a51a5-401">See the appendix for a description of the Navision model and the types of queries which were executed.</span></span> <span data-ttu-id="a51a5-402">В этом тесте мы сначала итерируем список запросов и выполняем каждый раз, чтобы добавить их в кэш (если кэширование включено).</span><span class="sxs-lookup"><span data-stu-id="a51a5-402">In this test, we first iterate through the list of queries and execute each one once to add them to the cache (if caching is enabled).</span></span> <span data-ttu-id="a51a5-403">Этот шаг не имеет времени.</span><span class="sxs-lookup"><span data-stu-id="a51a5-403">This step is untimed.</span></span> <span data-ttu-id="a51a5-404">Далее, мы спим основной поток в течение более 60 секунд, чтобы кэш радикальных состоится; наконец, мы итерировать через список второй раз для выполнения кэшированных запросов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-404">Next, we sleep the main thread for over 60 seconds to allow cache sweeping to take place; finally, we iterate through the list a 2nd time to execute the cached queries.</span></span> <span data-ttu-id="a51a5-405">Кроме того, кэш плана плана S'L Server смывается перед выполнением каждого набора запросов, чтобы время, которое мы получаем, точно отражало выгоду, полученную кэшем плана запросов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-405">Additionally, the SQL Server plan cache is flushed before each set of queries is executed so that the times we obtain accurately reflect the benefit given by the query plan cache.</span></span>

##### <a name="3231-test-results"></a><span data-ttu-id="a51a5-406">3.2.3.1 Результаты испытаний</span><span class="sxs-lookup"><span data-stu-id="a51a5-406">3.2.3.1       Test Results</span></span>

| <span data-ttu-id="a51a5-407">Тест</span><span class="sxs-lookup"><span data-stu-id="a51a5-407">Test</span></span>                                                                   | <span data-ttu-id="a51a5-408">EF5 нет кэша</span><span class="sxs-lookup"><span data-stu-id="a51a5-408">EF5 no cache</span></span> | <span data-ttu-id="a51a5-409">Кэшированный EF5</span><span class="sxs-lookup"><span data-stu-id="a51a5-409">EF5 cached</span></span> | <span data-ttu-id="a51a5-410">EF6 нет кэша</span><span class="sxs-lookup"><span data-stu-id="a51a5-410">EF6 no cache</span></span> | <span data-ttu-id="a51a5-411">Кэшированный EF6</span><span class="sxs-lookup"><span data-stu-id="a51a5-411">EF6 cached</span></span> |
|:-----------------------------------------------------------------------|:-------------|:-----------|:-------------|:-----------|
| <span data-ttu-id="a51a5-412">Перечисление всех запросов 18723</span><span class="sxs-lookup"><span data-stu-id="a51a5-412">Enumerating all 18723 queries</span></span>                                          | <span data-ttu-id="a51a5-413">124</span><span class="sxs-lookup"><span data-stu-id="a51a5-413">124</span></span>          | <span data-ttu-id="a51a5-414">125.4</span><span class="sxs-lookup"><span data-stu-id="a51a5-414">125.4</span></span>      | <span data-ttu-id="a51a5-415">124.3</span><span class="sxs-lookup"><span data-stu-id="a51a5-415">124.3</span></span>        | <span data-ttu-id="a51a5-416">125.3</span><span class="sxs-lookup"><span data-stu-id="a51a5-416">125.3</span></span>      |
| <span data-ttu-id="a51a5-417">Как избежать развертки (только первые 800 запросов, независимо от сложности)</span><span class="sxs-lookup"><span data-stu-id="a51a5-417">Avoiding sweep (just the first 800 queries, regardless of complexity)</span></span>  | <span data-ttu-id="a51a5-418">41.7</span><span class="sxs-lookup"><span data-stu-id="a51a5-418">41.7</span></span>         | <span data-ttu-id="a51a5-419">5.5</span><span class="sxs-lookup"><span data-stu-id="a51a5-419">5.5</span></span>        | <span data-ttu-id="a51a5-420">40,5</span><span class="sxs-lookup"><span data-stu-id="a51a5-420">40.5</span></span>         | <span data-ttu-id="a51a5-421">5.4</span><span class="sxs-lookup"><span data-stu-id="a51a5-421">5.4</span></span>        |
| <span data-ttu-id="a51a5-422">Просто aggregatingSubtotals запросы (178 всего - что позволяет избежать развертки)</span><span class="sxs-lookup"><span data-stu-id="a51a5-422">Just the AggregatingSubtotals queries (178 total - which avoids sweep)</span></span> | <span data-ttu-id="a51a5-423">39.5</span><span class="sxs-lookup"><span data-stu-id="a51a5-423">39.5</span></span>         | <span data-ttu-id="a51a5-424">4.5.</span><span class="sxs-lookup"><span data-stu-id="a51a5-424">4.5</span></span>        | <span data-ttu-id="a51a5-425">38.1</span><span class="sxs-lookup"><span data-stu-id="a51a5-425">38.1</span></span>         | <span data-ttu-id="a51a5-426">4.6</span><span class="sxs-lookup"><span data-stu-id="a51a5-426">4.6</span></span>        |

<span data-ttu-id="a51a5-427">*Все время в секундах.*</span><span class="sxs-lookup"><span data-stu-id="a51a5-427">*All times in seconds.*</span></span>

<span data-ttu-id="a51a5-428">Мораль - при выполнения большого количества различных запросов (например, динамически созданных запросов), кэширование не помогает, и в результате промывка кэша может держать запросы, которые выиграют больше всего от кэширования плана от фактического его использования.</span><span class="sxs-lookup"><span data-stu-id="a51a5-428">Moral - when executing lots of distinct queries (for example,  dynamically created queries), caching doesn't help and the resulting flushing of the cache can keep the queries that would benefit the most from plan caching from actually using it.</span></span>

<span data-ttu-id="a51a5-429">Запросы AggregatingSubtotals являются наиболее сложными из запросов, с которых мы тестировали.</span><span class="sxs-lookup"><span data-stu-id="a51a5-429">The AggregatingSubtotals queries are the most complex of the queries we tested with.</span></span> <span data-ttu-id="a51a5-430">Как и ожидалось, чем сложнее запрос, тем больше преимуществ вы увидите при кэше плана запроса.</span><span class="sxs-lookup"><span data-stu-id="a51a5-430">As expected, the more complex the query is, the more benefit you will see from query plan caching.</span></span>

<span data-ttu-id="a51a5-431">Поскольку компилированный кекери на самом деле является запросом LIN's с кэшированным планом, сравнение компиляционного запроса по сравнению с эквивалентным запросом Entity S'L должно иметь аналогичные результаты.</span><span class="sxs-lookup"><span data-stu-id="a51a5-431">Because a CompiledQuery is really a LINQ query with its plan cached, the comparison of a CompiledQuery versus the equivalent Entity SQL query should have similar results.</span></span> <span data-ttu-id="a51a5-432">В самом деле, если приложение имеет много динамических запросов Entity S'L, заполнение кэша с запросами также будет эффективно причиной Compiled'запросы "декомпилировать", когда они смыты из кэша.</span><span class="sxs-lookup"><span data-stu-id="a51a5-432">In fact, if an app has lots of dynamic Entity SQL queries, filling the cache with queries will also effectively cause CompiledQueries to “decompile” when they are flushed from the cache.</span></span> <span data-ttu-id="a51a5-433">В этом сценарии производительность может быть улучшена путем отключения кэширования динамических запросов для определения приоритетов компиляжных запросов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-433">In this scenario, performance may be improved by disabling caching on the dynamic queries to prioritize the CompiledQueries.</span></span> <span data-ttu-id="a51a5-434">А еще лучше, конечно, было бы переписать приложение, чтобы использовать параметризированные запросы вместо динамических запросов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-434">Better yet, of course, would be to rewrite the app to use parameterized queries instead of dynamic queries.</span></span>

### <a name="33-using-compiledquery-to-improve-performance-with-linq-queries"></a><span data-ttu-id="a51a5-435">3.3 Использование компилированных кюкери для повышения производительности с помощью запросов LIN</span><span class="sxs-lookup"><span data-stu-id="a51a5-435">3.3 Using CompiledQuery to improve performance with LINQ queries</span></span>

<span data-ttu-id="a51a5-436">Наши тесты показывают, что использование компилированного квиера может принести пользу в размере 7% по сравнению с автокомпилированными запросами LIN; это означает, что вы потратите на 7% меньше времени на выполнение кода из стека инфраструктуры сущности; это не означает, что ваше приложение будет на 7% быстрее.</span><span class="sxs-lookup"><span data-stu-id="a51a5-436">Our tests indicate that using CompiledQuery can bring a benefit of 7% over autocompiled LINQ queries; this means that you’ll spend 7% less time executing code from the Entity Framework stack; it does not mean your application will be 7% faster.</span></span> <span data-ttu-id="a51a5-437">Вообще говоря, стоимость написания и обслуживания объектов компиляторы в EF 5.0 не может быть стоит проблемы по сравнению с преимуществами.</span><span class="sxs-lookup"><span data-stu-id="a51a5-437">Generally speaking, the cost of writing and maintaining CompiledQuery objects in EF 5.0 may not be worth the trouble when compared to the benefits.</span></span> <span data-ttu-id="a51a5-438">Ваш пробег может варьироваться, поэтому воспроизвите эту опцию, если ваш проект требует дополнительного толчка.</span><span class="sxs-lookup"><span data-stu-id="a51a5-438">Your mileage may vary, so exercise this option if your project requires the extra push.</span></span> <span data-ttu-id="a51a5-439">Обратите внимание, что компилированные запросы совместимы только с моделями, полученными из ObjectContext, и не совместимы с моделями, полученными из DbContext.</span><span class="sxs-lookup"><span data-stu-id="a51a5-439">Note that CompiledQueries are only compatible with ObjectContext-derived models, and not compatible with DbContext-derived models.</span></span>

<span data-ttu-id="a51a5-440">Для получения дополнительной информации о создании и вызывании компилированного квикери см. [Compiled Queries (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx)</span><span class="sxs-lookup"><span data-stu-id="a51a5-440">For more information on creating and invoking a CompiledQuery, see [Compiled Queries (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx).</span></span>

<span data-ttu-id="a51a5-441">При использовании компилированного кикери необходимо учитывать два соображения, а именно требование использовать статические экземпляры и проблемы, которые они имеют при композициях.</span><span class="sxs-lookup"><span data-stu-id="a51a5-441">There are two considerations you have to take when using a CompiledQuery, namely the requirement to use static instances and the problems they have with composability.</span></span> <span data-ttu-id="a51a5-442">Ниже приводится подробное объяснение этих двух соображений.</span><span class="sxs-lookup"><span data-stu-id="a51a5-442">Here follows an in-depth explanation of these two considerations.</span></span>

#### <a name="331-use-static-compiledquery-instances"></a><span data-ttu-id="a51a5-443">3.3.1 Использование статических экземпляров компиляций</span><span class="sxs-lookup"><span data-stu-id="a51a5-443">3.3.1       Use static CompiledQuery instances</span></span>

<span data-ttu-id="a51a5-444">Поскольку компиляция запроса LIN's занимает много времени, мы не хотим делать это каждый раз, когда нам нужно получать данные из базы данных.</span><span class="sxs-lookup"><span data-stu-id="a51a5-444">Since compiling a LINQ query is a time-consuming process, we don’t want to do it every time we need to fetch data from the database.</span></span> <span data-ttu-id="a51a5-445">Компилированные экземпляры позволяют компилировать один раз и запускать несколько раз, но вы должны быть осторожны и закупать повторно использовать тот же экземпляр Компилекинга каждый раз, вместо того, чтобы компиляции его снова и снова.</span><span class="sxs-lookup"><span data-stu-id="a51a5-445">CompiledQuery instances allow you to compile once and run multiple times, but you have to be careful and procure to re-use the same CompiledQuery instance every time instead of compiling it over and over again.</span></span> <span data-ttu-id="a51a5-446">Использование статических членов для хранения экземпляров Компилеци-Куира становится необходимым; в противном случае вы не увидите никакой пользы.</span><span class="sxs-lookup"><span data-stu-id="a51a5-446">The use of static members to store the CompiledQuery instances becomes necessary; otherwise you won’t see any benefit.</span></span>

<span data-ttu-id="a51a5-447">Например, предположим, что ваша страница имеет следующий корпус метода для обработки отображения продуктов для выбранной категории:</span><span class="sxs-lookup"><span data-stu-id="a51a5-447">For example, suppose your page has the following method body to handle displaying the products for the selected category:</span></span>

``` csharp
    // Warning: this is the wrong way of using CompiledQuery
    using (NorthwindEntities context = new NorthwindEntities())
    {
        string selectedCategory = this.categoriesList.SelectedValue;

        var productsForCategory = CompiledQuery.Compile<NorthwindEntities, string, IQueryable<Product>>(
            (NorthwindEntities nwnd, string category) =>
                nwnd.Products.Where(p => p.Category.CategoryName == category)
        );

        this.productsGrid.DataSource = productsForCategory.Invoke(context, selectedCategory).ToList();
        this.productsGrid.DataBind();
    }

    this.productsGrid.Visible = true;
```

<span data-ttu-id="a51a5-448">В этом случае вы будете создавать новый экземпляр Компиледовна на лету каждый раз, когда метод вызывается.</span><span class="sxs-lookup"><span data-stu-id="a51a5-448">In this case, you will create a new CompiledQuery instance on the fly every time the method is called.</span></span> <span data-ttu-id="a51a5-449">Вместо того, чтобы видеть преимущества производительности, извлекая команду хранилища из кэша плана запроса, компилятор компиляции плана будет проходить через компилятор плана каждый раз, когда создается новый экземпляр.</span><span class="sxs-lookup"><span data-stu-id="a51a5-449">Instead of seeing performance benefits by retrieving the store command from the query plan cache, the CompiledQuery will go through the plan compiler every time a new instance is created.</span></span> <span data-ttu-id="a51a5-450">На самом деле, каждый раз, когда метод вызывается, вы будете загрязнять кэш плана запросов новой записью Компиляции.</span><span class="sxs-lookup"><span data-stu-id="a51a5-450">In fact, you will be polluting your query plan cache with a new CompiledQuery entry every time the method is called.</span></span>

<span data-ttu-id="a51a5-451">Вместо этого необходимо создать статический экземпляр компилированного запроса, поэтому вы вызываете один и тот же компилированный запрос каждый раз, когда вызывается метод.</span><span class="sxs-lookup"><span data-stu-id="a51a5-451">Instead, you want to create a static instance of the compiled query, so you are invoking the same compiled query every time the method is called.</span></span> <span data-ttu-id="a51a5-452">Одним из способов этого является добавление экземпляра компилированного кекери в качестве члена контекста объекта.</span><span class="sxs-lookup"><span data-stu-id="a51a5-452">One way to so this is by adding the CompiledQuery instance as a member of your object context.</span></span><span data-ttu-id="a51a5-453">Затем вы можете сделать вещи немного чище, обратившись к компилятору с помощью вспомогательного метода:</span><span class="sxs-lookup"><span data-stu-id="a51a5-453">  You can then make things a little cleaner by accessing the CompiledQuery through a helper method:</span></span>

``` csharp
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IEnumerable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
            );

        public IEnumerable<Product> GetProductsForCategory(string categoryName)
        {
            return productsForCategoryCQ.Invoke(this, categoryName).ToList();
        }
```

<span data-ttu-id="a51a5-454">Этот метод помощника будет использоваться следующим образом:</span><span class="sxs-lookup"><span data-stu-id="a51a5-454">This helper method would be invoked as follows:</span></span>

``` csharp
    this.productsGrid.DataSource = context.GetProductsForCategory(selectedCategory);
```

#### <a name="332-composing-over-a-compiledquery"></a><span data-ttu-id="a51a5-455">3.3.2 Составление по компилированному кемери</span><span class="sxs-lookup"><span data-stu-id="a51a5-455">3.3.2       Composing over a CompiledQuery</span></span>

<span data-ttu-id="a51a5-456">Возможность сочинять по любой запросу LIN'а чрезвычайно полезна; для этого вы просто вызываете метод после i'E'E'Eiryable, таких как *Skip()* или *Count()*.</span><span class="sxs-lookup"><span data-stu-id="a51a5-456">The ability to compose over any LINQ query is extremely useful; to do this, you simply invoke a method after the IQueryable such as *Skip()* or *Count()*.</span></span> <span data-ttu-id="a51a5-457">Тем не менее, это по существу возвращает новый объект i'squeryable.</span><span class="sxs-lookup"><span data-stu-id="a51a5-457">However, doing so essentially returns a new IQueryable object.</span></span> <span data-ttu-id="a51a5-458">Несмотря на то, что технически не остановить вас от составления компиляций, это приведет к генерации нового объекта, который требует повторного прохождения через компилятор плана.</span><span class="sxs-lookup"><span data-stu-id="a51a5-458">While there’s nothing to stop you technically from composing over a CompiledQuery, doing so will cause the generation of a new IQueryable object that requires passing through the plan compiler again.</span></span>

<span data-ttu-id="a51a5-459">Некоторые компоненты будут использовать составные объекты, которые можно использовать для обеспечения расширенной функциональности.</span><span class="sxs-lookup"><span data-stu-id="a51a5-459">Some components will make use of composed IQueryable objects to enable advanced functionality.</span></span> <span data-ttu-id="a51a5-460">Например, ASP. GridView NET может быть привязан к объекту, который можно сделать через свойство SelectMethod.</span><span class="sxs-lookup"><span data-stu-id="a51a5-460">For example, ASP.NET’s GridView can be data-bound to an IQueryable object via the SelectMethod property.</span></span> <span data-ttu-id="a51a5-461">Затем GridView будет составлять над этим объектом, который можно сделать, чтобы сортировать и прокладывать по модели данных.</span><span class="sxs-lookup"><span data-stu-id="a51a5-461">The GridView will then compose over this IQueryable object to allow sorting and paging over the data model.</span></span> <span data-ttu-id="a51a5-462">Как вы можете видеть, использование компилированного query для GridView не попадет в компилированный запрос, а создаст новый автоматически скомпилированный запрос.</span><span class="sxs-lookup"><span data-stu-id="a51a5-462">As you can see, using a CompiledQuery for the GridView would not hit the compiled query but would generate a new autocompiled query.</span></span>

<span data-ttu-id="a51a5-463">Одно из мест, где вы можете столкнуться с этим при добавлении прогрессивных фильтров в запрос.</span><span class="sxs-lookup"><span data-stu-id="a51a5-463">One place where you may run into this is when adding progressive filters to a query.</span></span> <span data-ttu-id="a51a5-464">Например, предположим, что у вас есть страница Клиентов с несколькими списками выпадающих для дополнительных фильтров (например, Country and OrdersCount).</span><span class="sxs-lookup"><span data-stu-id="a51a5-464">For example, suppose you had a Customers page with several drop-down lists for optional filters (for example, Country and OrdersCount).</span></span> <span data-ttu-id="a51a5-465">Эти фильтры можно составить по сравнению с результатами компилируемых кекеров, но это приведет к тому, что новый запрос будет проходить через компилятор плана каждый раз, когда вы его выполняете.</span><span class="sxs-lookup"><span data-stu-id="a51a5-465">You can compose these filters over the IQueryable results of a CompiledQuery, but doing so will result in the new query going through the plan compiler every time you execute it.</span></span>

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployee();

        if (this.orderCountFilterList.SelectedItem.Value != defaultFilterText)
        {
            int orderCount = int.Parse(orderCountFilterList.SelectedValue);
            myCustomers = myCustomers.Where(c => c.Orders.Count > orderCount);
        }

        if (this.countryFilterList.SelectedItem.Value != defaultFilterText)
        {
            myCustomers = myCustomers.Where(c => c.Address.Country == countryFilterList.SelectedValue);
        }

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 <span data-ttu-id="a51a5-466">Чтобы избежать этой перекомпимации, можно переписать компиляционный кюкери, чтобы учесть возможные фильтры:</span><span class="sxs-lookup"><span data-stu-id="a51a5-466">To avoid this re-compilation, you can rewrite the CompiledQuery to take the possible filters into account:</span></span>

``` csharp
    private static readonly Func<NorthwindEntities, int, int?, string, IQueryable<Customer>> customersForEmployeeWithFiltersCQ = CompiledQuery.Compile(
        (NorthwindEntities context, int empId, int? countFilter, string countryFilter) =>
            context.Customers.Where(c => c.Orders.Any(o => o.EmployeeID == empId))
            .Where(c => countFilter.HasValue == false || c.Orders.Count > countFilter)
            .Where(c => countryFilter == null || c.Address.Country == countryFilter)
        );
```

<span data-ttu-id="a51a5-467">Что будет ссылаться в uI, как:</span><span class="sxs-lookup"><span data-stu-id="a51a5-467">Which would be invoked in the UI like:</span></span>

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        int? countFilter = (this.orderCountFilterList.SelectedIndex == 0) ?
            (int?)null :
            int.Parse(this.orderCountFilterList.SelectedValue);

        string countryFilter = (this.countryFilterList.SelectedIndex == 0) ?
            null :
            this.countryFilterList.SelectedValue;

        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployeeWithFilters(
                countFilter, countryFilter);

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 <span data-ttu-id="a51a5-468">Компромиссом здесь является сгенерированная команда магазина всегда будет иметь фильтры с нулевыми проверками, но они должны быть довольно простыми для сервера базы данных для оптимизации:</span><span class="sxs-lookup"><span data-stu-id="a51a5-468">A tradeoff here is the generated store command will always have the filters with the null checks, but these should be fairly simple for the database server to optimize:</span></span>

``` SQL
...
WHERE ((0 = (CASE WHEN (@p__linq__1 IS NOT NULL) THEN cast(1 as bit) WHEN (@p__linq__1 IS NULL) THEN cast(0 as bit) END)) OR ([Project3].[C2] > @p__linq__2)) AND (@p__linq__3 IS NULL OR [Project3].[Country] = @p__linq__4)
```

### <a name="34-metadata-caching"></a><span data-ttu-id="a51a5-469">3.4 Кэширование метаданных</span><span class="sxs-lookup"><span data-stu-id="a51a5-469">3.4 Metadata caching</span></span>

<span data-ttu-id="a51a5-470">Рамочная система сущности также поддерживает кэширование метаданных.</span><span class="sxs-lookup"><span data-stu-id="a51a5-470">The Entity Framework also supports Metadata caching.</span></span> <span data-ttu-id="a51a5-471">По сути, это кэширование информации типа и отображение информации от типа к базе данных в разных соединениях с одной и той же моделью.</span><span class="sxs-lookup"><span data-stu-id="a51a5-471">This is essentially caching of type information and type-to-database mapping information across different connections to the same model.</span></span> <span data-ttu-id="a51a5-472">Кэш Metadata уникален для AppDomain.</span><span class="sxs-lookup"><span data-stu-id="a51a5-472">The Metadata cache is unique per AppDomain.</span></span>

#### <a name="341-metadata-caching-algorithm"></a><span data-ttu-id="a51a5-473">3.4.1 Алгоритм кэширования метаданных</span><span class="sxs-lookup"><span data-stu-id="a51a5-473">3.4.1 Metadata Caching algorithm</span></span>

1.  <span data-ttu-id="a51a5-474">Информация о метаданных для модели хранится в ItemCollection для каждого EntityConnection.</span><span class="sxs-lookup"><span data-stu-id="a51a5-474">Metadata information for a model is stored in an ItemCollection for each EntityConnection.</span></span>
    -   <span data-ttu-id="a51a5-475">В качестве примечания следует, что существуют различные объекты ItemCollection для различных частей модели.</span><span class="sxs-lookup"><span data-stu-id="a51a5-475">As a side note, there are different ItemCollection objects for different parts of the model.</span></span> <span data-ttu-id="a51a5-476">Например, StoreItemCollections содержит информацию о модели базы данных; ObjectItemCollection содержит информацию о модели данных; EdmItemCollection содержит информацию о концептуальной модели.</span><span class="sxs-lookup"><span data-stu-id="a51a5-476">For example, StoreItemCollections contains the information about the database model; ObjectItemCollection contains information about the data model; EdmItemCollection contains information about the conceptual model.</span></span>

2.  <span data-ttu-id="a51a5-477">Если два соединения используют одну и ту же строку соединения, они будут совместно использовать один и тот же экземпляр ItemCollection.</span><span class="sxs-lookup"><span data-stu-id="a51a5-477">If two connections use the same connection string, they will share the same ItemCollection instance.</span></span>
3.  <span data-ttu-id="a51a5-478">Функционально эквивалентно, но текстуически разные строки соединения могут привести к различным кэшам метаданных.</span><span class="sxs-lookup"><span data-stu-id="a51a5-478">Functionally equivalent but textually different connection strings may result in different metadata caches.</span></span> <span data-ttu-id="a51a5-479">Мы делаем токенизировать строки соединения, поэтому простое изменение порядка токенов должно привести к общим метаданным.</span><span class="sxs-lookup"><span data-stu-id="a51a5-479">We do tokenize connection strings, so simply changing the order of the tokens should result in shared metadata.</span></span> <span data-ttu-id="a51a5-480">Но две строки соединения, которые кажутся функционально одинаковыми, не могут быть оценены как идентичные после токенизации.</span><span class="sxs-lookup"><span data-stu-id="a51a5-480">But two connection strings that seem functionally the same may not be evaluated as identical after tokenization.</span></span>
4.  <span data-ttu-id="a51a5-481">Элементколлекции периодически проверяется на использование.</span><span class="sxs-lookup"><span data-stu-id="a51a5-481">The ItemCollection is periodically checked for use.</span></span> <span data-ttu-id="a51a5-482">Если установлено, что рабочее пространство не было доступно в последнее время, оно будет помечено для очистки при следующем размахе кэша.</span><span class="sxs-lookup"><span data-stu-id="a51a5-482">If it is determined that a workspace has not been accessed recently, it will be marked for cleanup on the next cache sweep.</span></span>
5.  <span data-ttu-id="a51a5-483">Простое создание EntityConnection приведет к созданию кэша метаданных (хотя коллекции элементов в нем не будут инициализированы до открытия соединения).</span><span class="sxs-lookup"><span data-stu-id="a51a5-483">Merely creating an EntityConnection will cause a metadata cache to be created (though the item collections in it will not be initialized until the connection is opened).</span></span> <span data-ttu-id="a51a5-484">Это рабочее пространство будет оставаться в памяти до тех пор, пока алгоритм кэширования не определит, что оно не используется.</span><span class="sxs-lookup"><span data-stu-id="a51a5-484">This workspace will remain in-memory until the caching algorithm determines it is not “in use”.</span></span>

<span data-ttu-id="a51a5-485">Консультационная группа по работе с клиентами написала сообщение в блоге, в которой описывается проведение \< https://docs.microsoft.com/archive/blogs/appfabriccat/holding-a-reference-to-the-ef-metadataworkspace-for-wcf-services>ссылки на ItemCollection, чтобы избежать "амортизацию" при использовании больших моделей: .</span><span class="sxs-lookup"><span data-stu-id="a51a5-485">The Customer Advisory Team has written a blog post that describes holding a reference to an ItemCollection in order to avoid "deprecation" when using large models: \<https://docs.microsoft.com/archive/blogs/appfabriccat/holding-a-reference-to-the-ef-metadataworkspace-for-wcf-services>.</span></span>

#### <a name="342-the-relationship-between-metadata-caching-and-query-plan-caching"></a><span data-ttu-id="a51a5-486">3.4.2 Взаимосвязь между кэшированием метаданных и кэшингом плана запросов</span><span class="sxs-lookup"><span data-stu-id="a51a5-486">3.4.2 The relationship between Metadata Caching and Query Plan Caching</span></span>

<span data-ttu-id="a51a5-487">Экземпляр кэша плана запроса живет в элементозачах типов магазинов MetadataWorkspace.</span><span class="sxs-lookup"><span data-stu-id="a51a5-487">The query plan cache instance lives in the MetadataWorkspace's ItemCollection of store types.</span></span> <span data-ttu-id="a51a5-488">Это означает, что кэшированные команды хранилища будут использоваться для запросов в любом контексте, мгновенно мгновенном использовании данного пространства MetadataWork.</span><span class="sxs-lookup"><span data-stu-id="a51a5-488">This means that cached store commands will be used for queries against any context instantiated using a given MetadataWorkspace.</span></span> <span data-ttu-id="a51a5-489">Это также означает, что если у вас есть две строки соединений, которые немного отличаются и не совпадают после токенизации, у вас будут разные экземпляры кэша плана запросов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-489">It also means that if you have two connections strings that are slightly different and don't match after tokenizing, you will have different query plan cache instances.</span></span>

### <a name="35-results-caching"></a><span data-ttu-id="a51a5-490">3.5 Кэширование результатов</span><span class="sxs-lookup"><span data-stu-id="a51a5-490">3.5 Results caching</span></span>

<span data-ttu-id="a51a5-491">При кэше результатов (также известном как «кэширование второго уровня») вы сохраняете результаты запросов в локальном кэше.</span><span class="sxs-lookup"><span data-stu-id="a51a5-491">With results caching (also known as "second-level caching"), you keep the results of queries in a local cache.</span></span> <span data-ttu-id="a51a5-492">При выдаче запроса сначала вывидите, доступны ли результаты локально, прежде чем вы будете отвечать за магазин.</span><span class="sxs-lookup"><span data-stu-id="a51a5-492">When issuing a query, you first see if the results are available locally before you query against the store.</span></span> <span data-ttu-id="a51a5-493">Хотя кэширование результатов напрямую не поддерживается рамочной системой entity, можно добавить кэш второго уровня с помощью поставщика упаковки.</span><span class="sxs-lookup"><span data-stu-id="a51a5-493">While results caching isn't directly supported by Entity Framework, it's possible to add a second level cache by using a wrapping provider.</span></span> <span data-ttu-id="a51a5-494">Примером поставщика упаковки с кэшем второго уровня является Кэш второго уровня Alachisoft [Entity Framework Second Level, основанный на NCache.](https://www.alachisoft.com/ncache/entity-framework.html)</span><span class="sxs-lookup"><span data-stu-id="a51a5-494">An example wrapping provider with a second-level cache is Alachisoft's [Entity Framework Second Level Cache based on NCache](https://www.alachisoft.com/ncache/entity-framework.html).</span></span>

<span data-ttu-id="a51a5-495">Эта реализация кэширования второго уровня является инъекционной функциональностью, которая происходит после оценки (и funcletized выражения) и вычисляется или извлекается план выполнения запроса из кэша первого уровня.</span><span class="sxs-lookup"><span data-stu-id="a51a5-495">This implementation of second-level caching is an injected functionality that takes place after the LINQ expression has been evaluated (and funcletized) and the query execution plan is computed or retrieved from the first-level cache.</span></span> <span data-ttu-id="a51a5-496">Кэш второго уровня будет хранить только необработанные результаты базы данных, поэтому конвейер материализации по-прежнему выполняется после этого.</span><span class="sxs-lookup"><span data-stu-id="a51a5-496">The second-level cache will then store only the raw database results, so the materialization pipeline still executes afterwards.</span></span>

#### <a name="351-additional-references-for-results-caching-with-the-wrapping-provider"></a><span data-ttu-id="a51a5-497">3.5.1 Дополнительные ссылки на кэширование результатов с поставщиком упаковки</span><span class="sxs-lookup"><span data-stu-id="a51a5-497">3.5.1 Additional references for results caching with the wrapping provider</span></span>

-   <span data-ttu-id="a51a5-498">Джули Лерман написала статью MSDN «Второй уровень кэширования в рамках сущности и Windows Azure», которая включает в себя, как обновить поставщик оберток образца для использования кэширования Windows Server AppFabric:[https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)</span><span class="sxs-lookup"><span data-stu-id="a51a5-498">Julie Lerman has written a "Second-Level Caching in Entity Framework and Windows Azure" MSDN article that includes how to update the sample wrapping provider to use Windows Server AppFabric caching: [https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)</span></span>
-   <span data-ttu-id="a51a5-499">Если вы работаете с Entity Framework 5, в блоге команды есть публикация, в которой \< https://docs.microsoft.com/archive/blogs/adonet/ef-caching-with-jarek-kowalskis-provider>описывается, как запустить работу с поставщиком кэширования для Entity Framework 5: .</span><span class="sxs-lookup"><span data-stu-id="a51a5-499">If you are working with Entity Framework 5, the team blog has a post that describes how to get things running with the caching provider for Entity Framework 5: \<https://docs.microsoft.com/archive/blogs/adonet/ef-caching-with-jarek-kowalskis-provider>.</span></span> <span data-ttu-id="a51a5-500">Он также включает в себя шаблон T4, чтобы помочь автоматизировать добавление кэширования 2-го уровня в ваш проект.</span><span class="sxs-lookup"><span data-stu-id="a51a5-500">It also includes a T4 template to help automate adding the 2nd-level caching to your project.</span></span>

## <a name="4-autocompiled-queries"></a><span data-ttu-id="a51a5-501">4 Автокомпилированные запросы</span><span class="sxs-lookup"><span data-stu-id="a51a5-501">4 Autocompiled Queries</span></span>

<span data-ttu-id="a51a5-502">Когда запрос выдается в отношении базы данных с использованием рамочной базы, он должен пройти через ряд шагов, прежде чем фактически материализовать результаты; одним из таких шагов является компиляция запросов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-502">When a query is issued against a database using Entity Framework, it must go through a series of steps before actually materializing the results; one such step is Query Compilation.</span></span> <span data-ttu-id="a51a5-503">Было известно, что запросы сущности S'L имеют хорошую производительность, так как они автоматически кэшируются, поэтому во втором или третьем разе выполнения того же запроса он может пропустить компилятор плана и использовать вместо этого кэшированный план.</span><span class="sxs-lookup"><span data-stu-id="a51a5-503">Entity SQL queries were known to have good performance as they are automatically cached, so the second or third time you execute the same query it can skip the plan compiler and use the cached plan instead.</span></span>

<span data-ttu-id="a51a5-504">Система Сущности 5 ввела автоматическое кэширование для запросов линз для организаций.</span><span class="sxs-lookup"><span data-stu-id="a51a5-504">Entity Framework 5 introduced automatic caching for LINQ to Entities queries as well.</span></span> <span data-ttu-id="a51a5-505">В прошлых выпусках Рамочной системы сущности создание компиляций для ускорения производительности было обычной практикой, так как это сделает ваш кэшируемый запрос на количество запросов для СУЩНОСТи.</span><span class="sxs-lookup"><span data-stu-id="a51a5-505">In past editions of Entity Framework creating a CompiledQuery to speed your performance was a common practice, as this would make your LINQ to Entities query cacheable.</span></span> <span data-ttu-id="a51a5-506">Поскольку кэширование теперь выполняется автоматически без использования компилированного кикери, мы называем эту функцию "автокомпилированными запросами".</span><span class="sxs-lookup"><span data-stu-id="a51a5-506">Since caching is now done automatically without the use of a CompiledQuery, we call this feature “autocompiled queries”.</span></span> <span data-ttu-id="a51a5-507">Для получения дополнительной информации о кэше плана запроса и его механике см.</span><span class="sxs-lookup"><span data-stu-id="a51a5-507">For more information about the query plan cache and its mechanics, see Query Plan Caching.</span></span>

<span data-ttu-id="a51a5-508">Система сущности обнаруживает, когда запрос требует перекомпилироваться, и делает это, когда запрос вызывается, даже если он был компилирован ранее.</span><span class="sxs-lookup"><span data-stu-id="a51a5-508">Entity Framework detects when a query requires to be recompiled, and does so when the query is invoked even if it had been compiled before.</span></span> <span data-ttu-id="a51a5-509">Общие условия, которые вызывают перекомпилировать запрос:</span><span class="sxs-lookup"><span data-stu-id="a51a5-509">Common conditions that cause the query to be recompiled are:</span></span>

-   <span data-ttu-id="a51a5-510">Изменение MergeOption, связанного с вашим запросом.</span><span class="sxs-lookup"><span data-stu-id="a51a5-510">Changing the MergeOption associated to your query.</span></span> <span data-ttu-id="a51a5-511">Кэшированный запрос не будет использоваться, вместо этого компилятор плана будет работать снова и вновь созданный план кэшируется.</span><span class="sxs-lookup"><span data-stu-id="a51a5-511">The cached query will not be used, instead the plan compiler will run again and the newly created plan gets cached.</span></span>
-   <span data-ttu-id="a51a5-512">Изменение значения ContextOptions.UseSharpNullComparisonBehavior.</span><span class="sxs-lookup"><span data-stu-id="a51a5-512">Changing the value of ContextOptions.UseCSharpNullComparisonBehavior.</span></span> <span data-ttu-id="a51a5-513">Вы получаете тот же эффект, что и изменение MergeOption.</span><span class="sxs-lookup"><span data-stu-id="a51a5-513">You get the same effect as changing the MergeOption.</span></span>

<span data-ttu-id="a51a5-514">Другие условия могут помешать запросу использовать кэш.</span><span class="sxs-lookup"><span data-stu-id="a51a5-514">Other conditions can prevent your query from using the cache.</span></span> <span data-ttu-id="a51a5-515">Ниже приведены распространенные примеры.</span><span class="sxs-lookup"><span data-stu-id="a51a5-515">Common examples are:</span></span>

-   <span data-ttu-id="a51a5-516">Использование&lt;IEnumerable&gt;T . Содержит&lt;&gt;(значение T).</span><span class="sxs-lookup"><span data-stu-id="a51a5-516">Using IEnumerable&lt;T&gt;.Contains&lt;&gt;(T value).</span></span>
-   <span data-ttu-id="a51a5-517">Использование функций, которые производят запросы с константами.</span><span class="sxs-lookup"><span data-stu-id="a51a5-517">Using functions that produce queries with constants.</span></span>
-   <span data-ttu-id="a51a5-518">Использование свойств неотображаемого объекта.</span><span class="sxs-lookup"><span data-stu-id="a51a5-518">Using the properties of a non-mapped object.</span></span>
-   <span data-ttu-id="a51a5-519">Связывание запроса с другим запросом, требующим повторной компиляции.</span><span class="sxs-lookup"><span data-stu-id="a51a5-519">Linking your query to another query that requires to be recompiled.</span></span>

### <a name="41-using-ienumerablelttgtcontainslttgtt-value"></a><span data-ttu-id="a51a5-520">4.1 Использование IEnumerable&lt;T&gt;. Содержит&lt;&gt;T (значение T)</span><span class="sxs-lookup"><span data-stu-id="a51a5-520">4.1 Using IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value)</span></span>

<span data-ttu-id="a51a5-521">Система сущности не кэширует запросы, которые&lt;вызывают&gt;IEnumerable T. Содержит&lt;&gt;T (значение T) в отношении коллекции в памяти, так как значения коллекции считаются неустойчивыми.</span><span class="sxs-lookup"><span data-stu-id="a51a5-521">Entity Framework does not cache queries that invoke IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value) against an in-memory collection, since the values of the collection are considered volatile.</span></span> <span data-ttu-id="a51a5-522">Следующий пример запрос не будет кэшироваться, поэтому он всегда будет обрабатываться компилятором плана:</span><span class="sxs-lookup"><span data-stu-id="a51a5-522">The following example query will not be cached, so it will always be processed by the plan compiler:</span></span>

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var query = context.MyEntities
                    .Where(entity => ids.Contains(entity.Id));

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="a51a5-523">Обратите внимание, что размер IEnumerable, в соответствии с которым выполняется содержится, определяет, насколько быстро или как медленно компилируется ваш запрос.</span><span class="sxs-lookup"><span data-stu-id="a51a5-523">Note that the size of the IEnumerable against which Contains is executed determines how fast or how slow your query is compiled.</span></span> <span data-ttu-id="a51a5-524">Производительность может значительно пострадать при использовании больших коллекций, таких как тот, показанный в примере выше.</span><span class="sxs-lookup"><span data-stu-id="a51a5-524">Performance can suffer significantly when using large collections such as the one shown in the example above.</span></span>

<span data-ttu-id="a51a5-525">Система Entity Framework 6 содержит оптимизацию способа IEnumerable&lt;T.&gt; Содержит&lt;&gt;T (значение T) работает при выполнении запросов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-525">Entity Framework 6 contains optimizations to the way IEnumerable&lt;T&gt;.Contains&lt;T&gt;(T value) works when queries are executed.</span></span> <span data-ttu-id="a51a5-526">Сгенерированный код S'L гораздо быстрее в производстве и более читаемый, и в большинстве случаев он также выполняется быстрее на сервере.</span><span class="sxs-lookup"><span data-stu-id="a51a5-526">The SQL code that is generated is much faster to produce and more readable, and in most cases it also executes faster in the server.</span></span>

### <a name="42-using-functions-that-produce-queries-with-constants"></a><span data-ttu-id="a51a5-527">4.2 Использование функций, которые производят запросы с константами</span><span class="sxs-lookup"><span data-stu-id="a51a5-527">4.2 Using functions that produce queries with constants</span></span>

<span data-ttu-id="a51a5-528">Операторы Скипа(), Take(), Содержит () и DefautIfEmpty() операторы LIN's не производят запросы с параметрами, а вместо этого помещают передаваемые им значения в качестве констант.</span><span class="sxs-lookup"><span data-stu-id="a51a5-528">The Skip(), Take(), Contains() and DefautIfEmpty() LINQ operators do not produce SQL queries with parameters but instead put the values passed to them as constants.</span></span> <span data-ttu-id="a51a5-529">Из-за этого запросы, которые в противном случае могли бы быть идентичными, в конечном итоге загрязняют кэш плана запросов, как в стеке EF, так и на сервере базы данных, и не используются повторно, если одни и те же константы не используются в последующем выполнении запроса.</span><span class="sxs-lookup"><span data-stu-id="a51a5-529">Because of this, queries that might otherwise be identical end up polluting the query plan cache, both on the EF stack and on the database server, and do not get reutilized unless the same constants are used in a subsequent query execution.</span></span> <span data-ttu-id="a51a5-530">Пример:</span><span class="sxs-lookup"><span data-stu-id="a51a5-530">For example:</span></span>

``` csharp
var id = 10;
...
using (var context = new MyContext())
{
    var query = context.MyEntities.Select(entity => entity.Id).Contains(id);

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="a51a5-531">В этом примере каждый раз, когда этот запрос выполняется с другим значением для идентификатора, запрос будет компилирован в новый план.</span><span class="sxs-lookup"><span data-stu-id="a51a5-531">In this example, each time this query is executed with a different value for id the query will be compiled into a new plan.</span></span>

<span data-ttu-id="a51a5-532">В частности, обратите внимание на использование Skip и принять при выполнении paging.</span><span class="sxs-lookup"><span data-stu-id="a51a5-532">In particular pay attention to the use of Skip and Take when doing paging.</span></span> <span data-ttu-id="a51a5-533">В EF6 эти методы имеют перегрузку lambda, которая фактически делает план кэшированного запроса многоразовым, потому что EF может фиксировать переменные, передаваемые этим методам, и переводить их в S'Lparameters.</span><span class="sxs-lookup"><span data-stu-id="a51a5-533">In EF6 these methods have a lambda overload that effectively makes the cached query plan reusable because EF can capture variables passed to these methods and translate them to SQLparameters.</span></span> <span data-ttu-id="a51a5-534">Это также помогает сохранить кэш чище, так как в противном случае каждый запрос с другой константой для Skip и Take получит свою собственную запись кэша плана запросов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-534">This also helps keep the cache cleaner since otherwise each query with a different constant for Skip and Take would get its own query plan cache entry.</span></span>

<span data-ttu-id="a51a5-535">Рассмотрим следующий код, который является неоптимальным, но предназначен только для примера этого класса запросов:</span><span class="sxs-lookup"><span data-stu-id="a51a5-535">Consider the following code, which is suboptimal but is only meant to exemplify this class of queries:</span></span>

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

<span data-ttu-id="a51a5-536">Более быстрая версия этого же кода будет включать вызов Skip с лямбдой:</span><span class="sxs-lookup"><span data-stu-id="a51a5-536">A faster version of this same code would involve calling Skip with a lambda:</span></span>

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(() => i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

<span data-ttu-id="a51a5-537">Второй фрагмент может работать до 11% быстрее, потому что один и тот же план запроса используется каждый раз, когда запрос запущен, что экономит время процессора и позволяет избежать загрязнения кэша запроса.</span><span class="sxs-lookup"><span data-stu-id="a51a5-537">The second snippet may run up to 11% faster because the same query plan is used every time the query is run, which saves CPU time and avoids polluting the query cache.</span></span> <span data-ttu-id="a51a5-538">Кроме того, поскольку параметр Skip находится в замыкании, код может также выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="a51a5-538">Furthermore, because the parameter to Skip is in a closure the code might as well look like this now:</span></span>

``` csharp
var i = 0;
var skippyCustomers = context.Customers.OrderBy(c => c.LastName).Skip(() => i);
for (; i < count; ++i)
{
    var currentCustomer = skippyCustomers.FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

### <a name="43-using-the-properties-of-a-non-mapped-object"></a><span data-ttu-id="a51a5-539">4.3 Использование свойств неотображаемого объекта</span><span class="sxs-lookup"><span data-stu-id="a51a5-539">4.3 Using the properties of a non-mapped object</span></span>

<span data-ttu-id="a51a5-540">Когда запрос использует свойства неотображаемого типа объекта в качестве параметра, то запрос не будет кэширован.</span><span class="sxs-lookup"><span data-stu-id="a51a5-540">When a query uses the properties of a non-mapped object type as a parameter then the query will not get cached.</span></span> <span data-ttu-id="a51a5-541">Пример:</span><span class="sxs-lookup"><span data-stu-id="a51a5-541">For example:</span></span>

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();

    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myObject.MyProperty)
                select entity;

   var results = query.ToList();
    ...
}
```

<span data-ttu-id="a51a5-542">В этом примере предположим, что класс NonMappedType не является частью модели Entity.</span><span class="sxs-lookup"><span data-stu-id="a51a5-542">In this example, assume that class NonMappedType is not part of the Entity model.</span></span> <span data-ttu-id="a51a5-543">Этот запрос можно легко изменить, чтобы не использовать некартный тип и вместо этого использовать локальную переменную в качестве параметра для запроса:</span><span class="sxs-lookup"><span data-stu-id="a51a5-543">This query can easily be changed to not use a non-mapped type and instead use a local variable as the parameter to the query:</span></span>

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();
    var myValue = myObject.MyProperty;
    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myValue)
                select entity;

    var results = query.ToList();
    ...
}
```

<span data-ttu-id="a51a5-544">В этом случае запрос сможет получить кэшии и получит выгоду от кэша плана запроса.</span><span class="sxs-lookup"><span data-stu-id="a51a5-544">In this case, the query will be able to get cached and will benefit from the query plan cache.</span></span>

### <a name="44-linking-to-queries-that-require-recompiling"></a><span data-ttu-id="a51a5-545">4.4 Ссылка на запросы, требующие перекомпиляции</span><span class="sxs-lookup"><span data-stu-id="a51a5-545">4.4 Linking to queries that require recompiling</span></span>

<span data-ttu-id="a51a5-546">Следуя тому же примеру, что и выше, если у вас есть второй запрос, который опирается на запрос, который необходимо перекомпилировать, весь второй запрос также будет перекомпилирован.</span><span class="sxs-lookup"><span data-stu-id="a51a5-546">Following the same example as above, if you have a second query that relies on a query that needs to be recompiled, your entire second query will also be recompiled.</span></span> <span data-ttu-id="a51a5-547">Вот пример, иллюстрирующий этот сценарий:</span><span class="sxs-lookup"><span data-stu-id="a51a5-547">Here’s an example to illustrate this scenario:</span></span>

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var firstQuery = from entity in context.MyEntities
                        where ids.Contains(entity.Id)
                        select entity;

    var secondQuery = from entity in context.MyEntities
                        where firstQuery.Any(otherEntity => otherEntity.Id == entity.Id)
                        select entity;

    var results = secondQuery.ToList();
    ...
}
```

<span data-ttu-id="a51a5-548">Пример общий, но он иллюстрирует, как ссылка на первыйкекери вызывает второй кекери, чтобы быть не в состоянии получить кэшированный.</span><span class="sxs-lookup"><span data-stu-id="a51a5-548">The example is generic, but it illustrates how linking to firstQuery is causing secondQuery to be unable to get cached.</span></span> <span data-ttu-id="a51a5-549">Если бы во-первых, не был запрос, требующий перекомпинера, то второй кекери был бы кэширован.</span><span class="sxs-lookup"><span data-stu-id="a51a5-549">If firstQuery had not been a query that requires recompiling, then secondQuery would have been cached.</span></span>

## <a name="5-notracking-queries"></a><span data-ttu-id="a51a5-550">5 Запросы без отслеживания</span><span class="sxs-lookup"><span data-stu-id="a51a5-550">5 NoTracking Queries</span></span>

### <a name="51-disabling-change-tracking-to-reduce-state-management-overhead"></a><span data-ttu-id="a51a5-551">5.1 Отключение отслеживания изменений для сокращения накладных расходов на управление государством</span><span class="sxs-lookup"><span data-stu-id="a51a5-551">5.1 Disabling change tracking to reduce state management overhead</span></span>

<span data-ttu-id="a51a5-552">Если вы находитесь в сценарии только для чтения и хотите избежать накладных расходов на загрузку объектов в ObjectStateManager, вы можете выдать запросы "Нет отслеживания".</span><span class="sxs-lookup"><span data-stu-id="a51a5-552">If you are in a read-only scenario and want to avoid the overhead of loading the objects into the ObjectStateManager, you can issue "No Tracking" queries.</span></span><span data-ttu-id="a51a5-553">Отслеживание изменений может быть отключено на уровне запроса.</span><span class="sxs-lookup"><span data-stu-id="a51a5-553">  Change tracking can be disabled at the query level.</span></span>

<span data-ttu-id="a51a5-554">Обратите внимание, однако, что, отключив отслеживание изменений, вы эффективно выключаете кэш объекта.</span><span class="sxs-lookup"><span data-stu-id="a51a5-554">Note though that by disabling change tracking you are effectively turning off the object cache.</span></span> <span data-ttu-id="a51a5-555">При запросе сущности мы не можем пропустить материализацию, потянув результаты ранее материализованного запроса от ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="a51a5-555">When you query for an entity, we can't skip materialization by pulling the previously-materialized query results from the ObjectStateManager.</span></span> <span data-ttu-id="a51a5-556">Если вы неоднократно задавляете запросы для одних и тех же сущностей в одном контексте, можно увидеть выгоду от включения отслеживания изменений в пользу производительности.</span><span class="sxs-lookup"><span data-stu-id="a51a5-556">If you are repeatedly querying for the same entities on the same context, you might actually see a performance benefit from enabling change tracking.</span></span>

<span data-ttu-id="a51a5-557">При запросе с помощью экземпляров ObjectContext, Object'ryи и ObjectSet будут запоминать MergeOption после его установки, а запросы, которые состоятся на них, унаследуют эффективный MergeOption родительского запроса.</span><span class="sxs-lookup"><span data-stu-id="a51a5-557">When querying using ObjectContext, ObjectQuery and ObjectSet instances will remember a MergeOption once it is set, and queries that are composed on them will inherit the effective MergeOption of the parent query.</span></span> <span data-ttu-id="a51a5-558">При использовании DbContext отслеживание может быть отключено, позвонив в модификатор AsNoTracking () на DbSet.</span><span class="sxs-lookup"><span data-stu-id="a51a5-558">When using DbContext, tracking can be disabled by calling the AsNoTracking() modifier on the DbSet.</span></span>

#### <a name="511-disabling-change-tracking-for-a-query-when-using-dbcontext"></a><span data-ttu-id="a51a5-559">5.1.1 Отключение отслеживания изменений для запроса при использовании DbContext</span><span class="sxs-lookup"><span data-stu-id="a51a5-559">5.1.1 Disabling change tracking for a query when using DbContext</span></span>

<span data-ttu-id="a51a5-560">Режим запроса можно переключить на NoTracking, приковав вызов к методу AsNoTracking() в запросе.</span><span class="sxs-lookup"><span data-stu-id="a51a5-560">You can switch the mode of a query to NoTracking by chaining a call to the AsNoTracking() method in the query.</span></span> <span data-ttu-id="a51a5-561">В отличие от Object''s, классы DbSet и Db''query в API DbContext не имеют изменяемого свойства для MergeOption.</span><span class="sxs-lookup"><span data-stu-id="a51a5-561">Unlike ObjectQuery, the DbSet and DbQuery classes in the DbContext API don’t have a mutable property for the MergeOption.</span></span>

``` csharp
    var productsForCategory = from p in context.Products.AsNoTracking()
                                where p.Category.CategoryName == selectedCategory
                                select p;


```

#### <a name="512-disabling-change-tracking-at-the-query-level-using-objectcontext"></a><span data-ttu-id="a51a5-562">5.1.2 Отключение отслеживания изменений на уровне запроса с помощью ObjectContext</span><span class="sxs-lookup"><span data-stu-id="a51a5-562">5.1.2 Disabling change tracking at the query level using ObjectContext</span></span>

``` csharp
    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;

    ((ObjectQuery)productsForCategory).MergeOption = MergeOption.NoTracking;
```

#### <a name="513-disabling-change-tracking-for-an-entire-entity-set-using-objectcontext"></a><span data-ttu-id="a51a5-563">5.1.3 Отключение отслеживания изменений для всего набора сущности с помощью ObjectContext</span><span class="sxs-lookup"><span data-stu-id="a51a5-563">5.1.3 Disabling change tracking for an entire entity set using ObjectContext</span></span>

``` csharp
    context.Products.MergeOption = MergeOption.NoTracking;

    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;
```

### <a name="52test-metrics-demonstrating-the-performance-benefit-of-notracking-queries"></a><span data-ttu-id="a51a5-564">5.2 Метрики тестирования, демонстрирующие преимущества производительность запросов NoTracking</span><span class="sxs-lookup"><span data-stu-id="a51a5-564">5.2 Test Metrics demonstrating the performance benefit of NoTracking queries</span></span>

<span data-ttu-id="a51a5-565">В этом тесте мы рассмотрим стоимость заполнения ObjectStateManager, сравнивая запросы Отслеживания с Запросами NoTracking для модели Navision.</span><span class="sxs-lookup"><span data-stu-id="a51a5-565">In this test we look at the cost of filling the ObjectStateManager by comparing Tracking to NoTracking queries for the Navision model.</span></span> <span data-ttu-id="a51a5-566">Ознакомьтесь с приложением для описания модели Navision и типов запросов, которые были выполнены.</span><span class="sxs-lookup"><span data-stu-id="a51a5-566">See the appendix for a description of the Navision model and the types of queries which were executed.</span></span> <span data-ttu-id="a51a5-567">В этом тесте мы итерируем список запросов и выполняем каждый из них один раз.</span><span class="sxs-lookup"><span data-stu-id="a51a5-567">In this test, we iterate through the list of queries and execute each one once.</span></span> <span data-ttu-id="a51a5-568">Мы запустили два варианта теста, один раз с запросами NoTracking и один раз с опцией слияния по умолчанию "AppendOnly".</span><span class="sxs-lookup"><span data-stu-id="a51a5-568">We ran two variations of the test, once with NoTracking queries and once with the default merge option of "AppendOnly".</span></span> <span data-ttu-id="a51a5-569">Мы побежали каждый вариант 3 раза и принять среднее значение работает.</span><span class="sxs-lookup"><span data-stu-id="a51a5-569">We ran each variation 3 times and take the mean value of the runs.</span></span> <span data-ttu-id="a51a5-570">Между тестами мы очищаем кэш запроса на сервере S'L и сокращаем темп, запустив следующие команды:</span><span class="sxs-lookup"><span data-stu-id="a51a5-570">Between the tests we clear the query cache on the SQL Server and shrink the tempdb by running the following commands:</span></span>

1.  <span data-ttu-id="a51a5-571">DBCC DROPCLEANBUFFERS</span><span class="sxs-lookup"><span data-stu-id="a51a5-571">DBCC DROPCLEANBUFFERS</span></span>
2.  <span data-ttu-id="a51a5-572">DBCC FREEPROCCACHE</span><span class="sxs-lookup"><span data-stu-id="a51a5-572">DBCC FREEPROCCACHE</span></span>
3.  <span data-ttu-id="a51a5-573">DBCC SHRINKDATABASE (темп, 0)</span><span class="sxs-lookup"><span data-stu-id="a51a5-573">DBCC SHRINKDATABASE (tempdb, 0)</span></span>

<span data-ttu-id="a51a5-574">Результаты тестирования, медиана в течение 3 трасс:</span><span class="sxs-lookup"><span data-stu-id="a51a5-574">Test Results, median over 3 runs:</span></span>

|                        | <span data-ttu-id="a51a5-575">НЕТ ОТСЛЕЖИВАНИЯ - РАБОЧИЙ НАБОР</span><span class="sxs-lookup"><span data-stu-id="a51a5-575">NO TRACKING – WORKING SET</span></span> | <span data-ttu-id="a51a5-576">НЕТ ОТСЛЕЖИВАНИЯ - ВРЕМЯ</span><span class="sxs-lookup"><span data-stu-id="a51a5-576">NO TRACKING – TIME</span></span> | <span data-ttu-id="a51a5-577">ТОЛЬКО ПРИДАТКА - РАБОЧИЙ НАБОР</span><span class="sxs-lookup"><span data-stu-id="a51a5-577">APPEND ONLY – WORKING SET</span></span> | <span data-ttu-id="a51a5-578">ПРИЛОЖЕНИЕ ТОЛЬКО - ВРЕМЯ</span><span class="sxs-lookup"><span data-stu-id="a51a5-578">APPEND ONLY – TIME</span></span> |
|:-----------------------|:--------------------------|:-------------------|:--------------------------|:-------------------|
| <span data-ttu-id="a51a5-579">**Рамки сущности 5**</span><span class="sxs-lookup"><span data-stu-id="a51a5-579">**Entity Framework 5**</span></span> | <span data-ttu-id="a51a5-580">460361728</span><span class="sxs-lookup"><span data-stu-id="a51a5-580">460361728</span></span>                 | <span data-ttu-id="a51a5-581">1163536 мс</span><span class="sxs-lookup"><span data-stu-id="a51a5-581">1163536 ms</span></span>         | <span data-ttu-id="a51a5-582">596545536</span><span class="sxs-lookup"><span data-stu-id="a51a5-582">596545536</span></span>                 | <span data-ttu-id="a51a5-583">1273042 мс</span><span class="sxs-lookup"><span data-stu-id="a51a5-583">1273042 ms</span></span>         |
| <span data-ttu-id="a51a5-584">**Entity Framework 6**</span><span class="sxs-lookup"><span data-stu-id="a51a5-584">**Entity Framework 6**</span></span> | <span data-ttu-id="a51a5-585">647127040</span><span class="sxs-lookup"><span data-stu-id="a51a5-585">647127040</span></span>                 | <span data-ttu-id="a51a5-586">190228 мс</span><span class="sxs-lookup"><span data-stu-id="a51a5-586">190228 ms</span></span>          | <span data-ttu-id="a51a5-587">832798720</span><span class="sxs-lookup"><span data-stu-id="a51a5-587">832798720</span></span>                 | <span data-ttu-id="a51a5-588">195521 мс</span><span class="sxs-lookup"><span data-stu-id="a51a5-588">195521 ms</span></span>          |

<span data-ttu-id="a51a5-589">Система сущности 5 будет иметь меньший объем памяти в конце выполнения, чем Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="a51a5-589">Entity Framework 5 will have a smaller memory footprint at the end of the run than Entity Framework 6 does.</span></span> <span data-ttu-id="a51a5-590">Дополнительная память, потребляемая Entity Framework 6, является результатом дополнительных структур памяти и кода, которые позволяют новым функциям и повышению производительности.</span><span class="sxs-lookup"><span data-stu-id="a51a5-590">The additional memory consumed by Entity Framework 6 is the result of additional memory structures and code that enable new features and better performance.</span></span>

<span data-ttu-id="a51a5-591">Кроме того, при использовании ObjectStateManager существует явная разница в памяти.</span><span class="sxs-lookup"><span data-stu-id="a51a5-591">There’s also a clear difference in memory footprint when using the ObjectStateManager.</span></span> <span data-ttu-id="a51a5-592">Entity Framework 5 увеличила свой след на 30% при отслеживании всех сущностей, которые мы материализовали из базы данных.</span><span class="sxs-lookup"><span data-stu-id="a51a5-592">Entity Framework 5 increased its footprint by 30% when keeping track of all the entities we materialized from the database.</span></span> <span data-ttu-id="a51a5-593">Система Entity 6 увеличила свой след на 28% при этом.</span><span class="sxs-lookup"><span data-stu-id="a51a5-593">Entity Framework 6 increased its footprint by 28% when doing so.</span></span>

<span data-ttu-id="a51a5-594">С точки зрения времени, Entity Framework 6 опережает Entity Framework 5 в этом тесте с большим отрывом.</span><span class="sxs-lookup"><span data-stu-id="a51a5-594">In terms of time, Entity Framework 6 outperforms Entity Framework 5 in this test by a large margin.</span></span> <span data-ttu-id="a51a5-595">Система сущности 6 завершила тест примерно в 16% времени, заработавам в рамках Entity Framework 5.</span><span class="sxs-lookup"><span data-stu-id="a51a5-595">Entity Framework 6 completed the test in roughly 16% of the time consumed by Entity Framework 5.</span></span> <span data-ttu-id="a51a5-596">Кроме того, при использовании ObjectStateManager на 9% больше времени уходит на 9% больше времени.</span><span class="sxs-lookup"><span data-stu-id="a51a5-596">Additionally, Entity Framework 5 takes 9% more time to complete when the ObjectStateManager is being used.</span></span> <span data-ttu-id="a51a5-597">Для сравнения, Entity Framework 6 использует на 3% больше времени при использовании ObjectStateManager.</span><span class="sxs-lookup"><span data-stu-id="a51a5-597">In comparison, Entity Framework 6 is using 3% more time when using the ObjectStateManager.</span></span>

## <a name="6-query-execution-options"></a><span data-ttu-id="a51a5-598">6 Параметры выполнения запросов</span><span class="sxs-lookup"><span data-stu-id="a51a5-598">6 Query Execution Options</span></span>

<span data-ttu-id="a51a5-599">Система сущности предлагает несколько различных способов запроса.</span><span class="sxs-lookup"><span data-stu-id="a51a5-599">Entity Framework offers several different ways to query.</span></span> <span data-ttu-id="a51a5-600">Мы рассмотрим следующие варианты, сравним плюсы и минусы каждого из них и рассмотрим их характеристики производительности:</span><span class="sxs-lookup"><span data-stu-id="a51a5-600">We'll take a look at the following options, compare the pros and cons of each, and examine their performance characteristics:</span></span>

-   <span data-ttu-id="a51a5-601">ЛИНЗ для организаций.</span><span class="sxs-lookup"><span data-stu-id="a51a5-601">LINQ to Entities.</span></span>
-   <span data-ttu-id="a51a5-602">Нет отслеживания LIN' для организаций.</span><span class="sxs-lookup"><span data-stu-id="a51a5-602">No Tracking LINQ to Entities.</span></span>
-   <span data-ttu-id="a51a5-603">Сущность СЗЛ над объектом.</span><span class="sxs-lookup"><span data-stu-id="a51a5-603">Entity SQL over an ObjectQuery.</span></span>
-   <span data-ttu-id="a51a5-604">Сущность S'L над EntityCommand.</span><span class="sxs-lookup"><span data-stu-id="a51a5-604">Entity SQL over an EntityCommand.</span></span>
-   <span data-ttu-id="a51a5-605">ExecuteStore's.</span><span class="sxs-lookup"><span data-stu-id="a51a5-605">ExecuteStoreQuery.</span></span>
-   <span data-ttu-id="a51a5-606">Кзл-Кусери.</span><span class="sxs-lookup"><span data-stu-id="a51a5-606">SqlQuery.</span></span>
-   <span data-ttu-id="a51a5-607">СоставителиКери.</span><span class="sxs-lookup"><span data-stu-id="a51a5-607">CompiledQuery.</span></span>

### <a name="61-linq-to-entities-queries"></a><span data-ttu-id="a51a5-608">6.1 Запросы на запросы для организаций</span><span class="sxs-lookup"><span data-stu-id="a51a5-608">6.1       LINQ to Entities queries</span></span>

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="a51a5-609">**Плюсы**</span><span class="sxs-lookup"><span data-stu-id="a51a5-609">**Pros**</span></span>

-   <span data-ttu-id="a51a5-610">Подходит для операций CUD.</span><span class="sxs-lookup"><span data-stu-id="a51a5-610">Suitable for CUD operations.</span></span>
-   <span data-ttu-id="a51a5-611">Полностью материализованные объекты.</span><span class="sxs-lookup"><span data-stu-id="a51a5-611">Fully materialized objects.</span></span>
-   <span data-ttu-id="a51a5-612">Проще всего писать с помощью синтаксиса, встроенного в язык программирования.</span><span class="sxs-lookup"><span data-stu-id="a51a5-612">Simplest to write with syntax built into the programming language.</span></span>
-   <span data-ttu-id="a51a5-613">Хорошая производительность.</span><span class="sxs-lookup"><span data-stu-id="a51a5-613">Good performance.</span></span>

<span data-ttu-id="a51a5-614">**Минусы**</span><span class="sxs-lookup"><span data-stu-id="a51a5-614">**Cons**</span></span>

-   <span data-ttu-id="a51a5-615">Некоторые технические ограничения, такие как:</span><span class="sxs-lookup"><span data-stu-id="a51a5-615">Certain technical restrictions, such as:</span></span>
    -   <span data-ttu-id="a51a5-616">Шаблоны, использующие по умолчаниюДля-запросы OUTER JOIN, приводят к более сложным запросам, чем простые операторы OUTER JOIN в Entity S'L.</span><span class="sxs-lookup"><span data-stu-id="a51a5-616">Patterns using DefaultIfEmpty for OUTER JOIN queries result in more complex queries than simple OUTER JOIN statements in Entity SQL.</span></span>
    -   <span data-ttu-id="a51a5-617">Вы все еще не можете использовать LIKE с общим соответствием шаблона.</span><span class="sxs-lookup"><span data-stu-id="a51a5-617">You still can’t use LIKE with general pattern matching.</span></span>

### <a name="62-no-tracking-linq-to-entities-queries"></a><span data-ttu-id="a51a5-618">6.2 Нет отслеживания запросов НАИНо-ЕЗ к объектам</span><span class="sxs-lookup"><span data-stu-id="a51a5-618">6.2       No Tracking LINQ to Entities queries</span></span>

<span data-ttu-id="a51a5-619">Когда контекст выводит ObjectContext:</span><span class="sxs-lookup"><span data-stu-id="a51a5-619">When the context derives ObjectContext:</span></span>

``` csharp
context.Products.MergeOption = MergeOption.NoTracking;
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="a51a5-620">Когда контекст выводит DbContext:</span><span class="sxs-lookup"><span data-stu-id="a51a5-620">When the context derives DbContext:</span></span>

``` csharp
var q = context.Products.AsNoTracking()
                        .Where(p => p.Category.CategoryName == "Beverages");
```

<span data-ttu-id="a51a5-621">**Плюсы**</span><span class="sxs-lookup"><span data-stu-id="a51a5-621">**Pros**</span></span>

-   <span data-ttu-id="a51a5-622">Улучшенная производительность по сравнению с обычными запросами НАИР.</span><span class="sxs-lookup"><span data-stu-id="a51a5-622">Improved performance over regular LINQ queries.</span></span>
-   <span data-ttu-id="a51a5-623">Полностью материализованные объекты.</span><span class="sxs-lookup"><span data-stu-id="a51a5-623">Fully materialized objects.</span></span>
-   <span data-ttu-id="a51a5-624">Проще всего писать с помощью синтаксиса, встроенного в язык программирования.</span><span class="sxs-lookup"><span data-stu-id="a51a5-624">Simplest to write with syntax built into the programming language.</span></span>

<span data-ttu-id="a51a5-625">**Минусы**</span><span class="sxs-lookup"><span data-stu-id="a51a5-625">**Cons**</span></span>

-   <span data-ttu-id="a51a5-626">Не подходит для операций CUD.</span><span class="sxs-lookup"><span data-stu-id="a51a5-626">Not suitable for CUD operations.</span></span>
-   <span data-ttu-id="a51a5-627">Некоторые технические ограничения, такие как:</span><span class="sxs-lookup"><span data-stu-id="a51a5-627">Certain technical restrictions, such as:</span></span>
    -   <span data-ttu-id="a51a5-628">Шаблоны, использующие по умолчаниюДля-запросы OUTER JOIN, приводят к более сложным запросам, чем простые операторы OUTER JOIN в Entity S'L.</span><span class="sxs-lookup"><span data-stu-id="a51a5-628">Patterns using DefaultIfEmpty for OUTER JOIN queries result in more complex queries than simple OUTER JOIN statements in Entity SQL.</span></span>
    -   <span data-ttu-id="a51a5-629">Вы все еще не можете использовать LIKE с общим соответствием шаблона.</span><span class="sxs-lookup"><span data-stu-id="a51a5-629">You still can’t use LIKE with general pattern matching.</span></span>

<span data-ttu-id="a51a5-630">Обратите внимание, что запросы, которые проектные свойства масштабирования не отслеживаются, даже если Нотрекинг не указан.</span><span class="sxs-lookup"><span data-stu-id="a51a5-630">Note that queries that project scalar properties are not tracked even if the NoTracking is not specified.</span></span> <span data-ttu-id="a51a5-631">Пример:</span><span class="sxs-lookup"><span data-stu-id="a51a5-631">For example:</span></span>

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages").Select(p => new { p.ProductName });
```

<span data-ttu-id="a51a5-632">Данный запрос явно не указывается как NoTracking, но так как он не материализуется в типе, который известен диспетчеру состояния объекта, то материализованный результат не отслеживается.</span><span class="sxs-lookup"><span data-stu-id="a51a5-632">This particular query doesn’t explicitly specify being NoTracking, but since it’s not materializing a type that’s known to the object state manager then the materialized result is not tracked.</span></span>

### <a name="63-entity-sql-over-an-objectquery"></a><span data-ttu-id="a51a5-633">6.3 Сущность СЗЛ над объектом«Закери</span><span class="sxs-lookup"><span data-stu-id="a51a5-633">6.3       Entity SQL over an ObjectQuery</span></span>

``` csharp
ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
```

<span data-ttu-id="a51a5-634">**Плюсы**</span><span class="sxs-lookup"><span data-stu-id="a51a5-634">**Pros**</span></span>

-   <span data-ttu-id="a51a5-635">Подходит для операций CUD.</span><span class="sxs-lookup"><span data-stu-id="a51a5-635">Suitable for CUD operations.</span></span>
-   <span data-ttu-id="a51a5-636">Полностью материализованные объекты.</span><span class="sxs-lookup"><span data-stu-id="a51a5-636">Fully materialized objects.</span></span>
-   <span data-ttu-id="a51a5-637">Поддерживает кэширование плана запроса.</span><span class="sxs-lookup"><span data-stu-id="a51a5-637">Supports query plan caching.</span></span>

<span data-ttu-id="a51a5-638">**Минусы**</span><span class="sxs-lookup"><span data-stu-id="a51a5-638">**Cons**</span></span>

-   <span data-ttu-id="a51a5-639">Включает строки текстового запроса, которые более подвержены ошибке пользователя, чем конструкции запроса, встроенные в язык.</span><span class="sxs-lookup"><span data-stu-id="a51a5-639">Involves textual query strings which are more prone to user error than query constructs built into the language.</span></span>

### <a name="64-entity-sql-over-an-entity-command"></a><span data-ttu-id="a51a5-640">6.4 Сущность СЗЛ над Командованием Сущности</span><span class="sxs-lookup"><span data-stu-id="a51a5-640">6.4       Entity SQL over an Entity Command</span></span>

``` csharp
EntityCommand cmd = eConn.CreateCommand();
cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
{
    while (reader.Read())
    {
        // manually 'materialize' the product
    }
}
```

<span data-ttu-id="a51a5-641">**Плюсы**</span><span class="sxs-lookup"><span data-stu-id="a51a5-641">**Pros**</span></span>

-   <span data-ttu-id="a51a5-642">Поддержка кэширования запроса в .NET 4.0 (кэширование плана поддерживается всеми другими типами запросов в .NET 4.5).</span><span class="sxs-lookup"><span data-stu-id="a51a5-642">Supports query plan caching in .NET 4.0 (plan caching is supported by all other query types in .NET 4.5).</span></span>

<span data-ttu-id="a51a5-643">**Минусы**</span><span class="sxs-lookup"><span data-stu-id="a51a5-643">**Cons**</span></span>

-   <span data-ttu-id="a51a5-644">Включает строки текстового запроса, которые более подвержены ошибке пользователя, чем конструкции запроса, встроенные в язык.</span><span class="sxs-lookup"><span data-stu-id="a51a5-644">Involves textual query strings which are more prone to user error than query constructs built into the language.</span></span>
-   <span data-ttu-id="a51a5-645">Не подходит для операций CUD.</span><span class="sxs-lookup"><span data-stu-id="a51a5-645">Not suitable for CUD operations.</span></span>
-   <span data-ttu-id="a51a5-646">Результаты не материализуются автоматически и должны быть прочитаны с читна данных.</span><span class="sxs-lookup"><span data-stu-id="a51a5-646">Results are not automatically materialized, and must be read from the data reader.</span></span>

### <a name="65-sqlquery-and-executestorequery"></a><span data-ttu-id="a51a5-647">6.5 Sql-Куивери и ExecuteStore'ry</span><span class="sxs-lookup"><span data-stu-id="a51a5-647">6.5       SqlQuery and ExecuteStoreQuery</span></span>

<span data-ttu-id="a51a5-648">Sql-Кери по базе данных:</span><span class="sxs-lookup"><span data-stu-id="a51a5-648">SqlQuery on Database:</span></span>

``` csharp
// use this to obtain entities and not track them
var q1 = context.Database.SqlQuery<Product>("select * from products");
```

<span data-ttu-id="a51a5-649">Sql-Кери на DbSet:</span><span class="sxs-lookup"><span data-stu-id="a51a5-649">SqlQuery on DbSet:</span></span>

``` csharp
// use this to obtain entities and have them tracked
var q2 = context.Products.SqlQuery("select * from products");
```

<span data-ttu-id="a51a5-650">ExecyteStore'ry:</span><span class="sxs-lookup"><span data-stu-id="a51a5-650">ExecyteStoreQuery:</span></span>

``` csharp
var beverages = context.ExecuteStoreQuery<Product>(
@"     SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued, P.DiscontinuedDate
       FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
       WHERE        (C.CategoryName = 'Beverages')"
);
```

<span data-ttu-id="a51a5-651">**Плюсы**</span><span class="sxs-lookup"><span data-stu-id="a51a5-651">**Pros**</span></span>

-   <span data-ttu-id="a51a5-652">Как правило, самая быстрая производительность, так как компилятор плана обойдяется стороной.</span><span class="sxs-lookup"><span data-stu-id="a51a5-652">Generally fastest performance since plan compiler is bypassed.</span></span>
-   <span data-ttu-id="a51a5-653">Полностью материализованные объекты.</span><span class="sxs-lookup"><span data-stu-id="a51a5-653">Fully materialized objects.</span></span>
-   <span data-ttu-id="a51a5-654">Подходит для операций CUD при использовании из DbSet.</span><span class="sxs-lookup"><span data-stu-id="a51a5-654">Suitable for CUD operations when used from the DbSet.</span></span>

<span data-ttu-id="a51a5-655">**Минусы**</span><span class="sxs-lookup"><span data-stu-id="a51a5-655">**Cons**</span></span>

-   <span data-ttu-id="a51a5-656">Запрос является текстовым и подверженным ошибкам.</span><span class="sxs-lookup"><span data-stu-id="a51a5-656">Query is textual and error prone.</span></span>
-   <span data-ttu-id="a51a5-657">Запрос привязан к определенному бэкэнду с помощью семантики магазина вместо концептуальной семантики.</span><span class="sxs-lookup"><span data-stu-id="a51a5-657">Query is tied to a specific backend by using store semantics instead of conceptual semantics.</span></span>
-   <span data-ttu-id="a51a5-658">При наследовании запрос ручной работы должен учитывать условия отображения для запрашиваемого типа.</span><span class="sxs-lookup"><span data-stu-id="a51a5-658">When inheritance is present, handcrafted query needs to account for mapping conditions for the type requested.</span></span>

### <a name="66-compiledquery"></a><span data-ttu-id="a51a5-659">6.6 КомпилированныйКери</span><span class="sxs-lookup"><span data-stu-id="a51a5-659">6.6       CompiledQuery</span></span>

``` csharp
private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
    (NorthwindEntities context, string categoryName) =>
        context.Products.Where(p => p.Category.CategoryName == categoryName)
        );
…
var q = context.InvokeProductsForCategoryCQ("Beverages");
```

<span data-ttu-id="a51a5-660">**Плюсы**</span><span class="sxs-lookup"><span data-stu-id="a51a5-660">**Pros**</span></span>

-   <span data-ttu-id="a51a5-661">Обеспечивает повышение производительности до 7% по сравнению с обычными запросами НА ИНО.</span><span class="sxs-lookup"><span data-stu-id="a51a5-661">Provides up to a 7% performance improvement over regular LINQ queries.</span></span>
-   <span data-ttu-id="a51a5-662">Полностью материализованные объекты.</span><span class="sxs-lookup"><span data-stu-id="a51a5-662">Fully materialized objects.</span></span>
-   <span data-ttu-id="a51a5-663">Подходит для операций CUD.</span><span class="sxs-lookup"><span data-stu-id="a51a5-663">Suitable for CUD operations.</span></span>

<span data-ttu-id="a51a5-664">**Минусы**</span><span class="sxs-lookup"><span data-stu-id="a51a5-664">**Cons**</span></span>

-   <span data-ttu-id="a51a5-665">Повышенная сложность и накладные расходы на программирование.</span><span class="sxs-lookup"><span data-stu-id="a51a5-665">Increased complexity and programming overhead.</span></span>
-   <span data-ttu-id="a51a5-666">Улучшение производительности теряется при составлении поверх компилированного запроса.</span><span class="sxs-lookup"><span data-stu-id="a51a5-666">The performance improvement is lost when composing on top of a compiled query.</span></span>
-   <span data-ttu-id="a51a5-667">Некоторые запросы LIN's не могут быть записаны в виде компилированного кекери - например, прогнозы анонимных типов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-667">Some LINQ queries can't be written as a CompiledQuery - for example, projections of anonymous types.</span></span>

### <a name="67-performance-comparison-of-different-query-options"></a><span data-ttu-id="a51a5-668">6.7 Сравнение производительности различных параметров запроса</span><span class="sxs-lookup"><span data-stu-id="a51a5-668">6.7       Performance Comparison of different query options</span></span>

<span data-ttu-id="a51a5-669">Простые микробенчмарки, где создание контекста не было приурочено, были поставлены на испытания.</span><span class="sxs-lookup"><span data-stu-id="a51a5-669">Simple microbenchmarks where the context creation was not timed were put to the test.</span></span> <span data-ttu-id="a51a5-670">Мы измерили 5000 раз запросов для набора некэшированных сущностей в контролируемой среде.</span><span class="sxs-lookup"><span data-stu-id="a51a5-670">We measured querying 5000 times for a set of non-cached entities in a controlled environment.</span></span> <span data-ttu-id="a51a5-671">Эти цифры следует воспринимать с предупреждением: они не отражают фактические числа, производимые приложением, но вместо этого они являются очень точным измерением того, сколько разница в производительности есть, когда различные варианты запроса сравниваются яблоки к яблокам, исключая стоимость создания нового контекста.</span><span class="sxs-lookup"><span data-stu-id="a51a5-671">These numbers are to be taken with a warning: they do not reflect actual numbers produced by an application, but instead they are a very accurate measurement of how much of a performance difference there is when different querying options are compared apples-to-apples, excluding the cost of creating a new context.</span></span>

| <span data-ttu-id="a51a5-672">EF</span><span class="sxs-lookup"><span data-stu-id="a51a5-672">EF</span></span>  | <span data-ttu-id="a51a5-673">Тест</span><span class="sxs-lookup"><span data-stu-id="a51a5-673">Test</span></span>                                 | <span data-ttu-id="a51a5-674">Время (ms)</span><span class="sxs-lookup"><span data-stu-id="a51a5-674">Time (ms)</span></span> | <span data-ttu-id="a51a5-675">Память</span><span class="sxs-lookup"><span data-stu-id="a51a5-675">Memory</span></span>   |
|:----|:-------------------------------------|:----------|:---------|
| <span data-ttu-id="a51a5-676">EF5</span><span class="sxs-lookup"><span data-stu-id="a51a5-676">EF5</span></span> | <span data-ttu-id="a51a5-677">ОбъектКонтекст ЭСЗЛ</span><span class="sxs-lookup"><span data-stu-id="a51a5-677">ObjectContext ESQL</span></span>                   | <span data-ttu-id="a51a5-678">2414</span><span class="sxs-lookup"><span data-stu-id="a51a5-678">2414</span></span>      | <span data-ttu-id="a51a5-679">38801408</span><span class="sxs-lookup"><span data-stu-id="a51a5-679">38801408</span></span> |
| <span data-ttu-id="a51a5-680">EF5</span><span class="sxs-lookup"><span data-stu-id="a51a5-680">EF5</span></span> | <span data-ttu-id="a51a5-681">Объективный контекст Линк Запрос</span><span class="sxs-lookup"><span data-stu-id="a51a5-681">ObjectContext Linq Query</span></span>             | <span data-ttu-id="a51a5-682">2692</span><span class="sxs-lookup"><span data-stu-id="a51a5-682">2692</span></span>      | <span data-ttu-id="a51a5-683">38277120</span><span class="sxs-lookup"><span data-stu-id="a51a5-683">38277120</span></span> |
| <span data-ttu-id="a51a5-684">EF5</span><span class="sxs-lookup"><span data-stu-id="a51a5-684">EF5</span></span> | <span data-ttu-id="a51a5-685">DbContext Линк Запрос Нет отслеживания</span><span class="sxs-lookup"><span data-stu-id="a51a5-685">DbContext Linq Query No Tracking</span></span>     | <span data-ttu-id="a51a5-686">2818</span><span class="sxs-lookup"><span data-stu-id="a51a5-686">2818</span></span>      | <span data-ttu-id="a51a5-687">41840640</span><span class="sxs-lookup"><span data-stu-id="a51a5-687">41840640</span></span> |
| <span data-ttu-id="a51a5-688">EF5</span><span class="sxs-lookup"><span data-stu-id="a51a5-688">EF5</span></span> | <span data-ttu-id="a51a5-689">DbContext Линк Запрос</span><span class="sxs-lookup"><span data-stu-id="a51a5-689">DbContext Linq Query</span></span>                 | <span data-ttu-id="a51a5-690">2930</span><span class="sxs-lookup"><span data-stu-id="a51a5-690">2930</span></span>      | <span data-ttu-id="a51a5-691">41771008</span><span class="sxs-lookup"><span data-stu-id="a51a5-691">41771008</span></span> |
| <span data-ttu-id="a51a5-692">EF5</span><span class="sxs-lookup"><span data-stu-id="a51a5-692">EF5</span></span> | <span data-ttu-id="a51a5-693">ObjectContext Linq Запрос Без отслеживания</span><span class="sxs-lookup"><span data-stu-id="a51a5-693">ObjectContext Linq Query No Tracking</span></span> | <span data-ttu-id="a51a5-694">3013</span><span class="sxs-lookup"><span data-stu-id="a51a5-694">3013</span></span>      | <span data-ttu-id="a51a5-695">38412288</span><span class="sxs-lookup"><span data-stu-id="a51a5-695">38412288</span></span> |
|     |                                      |           |          |
| <span data-ttu-id="a51a5-696">EF6</span><span class="sxs-lookup"><span data-stu-id="a51a5-696">EF6</span></span> | <span data-ttu-id="a51a5-697">ОбъектКонтекст ЭСЗЛ</span><span class="sxs-lookup"><span data-stu-id="a51a5-697">ObjectContext ESQL</span></span>                   | <span data-ttu-id="a51a5-698">2059</span><span class="sxs-lookup"><span data-stu-id="a51a5-698">2059</span></span>      | <span data-ttu-id="a51a5-699">46039040</span><span class="sxs-lookup"><span data-stu-id="a51a5-699">46039040</span></span> |
| <span data-ttu-id="a51a5-700">EF6</span><span class="sxs-lookup"><span data-stu-id="a51a5-700">EF6</span></span> | <span data-ttu-id="a51a5-701">Объективный контекст Линк Запрос</span><span class="sxs-lookup"><span data-stu-id="a51a5-701">ObjectContext Linq Query</span></span>             | <span data-ttu-id="a51a5-702">3074</span><span class="sxs-lookup"><span data-stu-id="a51a5-702">3074</span></span>      | <span data-ttu-id="a51a5-703">45248512</span><span class="sxs-lookup"><span data-stu-id="a51a5-703">45248512</span></span> |
| <span data-ttu-id="a51a5-704">EF6</span><span class="sxs-lookup"><span data-stu-id="a51a5-704">EF6</span></span> | <span data-ttu-id="a51a5-705">DbContext Линк Запрос Нет отслеживания</span><span class="sxs-lookup"><span data-stu-id="a51a5-705">DbContext Linq Query No Tracking</span></span>     | <span data-ttu-id="a51a5-706">3125</span><span class="sxs-lookup"><span data-stu-id="a51a5-706">3125</span></span>      | <span data-ttu-id="a51a5-707">47575040</span><span class="sxs-lookup"><span data-stu-id="a51a5-707">47575040</span></span> |
| <span data-ttu-id="a51a5-708">EF6</span><span class="sxs-lookup"><span data-stu-id="a51a5-708">EF6</span></span> | <span data-ttu-id="a51a5-709">DbContext Линк Запрос</span><span class="sxs-lookup"><span data-stu-id="a51a5-709">DbContext Linq Query</span></span>                 | <span data-ttu-id="a51a5-710">3420</span><span class="sxs-lookup"><span data-stu-id="a51a5-710">3420</span></span>      | <span data-ttu-id="a51a5-711">47652864</span><span class="sxs-lookup"><span data-stu-id="a51a5-711">47652864</span></span> |
| <span data-ttu-id="a51a5-712">EF6</span><span class="sxs-lookup"><span data-stu-id="a51a5-712">EF6</span></span> | <span data-ttu-id="a51a5-713">ObjectContext Linq Запрос Без отслеживания</span><span class="sxs-lookup"><span data-stu-id="a51a5-713">ObjectContext Linq Query No Tracking</span></span> | <span data-ttu-id="a51a5-714">3593</span><span class="sxs-lookup"><span data-stu-id="a51a5-714">3593</span></span>      | <span data-ttu-id="a51a5-715">45260800</span><span class="sxs-lookup"><span data-stu-id="a51a5-715">45260800</span></span> |

![МИКРО-бенчмарки EF5, 5000 теплых итераций](~/ef6/media/ef5micro5000warm.png)

![Микро-бенчмарки EF6, 5000 теплых итераций](~/ef6/media/ef6micro5000warm.png)

<span data-ttu-id="a51a5-718">Микробенчмарки очень чувствительны к небольшим изменениям в коде.</span><span class="sxs-lookup"><span data-stu-id="a51a5-718">Microbenchmarks are very sensitive to small changes in the code.</span></span> <span data-ttu-id="a51a5-719">В этом случае разница между затратами на рамки 5 и Рамки Сущности 6 обусловлена добавлением [улучшений перехвата](~/ef6/fundamentals/logging-and-interception.md) и [транзакций.](~/ef6/saving/transactions.md)</span><span class="sxs-lookup"><span data-stu-id="a51a5-719">In this case, the difference between the costs of Entity Framework 5 and Entity Framework 6 are due to the addition of [interception](~/ef6/fundamentals/logging-and-interception.md) and [transactional improvements](~/ef6/saving/transactions.md).</span></span> <span data-ttu-id="a51a5-720">Эти микробенчмарки номера, однако, являются усиленное видение в очень небольшой фрагмент того, что Entity Framework делает.</span><span class="sxs-lookup"><span data-stu-id="a51a5-720">These microbenchmarks numbers, however, are an amplified vision into a very small fragment of what Entity Framework does.</span></span> <span data-ttu-id="a51a5-721">Реальные сценарии теплых запросов не должны видеть регрессию производительности при обновлении с рамки сущности 5 в рамку сущности 6.</span><span class="sxs-lookup"><span data-stu-id="a51a5-721">Real-world scenarios of warm queries should not see a performance regression when upgrading from Entity Framework 5 to Entity Framework 6.</span></span>

<span data-ttu-id="a51a5-722">Для сравнения реальной производительности различных вариантов запросов мы создали 5 отдельных вариантов тестирования, где мы используем другой вариант запроса, чтобы выбрать все продукты, название категории которых "Beverages".</span><span class="sxs-lookup"><span data-stu-id="a51a5-722">To compare the real-world performance of the different query options, we created 5 separate test variations where we use a different query option to select all products whose category name is "Beverages".</span></span> <span data-ttu-id="a51a5-723">Каждая итерация включает в себя затраты на создание контекста и затраты на материализацию всех возвращенных сущностей.</span><span class="sxs-lookup"><span data-stu-id="a51a5-723">Each iteration includes the cost of creating the context, and the cost of materializing all returned entities.</span></span> <span data-ttu-id="a51a5-724">10 итераций запускаются без умопомрачения, прежде чем взять сумму в 1000 приуроченных итераций.</span><span class="sxs-lookup"><span data-stu-id="a51a5-724">10 iterations are run untimed before taking the sum of 1000 timed iterations.</span></span> <span data-ttu-id="a51a5-725">Показанные результаты - это средний пробег, взятый из 5 запусков каждого теста.</span><span class="sxs-lookup"><span data-stu-id="a51a5-725">The results shown are the median run taken from 5 runs of each test.</span></span> <span data-ttu-id="a51a5-726">Для получения дополнительной информации смотрите приложение B, которое включает код для теста.</span><span class="sxs-lookup"><span data-stu-id="a51a5-726">For more information, see Appendix B which includes the code for the test.</span></span>

| <span data-ttu-id="a51a5-727">EF</span><span class="sxs-lookup"><span data-stu-id="a51a5-727">EF</span></span>  | <span data-ttu-id="a51a5-728">Тест</span><span class="sxs-lookup"><span data-stu-id="a51a5-728">Test</span></span>                                        | <span data-ttu-id="a51a5-729">Время (ms)</span><span class="sxs-lookup"><span data-stu-id="a51a5-729">Time (ms)</span></span> | <span data-ttu-id="a51a5-730">Память</span><span class="sxs-lookup"><span data-stu-id="a51a5-730">Memory</span></span>   |
|:----|:--------------------------------------------|:----------|:---------|
| <span data-ttu-id="a51a5-731">EF5</span><span class="sxs-lookup"><span data-stu-id="a51a5-731">EF5</span></span> | <span data-ttu-id="a51a5-732">Командование сущности ObjectContext</span><span class="sxs-lookup"><span data-stu-id="a51a5-732">ObjectContext Entity Command</span></span>                | <span data-ttu-id="a51a5-733">621</span><span class="sxs-lookup"><span data-stu-id="a51a5-733">621</span></span>       | <span data-ttu-id="a51a5-734">39350272</span><span class="sxs-lookup"><span data-stu-id="a51a5-734">39350272</span></span> |
| <span data-ttu-id="a51a5-735">EF5</span><span class="sxs-lookup"><span data-stu-id="a51a5-735">EF5</span></span> | <span data-ttu-id="a51a5-736">DbContext Sql Запрос на базе данных</span><span class="sxs-lookup"><span data-stu-id="a51a5-736">DbContext Sql Query on Database</span></span>             | <span data-ttu-id="a51a5-737">825</span><span class="sxs-lookup"><span data-stu-id="a51a5-737">825</span></span>       | <span data-ttu-id="a51a5-738">37519360</span><span class="sxs-lookup"><span data-stu-id="a51a5-738">37519360</span></span> |
| <span data-ttu-id="a51a5-739">EF5</span><span class="sxs-lookup"><span data-stu-id="a51a5-739">EF5</span></span> | <span data-ttu-id="a51a5-740">Запрос магазина ObjectContext</span><span class="sxs-lookup"><span data-stu-id="a51a5-740">ObjectContext Store Query</span></span>                   | <span data-ttu-id="a51a5-741">878</span><span class="sxs-lookup"><span data-stu-id="a51a5-741">878</span></span>       | <span data-ttu-id="a51a5-742">39460864</span><span class="sxs-lookup"><span data-stu-id="a51a5-742">39460864</span></span> |
| <span data-ttu-id="a51a5-743">EF5</span><span class="sxs-lookup"><span data-stu-id="a51a5-743">EF5</span></span> | <span data-ttu-id="a51a5-744">ObjectContext Linq Запрос Без отслеживания</span><span class="sxs-lookup"><span data-stu-id="a51a5-744">ObjectContext Linq Query No Tracking</span></span>        | <span data-ttu-id="a51a5-745">969</span><span class="sxs-lookup"><span data-stu-id="a51a5-745">969</span></span>       | <span data-ttu-id="a51a5-746">38293504</span><span class="sxs-lookup"><span data-stu-id="a51a5-746">38293504</span></span> |
| <span data-ttu-id="a51a5-747">EF5</span><span class="sxs-lookup"><span data-stu-id="a51a5-747">EF5</span></span> | <span data-ttu-id="a51a5-748">ОбъектКонтекст Entity Sql с помощью объективного запроса</span><span class="sxs-lookup"><span data-stu-id="a51a5-748">ObjectContext Entity Sql using Object Query</span></span> | <span data-ttu-id="a51a5-749">1089</span><span class="sxs-lookup"><span data-stu-id="a51a5-749">1089</span></span>      | <span data-ttu-id="a51a5-750">38981632</span><span class="sxs-lookup"><span data-stu-id="a51a5-750">38981632</span></span> |
| <span data-ttu-id="a51a5-751">EF5</span><span class="sxs-lookup"><span data-stu-id="a51a5-751">EF5</span></span> | <span data-ttu-id="a51a5-752">Компилированный запрос ObjectContext</span><span class="sxs-lookup"><span data-stu-id="a51a5-752">ObjectContext Compiled Query</span></span>                | <span data-ttu-id="a51a5-753">1099</span><span class="sxs-lookup"><span data-stu-id="a51a5-753">1099</span></span>      | <span data-ttu-id="a51a5-754">38682624</span><span class="sxs-lookup"><span data-stu-id="a51a5-754">38682624</span></span> |
| <span data-ttu-id="a51a5-755">EF5</span><span class="sxs-lookup"><span data-stu-id="a51a5-755">EF5</span></span> | <span data-ttu-id="a51a5-756">Объективный контекст Линк Запрос</span><span class="sxs-lookup"><span data-stu-id="a51a5-756">ObjectContext Linq Query</span></span>                    | <span data-ttu-id="a51a5-757">1152</span><span class="sxs-lookup"><span data-stu-id="a51a5-757">1152</span></span>      | <span data-ttu-id="a51a5-758">38178816</span><span class="sxs-lookup"><span data-stu-id="a51a5-758">38178816</span></span> |
| <span data-ttu-id="a51a5-759">EF5</span><span class="sxs-lookup"><span data-stu-id="a51a5-759">EF5</span></span> | <span data-ttu-id="a51a5-760">DbContext Линк Запрос Нет отслеживания</span><span class="sxs-lookup"><span data-stu-id="a51a5-760">DbContext Linq Query No Tracking</span></span>            | <span data-ttu-id="a51a5-761">1208</span><span class="sxs-lookup"><span data-stu-id="a51a5-761">1208</span></span>      | <span data-ttu-id="a51a5-762">41803776</span><span class="sxs-lookup"><span data-stu-id="a51a5-762">41803776</span></span> |
| <span data-ttu-id="a51a5-763">EF5</span><span class="sxs-lookup"><span data-stu-id="a51a5-763">EF5</span></span> | <span data-ttu-id="a51a5-764">DbContext Sql Запрос на DbSet</span><span class="sxs-lookup"><span data-stu-id="a51a5-764">DbContext Sql Query on DbSet</span></span>                | <span data-ttu-id="a51a5-765">1414</span><span class="sxs-lookup"><span data-stu-id="a51a5-765">1414</span></span>      | <span data-ttu-id="a51a5-766">37982208</span><span class="sxs-lookup"><span data-stu-id="a51a5-766">37982208</span></span> |
| <span data-ttu-id="a51a5-767">EF5</span><span class="sxs-lookup"><span data-stu-id="a51a5-767">EF5</span></span> | <span data-ttu-id="a51a5-768">DbContext Линк Запрос</span><span class="sxs-lookup"><span data-stu-id="a51a5-768">DbContext Linq Query</span></span>                        | <span data-ttu-id="a51a5-769">1574</span><span class="sxs-lookup"><span data-stu-id="a51a5-769">1574</span></span>      | <span data-ttu-id="a51a5-770">41738240</span><span class="sxs-lookup"><span data-stu-id="a51a5-770">41738240</span></span> |
|     |                                             |           |          |
| <span data-ttu-id="a51a5-771">EF6</span><span class="sxs-lookup"><span data-stu-id="a51a5-771">EF6</span></span> | <span data-ttu-id="a51a5-772">Командование сущности ObjectContext</span><span class="sxs-lookup"><span data-stu-id="a51a5-772">ObjectContext Entity Command</span></span>                | <span data-ttu-id="a51a5-773">480</span><span class="sxs-lookup"><span data-stu-id="a51a5-773">480</span></span>       | <span data-ttu-id="a51a5-774">47247360</span><span class="sxs-lookup"><span data-stu-id="a51a5-774">47247360</span></span> |
| <span data-ttu-id="a51a5-775">EF6</span><span class="sxs-lookup"><span data-stu-id="a51a5-775">EF6</span></span> | <span data-ttu-id="a51a5-776">Запрос магазина ObjectContext</span><span class="sxs-lookup"><span data-stu-id="a51a5-776">ObjectContext Store Query</span></span>                   | <span data-ttu-id="a51a5-777">493</span><span class="sxs-lookup"><span data-stu-id="a51a5-777">493</span></span>       | <span data-ttu-id="a51a5-778">46739456</span><span class="sxs-lookup"><span data-stu-id="a51a5-778">46739456</span></span> |
| <span data-ttu-id="a51a5-779">EF6</span><span class="sxs-lookup"><span data-stu-id="a51a5-779">EF6</span></span> | <span data-ttu-id="a51a5-780">DbContext Sql Запрос на базе данных</span><span class="sxs-lookup"><span data-stu-id="a51a5-780">DbContext Sql Query on Database</span></span>             | <span data-ttu-id="a51a5-781">614</span><span class="sxs-lookup"><span data-stu-id="a51a5-781">614</span></span>       | <span data-ttu-id="a51a5-782">41607168</span><span class="sxs-lookup"><span data-stu-id="a51a5-782">41607168</span></span> |
| <span data-ttu-id="a51a5-783">EF6</span><span class="sxs-lookup"><span data-stu-id="a51a5-783">EF6</span></span> | <span data-ttu-id="a51a5-784">ObjectContext Linq Запрос Без отслеживания</span><span class="sxs-lookup"><span data-stu-id="a51a5-784">ObjectContext Linq Query No Tracking</span></span>        | <span data-ttu-id="a51a5-785">684</span><span class="sxs-lookup"><span data-stu-id="a51a5-785">684</span></span>       | <span data-ttu-id="a51a5-786">46333952</span><span class="sxs-lookup"><span data-stu-id="a51a5-786">46333952</span></span> |
| <span data-ttu-id="a51a5-787">EF6</span><span class="sxs-lookup"><span data-stu-id="a51a5-787">EF6</span></span> | <span data-ttu-id="a51a5-788">ОбъектКонтекст Entity Sql с помощью объективного запроса</span><span class="sxs-lookup"><span data-stu-id="a51a5-788">ObjectContext Entity Sql using Object Query</span></span> | <span data-ttu-id="a51a5-789">767</span><span class="sxs-lookup"><span data-stu-id="a51a5-789">767</span></span>       | <span data-ttu-id="a51a5-790">48865280</span><span class="sxs-lookup"><span data-stu-id="a51a5-790">48865280</span></span> |
| <span data-ttu-id="a51a5-791">EF6</span><span class="sxs-lookup"><span data-stu-id="a51a5-791">EF6</span></span> | <span data-ttu-id="a51a5-792">Компилированный запрос ObjectContext</span><span class="sxs-lookup"><span data-stu-id="a51a5-792">ObjectContext Compiled Query</span></span>                | <span data-ttu-id="a51a5-793">788</span><span class="sxs-lookup"><span data-stu-id="a51a5-793">788</span></span>       | <span data-ttu-id="a51a5-794">48467968</span><span class="sxs-lookup"><span data-stu-id="a51a5-794">48467968</span></span> |
| <span data-ttu-id="a51a5-795">EF6</span><span class="sxs-lookup"><span data-stu-id="a51a5-795">EF6</span></span> | <span data-ttu-id="a51a5-796">DbContext Линк Запрос Нет отслеживания</span><span class="sxs-lookup"><span data-stu-id="a51a5-796">DbContext Linq Query No Tracking</span></span>            | <span data-ttu-id="a51a5-797">878</span><span class="sxs-lookup"><span data-stu-id="a51a5-797">878</span></span>       | <span data-ttu-id="a51a5-798">47554560</span><span class="sxs-lookup"><span data-stu-id="a51a5-798">47554560</span></span> |
| <span data-ttu-id="a51a5-799">EF6</span><span class="sxs-lookup"><span data-stu-id="a51a5-799">EF6</span></span> | <span data-ttu-id="a51a5-800">Объективный контекст Линк Запрос</span><span class="sxs-lookup"><span data-stu-id="a51a5-800">ObjectContext Linq Query</span></span>                    | <span data-ttu-id="a51a5-801">953</span><span class="sxs-lookup"><span data-stu-id="a51a5-801">953</span></span>       | <span data-ttu-id="a51a5-802">47632384</span><span class="sxs-lookup"><span data-stu-id="a51a5-802">47632384</span></span> |
| <span data-ttu-id="a51a5-803">EF6</span><span class="sxs-lookup"><span data-stu-id="a51a5-803">EF6</span></span> | <span data-ttu-id="a51a5-804">DbContext Sql Запрос на DbSet</span><span class="sxs-lookup"><span data-stu-id="a51a5-804">DbContext Sql Query on DbSet</span></span>                | <span data-ttu-id="a51a5-805">1023</span><span class="sxs-lookup"><span data-stu-id="a51a5-805">1023</span></span>      | <span data-ttu-id="a51a5-806">41992192</span><span class="sxs-lookup"><span data-stu-id="a51a5-806">41992192</span></span> |
| <span data-ttu-id="a51a5-807">EF6</span><span class="sxs-lookup"><span data-stu-id="a51a5-807">EF6</span></span> | <span data-ttu-id="a51a5-808">DbContext Линк Запрос</span><span class="sxs-lookup"><span data-stu-id="a51a5-808">DbContext Linq Query</span></span>                        | <span data-ttu-id="a51a5-809">1290</span><span class="sxs-lookup"><span data-stu-id="a51a5-809">1290</span></span>      | <span data-ttu-id="a51a5-810">47529984</span><span class="sxs-lookup"><span data-stu-id="a51a5-810">47529984</span></span> |


![EF5 теплый запрос 1000 итераций](~/ef6/media/ef5warmquery1000.png)

![EF6 теплый запрос 1000 итераций](~/ef6/media/ef6warmquery1000.png)

> [!NOTE]
> <span data-ttu-id="a51a5-813">Для полноты мы включили вариацию, в которой мы выполняем запрос Entity S'L на EntityCommand.</span><span class="sxs-lookup"><span data-stu-id="a51a5-813">For completeness, we included a variation where we execute an Entity SQL query on an EntityCommand.</span></span> <span data-ttu-id="a51a5-814">Однако, поскольку результаты не материализовались для таких запросов, сравнение не обязательно яблоки к яблокам.</span><span class="sxs-lookup"><span data-stu-id="a51a5-814">However, because results are not materialized for such queries, the comparison isn't necessarily apples-to-apples.</span></span> <span data-ttu-id="a51a5-815">Тест включает в себя близкое приближение к материализации, чтобы попытаться сделать сравнение более справедливым.</span><span class="sxs-lookup"><span data-stu-id="a51a5-815">The test includes a close approximation to materializing to try making the comparison fairer.</span></span>

<span data-ttu-id="a51a5-816">В этом сквозном случае, Entity Framework 6 превосходит Entity Framework 5 из-за улучшения производительности, сделанных на нескольких частях стека, включая гораздо более легкую инициализацию DbContext и более быстрый поиск MetadataCollection&lt;T.&gt;</span><span class="sxs-lookup"><span data-stu-id="a51a5-816">In this end-to-end case, Entity Framework 6 outperforms Entity Framework 5 due to performance improvements made on several parts of the stack, including a much lighter DbContext initialization and faster MetadataCollection&lt;T&gt; lookups.</span></span>

## <a name="7-design-time-performance-considerations"></a><span data-ttu-id="a51a5-817">7 Соображения производительности времени проектирования</span><span class="sxs-lookup"><span data-stu-id="a51a5-817">7 Design time performance considerations</span></span>

### <a name="71-inheritance-strategies"></a><span data-ttu-id="a51a5-818">7.1 Стратегии наследования</span><span class="sxs-lookup"><span data-stu-id="a51a5-818">7.1       Inheritance Strategies</span></span>

<span data-ttu-id="a51a5-819">Другим соображением производительности при использовании системы Entity — стратегия наследования, используемая вами.</span><span class="sxs-lookup"><span data-stu-id="a51a5-819">Another performance consideration when using Entity Framework is the inheritance strategy you use.</span></span> <span data-ttu-id="a51a5-820">Система Entity поддерживает 3 основных типа наследования и их комбинации:</span><span class="sxs-lookup"><span data-stu-id="a51a5-820">Entity Framework supports 3 basic types of inheritance and their combinations:</span></span>

-   <span data-ttu-id="a51a5-821">Таблица для Иерархии (TPH) - где каждое наследование устанавливает карты в таблицу с столбцом распознавания, чтобы указать, какой конкретный тип в иерархии представлен в строке.</span><span class="sxs-lookup"><span data-stu-id="a51a5-821">Table per Hierarchy (TPH) – where each inheritance set maps to a table with a discriminator column to indicate which particular type in the hierarchy is being represented in the row.</span></span>
-   <span data-ttu-id="a51a5-822">Таблица на тип (TPT) - где каждый тип имеет свою собственную таблицу в базе данных; таблицы детей определяют только столбцы, которые не содержат родительская таблица.</span><span class="sxs-lookup"><span data-stu-id="a51a5-822">Table per Type (TPT) – where each type has its own table in the database; the child tables only define the columns that the parent table doesn’t contain.</span></span>
-   <span data-ttu-id="a51a5-823">Таблица на класс (TPC) - где каждый тип имеет свою собственную полную таблицу в базе данных; таблицы детей определяют все их поля, включая те, которые определяются в типах родителей.</span><span class="sxs-lookup"><span data-stu-id="a51a5-823">Table per Class (TPC) – where each type has its own full table in the database; the child tables define all their fields, including those defined in parent types.</span></span>

<span data-ttu-id="a51a5-824">Если модель использует наследование TPT, сгенерированные запросы будут более сложными, чем запросы, генерируемые с другими стратегиями наследования, что может привести к более длительному времени выполнения в магазине.</span><span class="sxs-lookup"><span data-stu-id="a51a5-824">If your model uses TPT inheritance, the queries which are generated will be more complex than those that are generated with the other inheritance strategies, which may result on longer execution times on the store.</span></span><span data-ttu-id="a51a5-825">Как правило, для генерации запросов по модели TPT и материализации полученных объектов требуется больше времени.</span><span class="sxs-lookup"><span data-stu-id="a51a5-825">  It will generally take longer to generate queries over a TPT model, and to materialize the resulting objects.</span></span>

<span data-ttu-id="a51a5-826">Смотрите сообщение в блоге \< https://docs.microsoft.com/archive/blogs/adonet/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework>MSDN "Рассмотрение производительности при использовании TPT (таблица на тип) Наследования в рамках entity" MSDN: .</span><span class="sxs-lookup"><span data-stu-id="a51a5-826">See the "Performance Considerations when using TPT (Table per Type) Inheritance in the Entity Framework" MSDN blog post: \<https://docs.microsoft.com/archive/blogs/adonet/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework>.</span></span>

#### <a name="711-avoiding-tpt-in-model-first-or-code-first-applications"></a><span data-ttu-id="a51a5-827">7.1.1 Избегая TPT в приложениях Model First или Code First</span><span class="sxs-lookup"><span data-stu-id="a51a5-827">7.1.1       Avoiding TPT in Model First or Code First applications</span></span>

<span data-ttu-id="a51a5-828">При создании модели над существующей базой данных с схемой TPT не так много вариантов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-828">When you create a model over an existing database that has a TPT schema, you don't have many options.</span></span> <span data-ttu-id="a51a5-829">Но при создании приложения с использованием Model First или Code First следует избегать наследования TPT из-за проблем с производительностью.</span><span class="sxs-lookup"><span data-stu-id="a51a5-829">But when creating an application using Model First or Code First, you should avoid TPT inheritance for performance concerns.</span></span>

<span data-ttu-id="a51a5-830">Когда вы используете Model First в Entity Designer Wizard, вы получите TPT для любого наследования в вашей модели.</span><span class="sxs-lookup"><span data-stu-id="a51a5-830">When you use Model First in the Entity Designer Wizard, you will get TPT for any inheritance in your model.</span></span> <span data-ttu-id="a51a5-831">Если вы хотите перейти на стратегию наследования TPH с Model First, вы можете использовать \< http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/>)"Entity Designer Database Generation Power Pack" доступны в галерее Visual Studio ( .</span><span class="sxs-lookup"><span data-stu-id="a51a5-831">If you want to switch to a TPH inheritance strategy with Model First, you can use the "Entity Designer Database Generation Power Pack" available from the Visual Studio Gallery ( \<http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/>).</span></span>

<span data-ttu-id="a51a5-832">При использовании Code First для настройки отображения модели с наследованием EF будет использовать TPH по умолчанию, поэтому все сущности в иерархии наследования будут отображены в одну таблицу.</span><span class="sxs-lookup"><span data-stu-id="a51a5-832">When using Code First to configure the mapping of a model with inheritance, EF will use TPH by default, therefore all entities in the inheritance hierarchy will be mapped to the same table.</span></span> <span data-ttu-id="a51a5-833">Подробнее о статье «Картирование с помощью API с помощью Свободного» в разделе [http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx)«Код первый в рамках entity4.1» смотрите раздел «Код первый в рамках entity4.1» в журнале MSDN () для получения более подробной информации.</span><span class="sxs-lookup"><span data-stu-id="a51a5-833">See the "Mapping with the Fluent API" section of the "Code First in Entity Framework4.1" article in MSDN Magazine ( [http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx)) for more details.</span></span>

### <a name="72-upgrading-from-ef4-to-improve-model-generation-time"></a><span data-ttu-id="a51a5-834">7.2 Обновление от EF4 для улучшения времени генерации модели</span><span class="sxs-lookup"><span data-stu-id="a51a5-834">7.2       Upgrading from EF4 to improve model generation time</span></span>

<span data-ttu-id="a51a5-835">Конкретное усовершенствование сервера для алгоритма, генерируемого слоем (SSDL) модели, доступно в рамках Entity Framework 5 и 6, а также в качестве обновления для Entity Framework 4 при установке Visual Studio 2010 SP1.</span><span class="sxs-lookup"><span data-stu-id="a51a5-835">A SQL Server-specific improvement to the algorithm that generates the store-layer (SSDL) of the model is available in Entity Framework 5 and 6, and as an update to Entity Framework 4 when Visual Studio 2010 SP1 is installed.</span></span> <span data-ttu-id="a51a5-836">Следующие результаты тестирования демонстрируют улучшение при создании очень большой модели, в данном случае модели Navision.</span><span class="sxs-lookup"><span data-stu-id="a51a5-836">The following test results demonstrate the improvement when generating a very big model, in this case the Navision model.</span></span> <span data-ttu-id="a51a5-837">Более подробную информацию об этом можно узнать в приложении C.</span><span class="sxs-lookup"><span data-stu-id="a51a5-837">See Appendix C for more details about it.</span></span>

<span data-ttu-id="a51a5-838">Модель содержит 1005 наборов сущностей и 4227 наборов ассоциаций.</span><span class="sxs-lookup"><span data-stu-id="a51a5-838">The model contains 1005 entity sets and 4227 association sets.</span></span>

| <span data-ttu-id="a51a5-839">Конфигурация</span><span class="sxs-lookup"><span data-stu-id="a51a5-839">Configuration</span></span>                              | <span data-ttu-id="a51a5-840">Разбивка времени, потребляемого</span><span class="sxs-lookup"><span data-stu-id="a51a5-840">Breakdown of time consumed</span></span>                                                                                                                                               |
|:-------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="a51a5-841">Визуальная студия 2010, Entity Framework 4</span><span class="sxs-lookup"><span data-stu-id="a51a5-841">Visual Studio 2010, Entity Framework 4</span></span>     | <span data-ttu-id="a51a5-842">Поколение SSDL: 2 часа 27 мин</span><span class="sxs-lookup"><span data-stu-id="a51a5-842">SSDL Generation: 2 hr 27 min</span></span> <br/> <span data-ttu-id="a51a5-843">Поколение карт: 1 секунда</span><span class="sxs-lookup"><span data-stu-id="a51a5-843">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="a51a5-844">Поколение CSDL: 1 секунда</span><span class="sxs-lookup"><span data-stu-id="a51a5-844">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="a51a5-845">Поколение объектного слоя: 1 секунда</span><span class="sxs-lookup"><span data-stu-id="a51a5-845">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="a51a5-846">Поколение: 2 ч 14 мин</span><span class="sxs-lookup"><span data-stu-id="a51a5-846">View Generation: 2 h 14 min</span></span> |
| <span data-ttu-id="a51a5-847">Визуальная студия 2010 SP1, Entity Framework 4</span><span class="sxs-lookup"><span data-stu-id="a51a5-847">Visual Studio 2010 SP1, Entity Framework 4</span></span> | <span data-ttu-id="a51a5-848">Поколение SSDL: 1 секунда</span><span class="sxs-lookup"><span data-stu-id="a51a5-848">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="a51a5-849">Поколение карт: 1 секунда</span><span class="sxs-lookup"><span data-stu-id="a51a5-849">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="a51a5-850">Поколение CSDL: 1 секунда</span><span class="sxs-lookup"><span data-stu-id="a51a5-850">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="a51a5-851">Поколение объектного слоя: 1 секунда</span><span class="sxs-lookup"><span data-stu-id="a51a5-851">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="a51a5-852">Поколение: 1 час 53 мин</span><span class="sxs-lookup"><span data-stu-id="a51a5-852">View Generation: 1 hr 53 min</span></span>   |
| <span data-ttu-id="a51a5-853">Визуальная студия 2013, Entity Framework 5</span><span class="sxs-lookup"><span data-stu-id="a51a5-853">Visual Studio 2013, Entity Framework 5</span></span>     | <span data-ttu-id="a51a5-854">Поколение SSDL: 1 секунда</span><span class="sxs-lookup"><span data-stu-id="a51a5-854">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="a51a5-855">Поколение карт: 1 секунда</span><span class="sxs-lookup"><span data-stu-id="a51a5-855">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="a51a5-856">Поколение CSDL: 1 секунда</span><span class="sxs-lookup"><span data-stu-id="a51a5-856">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="a51a5-857">Поколение объектного слоя: 1 секунда</span><span class="sxs-lookup"><span data-stu-id="a51a5-857">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="a51a5-858">Поколение просмотра: 65 минут</span><span class="sxs-lookup"><span data-stu-id="a51a5-858">View Generation: 65 minutes</span></span>    |
| <span data-ttu-id="a51a5-859">Визуальная студия 2013, Entity Framework 6</span><span class="sxs-lookup"><span data-stu-id="a51a5-859">Visual Studio 2013, Entity Framework 6</span></span>     | <span data-ttu-id="a51a5-860">Поколение SSDL: 1 секунда</span><span class="sxs-lookup"><span data-stu-id="a51a5-860">SSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="a51a5-861">Поколение карт: 1 секунда</span><span class="sxs-lookup"><span data-stu-id="a51a5-861">Mapping Generation: 1 second</span></span> <br/> <span data-ttu-id="a51a5-862">Поколение CSDL: 1 секунда</span><span class="sxs-lookup"><span data-stu-id="a51a5-862">CSDL Generation: 1 second</span></span> <br/> <span data-ttu-id="a51a5-863">Поколение объектного слоя: 1 секунда</span><span class="sxs-lookup"><span data-stu-id="a51a5-863">ObjectLayer Generation: 1 second</span></span> <br/> <span data-ttu-id="a51a5-864">Поколение просмотра: 28 секунд.</span><span class="sxs-lookup"><span data-stu-id="a51a5-864">View Generation: 28 seconds.</span></span>   |


<span data-ttu-id="a51a5-865">Стоит отметить, что при генерации SSDL нагрузка почти полностью расходуется на сервер S'L Server, в то время как машина разработки клиента ждет простоя, пока результаты будут возвращены с сервера.</span><span class="sxs-lookup"><span data-stu-id="a51a5-865">It's worth noting that when generating the SSDL, the load is almost entirely spent on the SQL Server, while the client development machine is waiting idle for results to come back from the server.</span></span> <span data-ttu-id="a51a5-866">Освоен этому улучшению должны быть особенно оцениваемы dB.</span><span class="sxs-lookup"><span data-stu-id="a51a5-866">DBAs should particularly appreciate this improvement.</span></span> <span data-ttu-id="a51a5-867">Стоит также отметить, что по существу вся стоимость генерации модели происходит в View Generation сейчас.</span><span class="sxs-lookup"><span data-stu-id="a51a5-867">It's also worth noting that essentially the entire cost of model generation takes place in View Generation now.</span></span>

### <a name="73-splitting-large-models-with-database-first-and-model-first"></a><span data-ttu-id="a51a5-868">7.3 Разделение больших моделей с базой первой и модели first</span><span class="sxs-lookup"><span data-stu-id="a51a5-868">7.3       Splitting Large Models with Database First and Model First</span></span>

<span data-ttu-id="a51a5-869">По мере увеличения размера модели поверхность конструктора становится загроможденной и трудной в использовании.</span><span class="sxs-lookup"><span data-stu-id="a51a5-869">As model size increases, the designer surface becomes cluttered and difficult to use.</span></span> <span data-ttu-id="a51a5-870">Обычно мы считаем модель с более чем 300 объектами слишком большой, чтобы эффективно использовать конструктор.</span><span class="sxs-lookup"><span data-stu-id="a51a5-870">We typically consider a model with more than 300 entities to be too large to effectively use the designer.</span></span> <span data-ttu-id="a51a5-871">Следующий блог описывает несколько вариантов \< https://docs.microsoft.com/archive/blogs/adonet/working-with-large-models-in-entity-framework-part-2>для разделения больших моделей: .</span><span class="sxs-lookup"><span data-stu-id="a51a5-871">The following blog post describes several options for splitting large models: \<https://docs.microsoft.com/archive/blogs/adonet/working-with-large-models-in-entity-framework-part-2>.</span></span>

<span data-ttu-id="a51a5-872">Сообщение было написано для первой версии Рамочной организации, но шаги все еще применяются.</span><span class="sxs-lookup"><span data-stu-id="a51a5-872">The post was written for the first version of Entity Framework, but the steps still apply.</span></span>

### <a name="74-performance-considerations-with-the-entity-data-source-control"></a><span data-ttu-id="a51a5-873">7.4 Соображения производительности с помощью управления источниками данных entity</span><span class="sxs-lookup"><span data-stu-id="a51a5-873">7.4       Performance considerations with the Entity Data Source Control</span></span>

<span data-ttu-id="a51a5-874">Мы видели случаи в многопоточных производительности и стресс-тестов, где производительность веб-приложения с помощью EntityDataSource Control значительно ухудшается.</span><span class="sxs-lookup"><span data-stu-id="a51a5-874">We've seen cases in multi-threaded performance and stress tests where the performance of a web application using the EntityDataSource Control deteriorates significantly.</span></span> <span data-ttu-id="a51a5-875">Основная причина заключается в том, что EntityDataSource неоднократно вызывает MetadataWorkspace.LoadFromAssembly на сборках, на которые ссылается веб-приложение, чтобы обнаружить типы, которые будут использоваться в качестве сущностей.</span><span class="sxs-lookup"><span data-stu-id="a51a5-875">The underlying cause is that the EntityDataSource repeatedly calls MetadataWorkspace.LoadFromAssembly on the assemblies referenced by the Web application to discover the types to be used as entities.</span></span>

<span data-ttu-id="a51a5-876">Решение заключается в том, чтобы установить ContextTypeName EntityDataSource к типу имени вашего производного класса ObjectContext.</span><span class="sxs-lookup"><span data-stu-id="a51a5-876">The solution is to set the ContextTypeName of the EntityDataSource to the type name of your derived ObjectContext class.</span></span> <span data-ttu-id="a51a5-877">Это выключает механизм, который сканирует все ссылки на сборки для типов сущностей.</span><span class="sxs-lookup"><span data-stu-id="a51a5-877">This turns off the mechanism that scans all referenced assemblies for entity types.</span></span>

<span data-ttu-id="a51a5-878">Установка поля ContextTypeName также предотвращает функциональную проблему, когда EntityDataSource в .NET 4.0 бросает ReflectionTypeLoadException, когда он не может загрузить тип из сборки с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="a51a5-878">Setting the ContextTypeName field also prevents a functional problem where the EntityDataSource in .NET 4.0 throws a ReflectionTypeLoadException when it can't load a type from an assembly via reflection.</span></span> <span data-ttu-id="a51a5-879">Эта проблема была исправлена в .NET 4.5.</span><span class="sxs-lookup"><span data-stu-id="a51a5-879">This issue has been fixed in .NET 4.5.</span></span>

### <a name="75-poco-entities-and-change-tracking-proxies"></a><span data-ttu-id="a51a5-880">7.5 Сущности POCO и прокси-данные по отслеживанию изменений</span><span class="sxs-lookup"><span data-stu-id="a51a5-880">7.5       POCO entities and change tracking proxies</span></span>

<span data-ttu-id="a51a5-881">Entity Framework позволяет использовать индивидуальные классы данных вместе с моделью данных без внесения каких-либо изменений в сами классы данных.</span><span class="sxs-lookup"><span data-stu-id="a51a5-881">Entity Framework enables you to use custom data classes together with your data model without making any modifications to the data classes themselves.</span></span> <span data-ttu-id="a51a5-882">Это означает, что с моделью данных могут быть использованы традиционные объекты среды CLR (POCO), например существующие объекты домена.</span><span class="sxs-lookup"><span data-stu-id="a51a5-882">This means that you can use "plain-old" CLR objects (POCO), such as existing domain objects, with your data model.</span></span> <span data-ttu-id="a51a5-883">Эти классы данных POCO (также известные как объекты, не осведомленные о сохранении), которые отображаются на сущностях, которые определяются в модели данных, поддерживают большую часть одного и того же запроса, вставляют, обновляют и удаляют поведения как типы сущностей, генерируемые инструментами модели данных entity.</span><span class="sxs-lookup"><span data-stu-id="a51a5-883">These POCO data classes (also known as persistence-ignorant objects), which are mapped to entities that are defined in a data model, support most of the same query, insert, update, and delete behaviors as entity types that are generated by the Entity Data Model tools.</span></span>

<span data-ttu-id="a51a5-884">Система entity может также создавать классы прокси, полученные из типов POCO, которые используются при входной функции, такие как ленивая загрузка и автоматическое отслеживание изменений на объектах POCO.</span><span class="sxs-lookup"><span data-stu-id="a51a5-884">Entity Framework can also create proxy classes derived from your POCO types, which are used when you want to enable features such as lazy loading and automatic change tracking on POCO entities.</span></span> <span data-ttu-id="a51a5-885">Ваши классы POCO должны соответствовать определенным требованиям, позволяющим системе [http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx)Entity Framework использовать прокси- иподобия, как описано здесь: .</span><span class="sxs-lookup"><span data-stu-id="a51a5-885">Your POCO classes must meet certain requirements to allow Entity Framework to use proxies, as described here: [http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx).</span></span>

<span data-ttu-id="a51a5-886">Прокси-менеджеры отслеживания шансов будут уведомлять диспетчера состояния объектов каждый раз, когда любое из свойств ваших сущностей изменяется, поэтому система Entity</span><span class="sxs-lookup"><span data-stu-id="a51a5-886">Chance tracking proxies will notify the object state manager each time any of the properties of your entities has its value changed, so Entity Framework knows the actual state of your entities all the time.</span></span> <span data-ttu-id="a51a5-887">Это делается путем добавления событий уведомлений в тело методов сеттера ваших свойств и с помощью менеджера состояния объекта обработки таких событий.</span><span class="sxs-lookup"><span data-stu-id="a51a5-887">This is done by adding notification events to the body of the setter methods of your properties, and having the object state manager processing such events.</span></span> <span data-ttu-id="a51a5-888">Обратите внимание, что создание прокси-сущности, как правило, будет более дорогостоящим, чем создание сущности POCO, не являющаяся прокси-сервером, из-за добавленного набора событий, созданных рамочной организацией entity.</span><span class="sxs-lookup"><span data-stu-id="a51a5-888">Note that creating a proxy entity will typically be more expensive than creating a non-proxy POCO entity due to the added set of events created by Entity Framework.</span></span>

<span data-ttu-id="a51a5-889">Если у сущности POCO нет прокси-сервера отслеживания изменений, изменения обнаруживаются путем сравнения содержимого сущностей с копией предыдущего сохраненного состояния.</span><span class="sxs-lookup"><span data-stu-id="a51a5-889">When a POCO entity does not have a change tracking proxy, changes are found by comparing the contents of your entities against a copy of a previous saved state.</span></span> <span data-ttu-id="a51a5-890">Это глубокое сравнение станет длительным процессом, когда у вас есть много сущностей в контексте, или когда ваши сущности имеют очень большое количество свойств, даже если ни одно из них не изменилось с момента последнего сравнения.</span><span class="sxs-lookup"><span data-stu-id="a51a5-890">This deep comparison will become a lengthy process when you have many entities in your context, or when your entities have a very large amount of properties, even if none of them changed since the last comparison took place.</span></span>

<span data-ttu-id="a51a5-891">Резюмируя: при создании прокси-сервера отслеживания изменений вы будете платить за производительность, но отслеживание изменений поможет вам ускорить процесс обнаружения изменений, когда у вас есть много свойств или когда в модели много сущностей.</span><span class="sxs-lookup"><span data-stu-id="a51a5-891">In summary: you’ll pay a performance hit when creating the change tracking proxy, but change tracking will help you speed up the change detection process when your entities have many properties or when you have many entities in your model.</span></span> <span data-ttu-id="a51a5-892">Для сущностей с небольшим количеством свойств, где количество сущностей не растет слишком много, наличие прокси-треков отслеживания изменений не может быть большой пользы.</span><span class="sxs-lookup"><span data-stu-id="a51a5-892">For entities with a small number of properties where the amount of entities doesn’t grow too much, having change tracking proxies may not be of much benefit.</span></span>

## <a name="8-loading-related-entities"></a><span data-ttu-id="a51a5-893">8 Загрузка связанных лиц</span><span class="sxs-lookup"><span data-stu-id="a51a5-893">8 Loading Related Entities</span></span>

### <a name="81-lazy-loading-vs-eager-loading"></a><span data-ttu-id="a51a5-894">8.1 Ленивая загрузка против стремящейся загрузки</span><span class="sxs-lookup"><span data-stu-id="a51a5-894">8.1 Lazy Loading vs. Eager Loading</span></span>

<span data-ttu-id="a51a5-895">Система сущности предлагает несколько различных способов загрузки сущностей, связанных с целевой сущностью.</span><span class="sxs-lookup"><span data-stu-id="a51a5-895">Entity Framework offers several different ways to load the entities that are related to your target entity.</span></span> <span data-ttu-id="a51a5-896">Например, при запросе для продуктов существуют различные способы загрузки соответствующих заказов в диспетчер состояния объектов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-896">For example, when you query for Products, there are different ways that the related Orders will be loaded into the Object State Manager.</span></span> <span data-ttu-id="a51a5-897">С точки зрения производительности, самый большой вопрос, который следует учитывать при загрузке связанных объектов, будет заключаться в том, следует ли использовать Ленивую загрузку или стремяться к загрузке.</span><span class="sxs-lookup"><span data-stu-id="a51a5-897">From a performance standpoint, the biggest question to consider when loading related entities will be whether to use Lazy Loading or Eager Loading.</span></span>

<span data-ttu-id="a51a5-898">При использовании Eager Loading связанные сущности загружаются вместе с набором целевой сущности.</span><span class="sxs-lookup"><span data-stu-id="a51a5-898">When using Eager Loading, the related entities are loaded along with your target entity set.</span></span> <span data-ttu-id="a51a5-899">В запросе используется выписка включить, чтобы указать, какие связанные сущности вы хотите принести.</span><span class="sxs-lookup"><span data-stu-id="a51a5-899">You use an Include statement in your query to indicate which related entities you want to bring in.</span></span>

<span data-ttu-id="a51a5-900">При использовании Lazy Loading исходный запрос приводит только набор целевой объект.</span><span class="sxs-lookup"><span data-stu-id="a51a5-900">When using Lazy Loading, your initial query only brings in the target entity set.</span></span> <span data-ttu-id="a51a5-901">Но всякий раз, когда вы получаете доступ к свойству навигации, другой запрос выдается в магазин для загрузки соответствующей сущности.</span><span class="sxs-lookup"><span data-stu-id="a51a5-901">But whenever you access a navigation property, another query is issued against the store to load the related entity.</span></span>

<span data-ttu-id="a51a5-902">После загрузки объекта любые дополнительные запросы для объекта будут загружаться непосредственно от диспетчера состояния объектов, независимо от того, используете ли вы ленивую загрузку или недальновидную загрузку.</span><span class="sxs-lookup"><span data-stu-id="a51a5-902">Once an entity has been loaded, any further queries for the entity will load it directly from the Object State Manager, whether you are using lazy loading or eager loading.</span></span>

### <a name="82-how-to-choose-between-lazy-loading-and-eager-loading"></a><span data-ttu-id="a51a5-903">8.2 Как выбрать между ленивой загрузкой и стремящейся загрузкой</span><span class="sxs-lookup"><span data-stu-id="a51a5-903">8.2 How to choose between Lazy Loading and Eager Loading</span></span>

<span data-ttu-id="a51a5-904">Важно то, что вы понимаете разницу между Ленивый загрузки и стремятся загрузки, так что вы можете сделать правильный выбор для вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="a51a5-904">The important thing is that you understand the difference between Lazy Loading and Eager Loading so that you can make the correct choice for your application.</span></span> <span data-ttu-id="a51a5-905">Это поможет вам оценить компромисс между несколькими запросами по базе данных и одним запросом, который может содержать большую полезную нагрузку.</span><span class="sxs-lookup"><span data-stu-id="a51a5-905">This will help you evaluate the tradeoff between multiple requests against the database versus a single request that may contain a large payload.</span></span> <span data-ttu-id="a51a5-906">Возможно, целесообразно использовать несбывную загрузку в некоторых частях приложения и ленивую загрузку в других частях.</span><span class="sxs-lookup"><span data-stu-id="a51a5-906">It may be appropriate to use eager loading in some parts of your application and lazy loading in other parts.</span></span>

<span data-ttu-id="a51a5-907">В качестве примера того, что происходит под капотом, предположим, вы хотите, чтобы запрос для клиентов, которые живут в Великобритании и их количество заказов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-907">As an example of what's happening under the hood, suppose you want to query for the customers who live in the UK and their order count.</span></span>

<span data-ttu-id="a51a5-908">**Использование стремящихся загрузки**</span><span class="sxs-lookup"><span data-stu-id="a51a5-908">**Using Eager Loading**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var ukCustomers = context.Customers.Include(c => c.Orders).Where(c => c.Address.Country == "UK");
    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

<span data-ttu-id="a51a5-909">**Использование ленивой загрузки**</span><span class="sxs-lookup"><span data-stu-id="a51a5-909">**Using Lazy Loading**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    context.ContextOptions.LazyLoadingEnabled = true;

    //Notice that the Include method call is missing in the query
    var ukCustomers = context.Customers.Where(c => c.Address.Country == "UK");

    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

<span data-ttu-id="a51a5-910">При использовании нетерпеливой загрузки вы выдаете один запрос, который возвращает всем клиентам и всем заказам.</span><span class="sxs-lookup"><span data-stu-id="a51a5-910">When using eager loading, you'll issue a single query that returns all customers and all orders.</span></span> <span data-ttu-id="a51a5-911">Команда магазина выглядит следующим:</span><span class="sxs-lookup"><span data-stu-id="a51a5-911">The store command looks like:</span></span>

``` SQL
SELECT
[Project1].[C1] AS [C1],
[Project1].[CustomerID] AS [CustomerID],
[Project1].[CompanyName] AS [CompanyName],
[Project1].[ContactName] AS [ContactName],
[Project1].[ContactTitle] AS [ContactTitle],
[Project1].[Address] AS [Address],
[Project1].[City] AS [City],
[Project1].[Region] AS [Region],
[Project1].[PostalCode] AS [PostalCode],
[Project1].[Country] AS [Country],
[Project1].[Phone] AS [Phone],
[Project1].[Fax] AS [Fax],
[Project1].[C2] AS [C2],
[Project1].[OrderID] AS [OrderID],
[Project1].[CustomerID1] AS [CustomerID1],
[Project1].[EmployeeID] AS [EmployeeID],
[Project1].[OrderDate] AS [OrderDate],
[Project1].[RequiredDate] AS [RequiredDate],
[Project1].[ShippedDate] AS [ShippedDate],
[Project1].[ShipVia] AS [ShipVia],
[Project1].[Freight] AS [Freight],
[Project1].[ShipName] AS [ShipName],
[Project1].[ShipAddress] AS [ShipAddress],
[Project1].[ShipCity] AS [ShipCity],
[Project1].[ShipRegion] AS [ShipRegion],
[Project1].[ShipPostalCode] AS [ShipPostalCode],
[Project1].[ShipCountry] AS [ShipCountry]
FROM ( SELECT
      [Extent1].[CustomerID] AS [CustomerID],
       [Extent1].[CompanyName] AS [CompanyName],
       [Extent1].[ContactName] AS [ContactName],
       [Extent1].[ContactTitle] AS [ContactTitle],
       [Extent1].[Address] AS [Address],
       [Extent1].[City] AS [City],
       [Extent1].[Region] AS [Region],
       [Extent1].[PostalCode] AS [PostalCode],
       [Extent1].[Country] AS [Country],
       [Extent1].[Phone] AS [Phone],
       [Extent1].[Fax] AS [Fax],
      1 AS [C1],
       [Extent2].[OrderID] AS [OrderID],
       [Extent2].[CustomerID] AS [CustomerID1],
       [Extent2].[EmployeeID] AS [EmployeeID],
       [Extent2].[OrderDate] AS [OrderDate],
       [Extent2].[RequiredDate] AS [RequiredDate],
       [Extent2].[ShippedDate] AS [ShippedDate],
       [Extent2].[ShipVia] AS [ShipVia],
       [Extent2].[Freight] AS [Freight],
       [Extent2].[ShipName] AS [ShipName],
       [Extent2].[ShipAddress] AS [ShipAddress],
       [Extent2].[ShipCity] AS [ShipCity],
       [Extent2].[ShipRegion] AS [ShipRegion],
       [Extent2].[ShipPostalCode] AS [ShipPostalCode],
       [Extent2].[ShipCountry] AS [ShipCountry],
      CASE WHEN ([Extent2].[OrderID] IS NULL) THEN CAST(NULL AS int) ELSE 1 END AS [C2]
      FROM  [dbo].[Customers] AS [Extent1]
      LEFT OUTER JOIN [dbo].[Orders] AS [Extent2] ON [Extent1].[CustomerID] = [Extent2].[CustomerID]
      WHERE N'UK' = [Extent1].[Country]
)  AS [Project1]
ORDER BY [Project1].[CustomerID] ASC, [Project1].[C2] ASC
```

<span data-ttu-id="a51a5-912">При использовании ленивой загрузки вы будете выдавать следующий запрос на начальном этапе:</span><span class="sxs-lookup"><span data-stu-id="a51a5-912">When using lazy loading, you'll issue the following query initially:</span></span>

``` SQL
SELECT
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[CompanyName] AS [CompanyName],
[Extent1].[ContactName] AS [ContactName],
[Extent1].[ContactTitle] AS [ContactTitle],
[Extent1].[Address] AS [Address],
[Extent1].[City] AS [City],
[Extent1].[Region] AS [Region],
[Extent1].[PostalCode] AS [PostalCode],
[Extent1].[Country] AS [Country],
[Extent1].[Phone] AS [Phone],
[Extent1].[Fax] AS [Fax]
FROM [dbo].[Customers] AS [Extent1]
WHERE N'UK' = [Extent1].[Country]
```

<span data-ttu-id="a51a5-913">И каждый раз, когда вы получаете доступ к навигационному свойству Заказов клиента, в отношении магазина выдается другой запрос, подобный следующему:</span><span class="sxs-lookup"><span data-stu-id="a51a5-913">And each time you access the Orders navigation property of a customer another query like the following is issued against the store:</span></span>

``` SQL
exec sp_executesql N'SELECT
[Extent1].[OrderID] AS [OrderID],
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[EmployeeID] AS [EmployeeID],
[Extent1].[OrderDate] AS [OrderDate],
[Extent1].[RequiredDate] AS [RequiredDate],
[Extent1].[ShippedDate] AS [ShippedDate],
[Extent1].[ShipVia] AS [ShipVia],
[Extent1].[Freight] AS [Freight],
[Extent1].[ShipName] AS [ShipName],
[Extent1].[ShipAddress] AS [ShipAddress],
[Extent1].[ShipCity] AS [ShipCity],
[Extent1].[ShipRegion] AS [ShipRegion],
[Extent1].[ShipPostalCode] AS [ShipPostalCode],
[Extent1].[ShipCountry] AS [ShipCountry]
FROM [dbo].[Orders] AS [Extent1]
WHERE [Extent1].[CustomerID] = @EntityKeyValue1',N'@EntityKeyValue1 nchar(5)',@EntityKeyValue1=N'AROUT'
```

<span data-ttu-id="a51a5-914">Для получения дополнительной информации [см.](https://msdn.microsoft.com/library/bb896272.aspx)</span><span class="sxs-lookup"><span data-stu-id="a51a5-914">For more information, see the [Loading Related Objects](https://msdn.microsoft.com/library/bb896272.aspx).</span></span>

#### <a name="821-lazy-loading-versus-eager-loading-cheat-sheet"></a><span data-ttu-id="a51a5-915">8.2.1 Ленивая загрузка против стремящегося загрузки шпаргалки</span><span class="sxs-lookup"><span data-stu-id="a51a5-915">8.2.1 Lazy Loading versus Eager Loading cheat sheet</span></span>

<span data-ttu-id="a51a5-916">Там нет такого понятия, как один-размер-подходит для выбора стремятся загрузки по сравнению с ленивыми загрузки.</span><span class="sxs-lookup"><span data-stu-id="a51a5-916">There’s no such thing as a one-size-fits-all to choosing eager loading versus lazy loading.</span></span> <span data-ttu-id="a51a5-917">Сначала поймите различия между обеими стратегиями, чтобы вы могли принять взвешенное решение; также, рассмотрим, если ваш код подходит к любому из следующих сценариев:</span><span class="sxs-lookup"><span data-stu-id="a51a5-917">Try first to understand the differences between both strategies so you can do a well informed decision; also, consider if your code fits to any of the following scenarios:</span></span>

| <span data-ttu-id="a51a5-918">Сценарий</span><span class="sxs-lookup"><span data-stu-id="a51a5-918">Scenario</span></span>                                                                    | <span data-ttu-id="a51a5-919">Наше предложение</span><span class="sxs-lookup"><span data-stu-id="a51a5-919">Our Suggestion</span></span>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|:----------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="a51a5-920">Вам необходимо получить доступ ко многим навигационным свойствам из извлеченных сущностей?</span><span class="sxs-lookup"><span data-stu-id="a51a5-920">Do you need to access many navigation properties from the fetched entities?</span></span> | <span data-ttu-id="a51a5-921">**Нет** - Оба варианта, вероятно, делать.</span><span class="sxs-lookup"><span data-stu-id="a51a5-921">**No** - Both options will probably do.</span></span> <span data-ttu-id="a51a5-922">Однако, если полезная нагрузка, которую приносит ваш запрос, не слишком велика, вы можете столкнуться с преимуществами производительности, используя загрузку Eager, поскольку для материализации объектов потребуется меньше сетевых поездок.</span><span class="sxs-lookup"><span data-stu-id="a51a5-922">However, if the payload your query is bringing is not too big, you may experience performance benefits by using Eager loading as it’ll require less network round trips to materialize your objects.</span></span> <br/> <br/> <span data-ttu-id="a51a5-923">**Да** - Если вам необходимо получить доступ ко многим навигационным свойствам от сущностей, вы бы сделали это, используя несколько включающих операторы в запросе с загрузкой Eager.</span><span class="sxs-lookup"><span data-stu-id="a51a5-923">**Yes** -  If you need to access many navigation properties from the entities, you’d do that by using multiple include statements in your query with Eager loading.</span></span> <span data-ttu-id="a51a5-924">Чем больше объектов вы включите, тем больше полезная нагрузка будет возвращаться в запрос.</span><span class="sxs-lookup"><span data-stu-id="a51a5-924">The more entities you include, the bigger the payload your query will return.</span></span> <span data-ttu-id="a51a5-925">После включения трех или более объектов в свой запрос рассмотрите возможность переключения на ленивую загрузку.</span><span class="sxs-lookup"><span data-stu-id="a51a5-925">Once you include three or more entities into your query, consider switching to Lazy loading.</span></span> |
| <span data-ttu-id="a51a5-926">Вы точно знаете, какие данные понадобятся во время выполнения?</span><span class="sxs-lookup"><span data-stu-id="a51a5-926">Do you know exactly what data will be needed at run time?</span></span>                   | <span data-ttu-id="a51a5-927">**Нет** - Ленивая загрузка будет лучше для вас.</span><span class="sxs-lookup"><span data-stu-id="a51a5-927">**No** - Lazy loading will be better for you.</span></span> <span data-ttu-id="a51a5-928">В противном случае вы можете в конечном итоге запросить данные, которые вам не понадобятся.</span><span class="sxs-lookup"><span data-stu-id="a51a5-928">Otherwise, you may end up querying for data that you will not need.</span></span> <br/> <br/> <span data-ttu-id="a51a5-929">**Да** - Стремясь загрузки, вероятно, ваш лучший выбор; это поможет быстрее загрузить целые наборы.</span><span class="sxs-lookup"><span data-stu-id="a51a5-929">**Yes** - Eager loading is probably your best bet; it will help loading entire sets faster.</span></span> <span data-ttu-id="a51a5-930">Если ваш запрос требует получения очень большого объема данных, и это становится слишком медленным, попробуйте ленивую загрузку вместо этого.</span><span class="sxs-lookup"><span data-stu-id="a51a5-930">If your query requires fetching a very large amount of data, and this becomes too slow, then try Lazy loading instead.</span></span>                                                                                                                                                                                                                                                       |
| <span data-ttu-id="a51a5-931">Ваш код используется далеко от вашей базы данных?</span><span class="sxs-lookup"><span data-stu-id="a51a5-931">Is your code executing far from your database?</span></span> <span data-ttu-id="a51a5-932">(увеличение задержки сети)</span><span class="sxs-lookup"><span data-stu-id="a51a5-932">(increased network latency)</span></span>  | <span data-ttu-id="a51a5-933">**Нет** - Когда задержка сети не является проблемой, использование Ленивая загрузка может упростить код.</span><span class="sxs-lookup"><span data-stu-id="a51a5-933">**No** - When the network latency is not an issue, using Lazy loading may simplify your code.</span></span> <span data-ttu-id="a51a5-934">Помните, что топология приложения может измениться, поэтому не принимайте близость базы данных как должное.</span><span class="sxs-lookup"><span data-stu-id="a51a5-934">Remember that the topology of your application may change, so don’t take database proximity for granted.</span></span> <br/> <br/> <span data-ttu-id="a51a5-935">**Да** - Когда сеть является проблемой, только вы можете решить, что лучше подходит для вашего сценария.</span><span class="sxs-lookup"><span data-stu-id="a51a5-935">**Yes** - When the network is a problem, only you can decide what fits better for your scenario.</span></span> <span data-ttu-id="a51a5-936">Как правило, eager загрузка будет лучше, потому что она требует меньше поездок в облаву.</span><span class="sxs-lookup"><span data-stu-id="a51a5-936">Typically Eager loading will be better because it requires fewer round trips.</span></span>                                                                                                                                                                                                      |


#### <a name="822-performance-concerns-with-multiple-includes"></a><span data-ttu-id="a51a5-937">8.2.2 Проблемы производительности с несколькими включает</span><span class="sxs-lookup"><span data-stu-id="a51a5-937">8.2.2       Performance concerns with multiple Includes</span></span>

<span data-ttu-id="a51a5-938">Когда мы слышим вопросы производительности, связанные с проблемами времени отклика сервера, источником проблемы часто являются запросы с несколькими операторами Включить.</span><span class="sxs-lookup"><span data-stu-id="a51a5-938">When we hear performance questions that involve server response time problems, the source of the issue is frequently queries with multiple Include statements.</span></span> <span data-ttu-id="a51a5-939">Хотя включение связанных сущностей в запрос является мощным, важно понимать, что происходит под крышкой.</span><span class="sxs-lookup"><span data-stu-id="a51a5-939">While including related entities in a query is powerful, it's important to understand what's happening under the covers.</span></span>

<span data-ttu-id="a51a5-940">Запрос с несколькими операторами Включить в нем занимает относительно много времени, чтобы просмотреть наш внутренний компилятор плана для создания команды магазина.</span><span class="sxs-lookup"><span data-stu-id="a51a5-940">It takes a relatively long time for a query with multiple Include statements in it to go through our internal plan compiler to produce the store command.</span></span> <span data-ttu-id="a51a5-941">Большая часть этого времени уходит на попытки оптимизировать полученный запрос.</span><span class="sxs-lookup"><span data-stu-id="a51a5-941">The majority of this time is spent trying to optimize the resulting query.</span></span> <span data-ttu-id="a51a5-942">Команда сгенерированного хранилища будет содержать внешнее соединение или союз для каждого включения, в зависимости от от вашего отображения.</span><span class="sxs-lookup"><span data-stu-id="a51a5-942">The generated store command will contain an Outer Join or Union for each Include, depending on your mapping.</span></span> <span data-ttu-id="a51a5-943">Запросы, подобные этому, приведут к тому, что большие подключенные графики из вашей базы данных будут использоваться в одной полезной нагрузке, что приведет к acerbate любых проблем с пропускной способностью, особенно при большом увеличении полезной нагрузки (например, когда несколько уровней Включения используются для обхода ассоциаций в направлении от одного до многих).</span><span class="sxs-lookup"><span data-stu-id="a51a5-943">Queries like this will bring in large connected graphs from your database in a single payload, which will acerbate any bandwidth issues, especially when there is a lot of redundancy in the payload (for example, when multiple levels of Include are used to traverse associations in the one-to-many direction).</span></span>

<span data-ttu-id="a51a5-944">Вы можете проверить случаи, когда ваши запросы возвращают слишком большие полезные нагрузки, обратившись к базовому запросу TS'L, используя ToTraceString и выполнив команду магазина в студии управления серверами S'L, чтобы увидеть размер полезной нагрузки.</span><span class="sxs-lookup"><span data-stu-id="a51a5-944">You can check for cases where your queries are returning excessively large payloads by accessing the underlying TSQL for the query by using ToTraceString and executing the store command in SQL Server Management Studio to see the payload size.</span></span> <span data-ttu-id="a51a5-945">В таких случаях можно попытаться уменьшить количество инструкций Включить в запрос, чтобы просто принести данные, которые вам нужны.</span><span class="sxs-lookup"><span data-stu-id="a51a5-945">In such cases you can try to reduce the number of Include statements in your query to just bring in the data you need.</span></span> <span data-ttu-id="a51a5-946">Или вы можете разбить запрос на меньшую последовательность субзапросов, например:</span><span class="sxs-lookup"><span data-stu-id="a51a5-946">Or you may be able to break your query into a smaller sequence of subqueries, for example:</span></span>

<span data-ttu-id="a51a5-947">**Перед нарушением запроса:**</span><span class="sxs-lookup"><span data-stu-id="a51a5-947">**Before breaking the query:**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var customers = from c in context.Customers.Include(c => c.Orders)
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

<span data-ttu-id="a51a5-948">**После взлома запроса:**</span><span class="sxs-lookup"><span data-stu-id="a51a5-948">**After breaking the query:**</span></span>

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var orders = from o in context.Orders
                 where o.Customer.LastName.StartsWith(lastNameParameter)
                 select o;

    orders.Load();

    var customers = from c in context.Customers
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

<span data-ttu-id="a51a5-949">Это будет работать только на отслеживаемых запросах, так как мы используем возможность контекста для выполнения разрешения идентификации и исправления ассоциации автоматически.</span><span class="sxs-lookup"><span data-stu-id="a51a5-949">This will work only on tracked queries, as we are making use of the ability the context has to perform identity resolution and association fixup automatically.</span></span>

<span data-ttu-id="a51a5-950">Как и в том, что с ленивой загрузкой, компромисс будет больше запросов для меньших полезных нагрузок.</span><span class="sxs-lookup"><span data-stu-id="a51a5-950">As with lazy loading, the tradeoff will be more queries for smaller payloads.</span></span> <span data-ttu-id="a51a5-951">Вы также можете использовать проекции отдельных свойств, чтобы явно выбрать только данные, необходимые от каждой сущности, но в этом случае вы не будете загружать объекты, и обновления не будут поддерживаться.</span><span class="sxs-lookup"><span data-stu-id="a51a5-951">You can also use projections of individual properties to explicitly select only the data you need from each entity, but you will not be loading entities in this case, and updates will not be supported.</span></span>

#### <a name="823-workaround-to-get-lazy-loading-of-properties"></a><span data-ttu-id="a51a5-952">8.2.3 Обход, чтобы получить ленивый загрузки свойств</span><span class="sxs-lookup"><span data-stu-id="a51a5-952">8.2.3 Workaround to get lazy loading of properties</span></span>

<span data-ttu-id="a51a5-953">В настоящее время система Entity Framework не поддерживает ленивую загрузку масштабных или сложных свойств.</span><span class="sxs-lookup"><span data-stu-id="a51a5-953">Entity Framework currently doesn’t support lazy loading of scalar or complex properties.</span></span> <span data-ttu-id="a51a5-954">Однако в тех случаях, когда есть таблица, включающая большой объект, такой как BLOB, можно использовать разделение таблицы, чтобы разделить большие свойства на отдельную сущность.</span><span class="sxs-lookup"><span data-stu-id="a51a5-954">However, in cases where you have a table that includes a large object such as a BLOB, you can use table splitting to separate the large properties into a separate entity.</span></span> <span data-ttu-id="a51a5-955">Например, предположим, что у вас есть таблица продуктов, которая включает в себя варбинарную колонку фотографий.</span><span class="sxs-lookup"><span data-stu-id="a51a5-955">For example, suppose you have a Product table that includes a varbinary photo column.</span></span> <span data-ttu-id="a51a5-956">Если вам не часто требуется доступ к этому свойству в запросах, можно использовать разделение таблицы, чтобы привести только те части сущности, которые обычно необходимы.</span><span class="sxs-lookup"><span data-stu-id="a51a5-956">If you don't frequently need to access this property in your queries, you can use table splitting to bring in only the parts of the entity that you normally need.</span></span> <span data-ttu-id="a51a5-957">Сущность, представляющая фотографию продукта, будет загружена только тогда, когда она явно необходима.</span><span class="sxs-lookup"><span data-stu-id="a51a5-957">The entity representing the product photo will only be loaded when you explicitly need it.</span></span>

<span data-ttu-id="a51a5-958">Хороший ресурс, который показывает, как включить разделение таблицы является Гил Финк \< http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx>в "Таблица разделения в рамках entity" блоге: .</span><span class="sxs-lookup"><span data-stu-id="a51a5-958">A good resource that shows how to enable table splitting is Gil Fink's "Table Splitting in Entity Framework" blog post: \<http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx>.</span></span>

## <a name="9-other-considerations"></a><span data-ttu-id="a51a5-959">9 Другие соображения</span><span class="sxs-lookup"><span data-stu-id="a51a5-959">9 Other considerations</span></span>

### <a name="91-server-garbage-collection"></a><span data-ttu-id="a51a5-960">9.1 Сбор мусора сервера</span><span class="sxs-lookup"><span data-stu-id="a51a5-960">9.1      Server Garbage Collection</span></span>

<span data-ttu-id="a51a5-961">Некоторые пользователи могут испытывать споры ресурсов, которые ограничивают параллелизм, который они ожидают, когда сборщик мусора не настроен должным образом.</span><span class="sxs-lookup"><span data-stu-id="a51a5-961">Some users might experience resource contention that limits the parallelism they are expecting when the Garbage Collector is not properly configured.</span></span> <span data-ttu-id="a51a5-962">Всякий раз, когда EF используется в многопоточном сценарии или в любом приложении, напоминающее серверную систему, убедитесь, что включите сбор мусора сервера.</span><span class="sxs-lookup"><span data-stu-id="a51a5-962">Whenever EF is used in a multithreaded scenario, or in any application that resembles a server-side system, make sure to enable Server Garbage Collection.</span></span> <span data-ttu-id="a51a5-963">Это делается с помощью простой настройки в файле конфигурации приложения:</span><span class="sxs-lookup"><span data-stu-id="a51a5-963">This is done via a simple setting in your application config file:</span></span>

``` xml
<?xmlversion="1.0" encoding="utf-8" ?>
<configuration>
        <runtime>
               <gcServer enabled="true" />
        </runtime>
</configuration>
```

<span data-ttu-id="a51a5-964">Это должно уменьшить спор потока и увеличить пропускную состав до 30% в сценариях насыщения процессора.</span><span class="sxs-lookup"><span data-stu-id="a51a5-964">This should decrease your thread contention and increase your throughput by up to 30% in CPU saturated scenarios.</span></span> <span data-ttu-id="a51a5-965">В общих чертах, вы всегда должны проверить, как ваше приложение ведет себя с помощью классической коллекции мусора (которая лучше настроить для сценариев uI и клиентской стороны), а также сбор мусора сервера.</span><span class="sxs-lookup"><span data-stu-id="a51a5-965">In general terms, you should always test how your application behaves using the classic Garbage Collection (which is better tuned for UI and client side scenarios) as well as the Server Garbage Collection.</span></span>

### <a name="92-autodetectchanges"></a><span data-ttu-id="a51a5-966">9.2 АвтоОбнаруживизменения</span><span class="sxs-lookup"><span data-stu-id="a51a5-966">9.2      AutoDetectChanges</span></span>

<span data-ttu-id="a51a5-967">Как упоминалось ранее, система entity Может отображать проблемы с производительностью, когда кэш объектов имеет много сущностей.</span><span class="sxs-lookup"><span data-stu-id="a51a5-967">As mentioned earlier, Entity Framework might show performance issues when the object cache has many entities.</span></span> <span data-ttu-id="a51a5-968">Некоторые операции, такие как Добавить, Удалить, Найти, Входе и СохранитьИзменения, вызывают вызовы для DetectChanges, которые могут потреблять большое количество процессора в зависимости от размера кэша объектов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-968">Certain operations, such as Add, Remove, Find, Entry and SaveChanges, trigger calls to DetectChanges which might consume a large amount of CPU based on how large the object cache has become.</span></span> <span data-ttu-id="a51a5-969">Причина этого заключается в том, что кэш объекта и диспетчер состояния объекта пытаются оставаться как можно более синхронизированными на каждой выполняемой операции в контексте, чтобы полученные данные были гарантированно корректны в широком спектре сценариев.</span><span class="sxs-lookup"><span data-stu-id="a51a5-969">The reason for this is that the object cache and the object state manager try to stay as synchronized as possible on each operation performed to a context so that the produced data is guaranteed to be correct under a wide array of scenarios.</span></span>

<span data-ttu-id="a51a5-970">Как правило, это хорошая практика, чтобы оставить автоматическое обнаружение изменений Entity Framework включенным на весь срок службы вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="a51a5-970">It is generally a good practice to leave Entity Framework’s automatic change detection enabled for the entire life of your application.</span></span> <span data-ttu-id="a51a5-971">Если на сценарий негативно влияет высокое использование процессора, а профили указывают на то, что виновником является вызов DetectChanges, подумайте о временном отключении AutoDetectChanges в чувствительной части кода:</span><span class="sxs-lookup"><span data-stu-id="a51a5-971">If your scenario is being negatively affected by high CPU usage and your profiles indicate that the culprit is the call to DetectChanges, consider temporarily turning off AutoDetectChanges in the sensitive portion of your code:</span></span>

``` csharp
try
{
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    ...
}
finally
{
    context.Configuration.AutoDetectChangesEnabled = true;
}
```

<span data-ttu-id="a51a5-972">Прежде чем отключить AutoDetectChanges, хорошо понять, что это может привести к потере возможности создавать возможности для отслеживания определенной информации об изменениях, происходящих на объектах.</span><span class="sxs-lookup"><span data-stu-id="a51a5-972">Before turning off AutoDetectChanges, it’s good to understand that this might cause Entity Framework to lose its ability to track certain information about the changes that are taking place on the entities.</span></span> <span data-ttu-id="a51a5-973">Если обработка обрабатывается неправильно, это может привести к несогласованности данных в приложении.</span><span class="sxs-lookup"><span data-stu-id="a51a5-973">If handled incorrectly, this might cause data inconsistency on your application.</span></span> <span data-ttu-id="a51a5-974">Для получения дополнительной информации о \< http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/>выключении AutoDetectChanges, читайте .</span><span class="sxs-lookup"><span data-stu-id="a51a5-974">For more information on turning off AutoDetectChanges, read \<http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/>.</span></span>

### <a name="93-context-per-request"></a><span data-ttu-id="a51a5-975">9.3 Контекст за запрос</span><span class="sxs-lookup"><span data-stu-id="a51a5-975">9.3      Context per request</span></span>

<span data-ttu-id="a51a5-976">Контексты Entity Framework предназначены для использования в качестве недолговечных экземпляров для обеспечения наиболее оптимального опыта работы.</span><span class="sxs-lookup"><span data-stu-id="a51a5-976">Entity Framework’s contexts are meant to be used as short-lived instances in order to provide the most optimal performance experience.</span></span> <span data-ttu-id="a51a5-977">Контексты, как ожидается, будут недолговечными и отбрасываются, и как таковые были реализованы, чтобы быть очень легкими и повторно использовать метаданные, когда это возможно.</span><span class="sxs-lookup"><span data-stu-id="a51a5-977">Contexts are expected to be short lived and discarded, and as such have been implemented to be very lightweight and reutilize metadata whenever possible.</span></span> <span data-ttu-id="a51a5-978">В веб-сценариях важно иметь это в виду и не иметь контекста больше, чем продолжительность одного запроса.</span><span class="sxs-lookup"><span data-stu-id="a51a5-978">In web scenarios it’s important to keep this in mind and not have a context for more than the duration of a single request.</span></span> <span data-ttu-id="a51a5-979">Аналогичным образом, в невеб-сценариях контекст должен быть отброшен на основе вашего понимания различных уровней кэширования в рамочной системе сущности.</span><span class="sxs-lookup"><span data-stu-id="a51a5-979">Similarly, in non-web scenarios, context should be discarded based on your understanding of the different levels of caching in the Entity Framework.</span></span> <span data-ttu-id="a51a5-980">Вообще говоря, следует избегать наличия контекста экземпляра на протяжении всего срока службы приложения, а также контекстов на поток и статические контексты.</span><span class="sxs-lookup"><span data-stu-id="a51a5-980">Generally speaking, one should avoid having a context instance throughout the life of the application, as well as contexts per thread and static contexts.</span></span>

### <a name="94-database-null-semantics"></a><span data-ttu-id="a51a5-981">9.4 Семантика базы данных нулевая</span><span class="sxs-lookup"><span data-stu-id="a51a5-981">9.4      Database null semantics</span></span>

<span data-ttu-id="a51a5-982">Система сущности по умолчанию будет\# генерировать код S'L, который имеет семантику сравнения C.</span><span class="sxs-lookup"><span data-stu-id="a51a5-982">Entity Framework by default will generate SQL code that has C\# null comparison semantics.</span></span> <span data-ttu-id="a51a5-983">Рассмотрим следующий запрос:</span><span class="sxs-lookup"><span data-stu-id="a51a5-983">Consider the following example query:</span></span>

``` csharp
            int? categoryId = 7;
            int? supplierId = 8;
            decimal? unitPrice = 0;
            short? unitsInStock = 100;
            short? unitsOnOrder = 20;
            short? reorderLevel = null;

            var q = from p incontext.Products
                    wherep.Category.CategoryName == "Beverages"
                          || (p.CategoryID == categoryId
                                || p.SupplierID == supplierId
                                || p.UnitPrice == unitPrice
                                || p.UnitsInStock == unitsInStock
                                || p.UnitsOnOrder == unitsOnOrder
                                || p.ReorderLevel == reorderLevel)
                    select p;

            var r = q.ToList();
```

<span data-ttu-id="a51a5-984">В этом примере мы сравниваем ряд недействительных переменных с необысданными свойствами на объекте, такими как SupplierID и UnitPrice.</span><span class="sxs-lookup"><span data-stu-id="a51a5-984">In this example, we’re comparing a number of nullable variables against nullable properties on the entity, such as SupplierID and UnitPrice.</span></span> <span data-ttu-id="a51a5-985">Сгенерированный СЗЛ для этого запроса спросит, является ли значение параметра таким же, как значение столбца, или если значение параметра и столбца являются нулевыми.</span><span class="sxs-lookup"><span data-stu-id="a51a5-985">The generated SQL for this query will ask if the parameter value is the same as the column value, or if both the parameter and the column values are null.</span></span> <span data-ttu-id="a51a5-986">Это скроет способ обработки сервера базы данных\# на нулевую информацию и обеспечит согласованный опыт C null для различных поставщиков баз данных.</span><span class="sxs-lookup"><span data-stu-id="a51a5-986">This will hide the way the database server handles nulls and will provide a consistent C\# null experience across different database vendors.</span></span> <span data-ttu-id="a51a5-987">С другой стороны, сгенерированный код немного запутан и может не работать хорошо, когда количество сравнений в том, где выписка запроса увеличивается до большого числа.</span><span class="sxs-lookup"><span data-stu-id="a51a5-987">On the other hand, the generated code is a bit convoluted and may not perform well when the amount of comparisons in the where statement of the query grows to a large number.</span></span>

<span data-ttu-id="a51a5-988">Одним из способов решения этой ситуации является использование семантики нулевой базы данных.</span><span class="sxs-lookup"><span data-stu-id="a51a5-988">One way to deal with this situation is by using database null semantics.</span></span> <span data-ttu-id="a51a5-989">Обратите внимание, что это потенциально может\# вести себя по-другому ссемантики C null, так как теперь система Entity Framework будет генерировать более простые S'L, что предоставляет способ обработки движка базы данных нулевыми значениями.</span><span class="sxs-lookup"><span data-stu-id="a51a5-989">Note that this might potentially behave differently to the C\# null semantics since now Entity Framework will generate simpler SQL that exposes the way the database engine handles null values.</span></span> <span data-ttu-id="a51a5-990">Семантика нулевой базы данных может быть активирована в контексте с одной строкой конфигурации в соответствии с конфигурацией контекста:</span><span class="sxs-lookup"><span data-stu-id="a51a5-990">Database null semantics can be activated per-context with one single configuration line against the context configuration:</span></span>

``` csharp
                context.Configuration.UseDatabaseNullSemantics = true;
```

<span data-ttu-id="a51a5-991">Малые и средние запросы не будут отображать заметное улучшение производительности при использовании нулевой семантики базы данных, но разница станет более заметной по запросам с большим количеством потенциальных сравнений нуля.</span><span class="sxs-lookup"><span data-stu-id="a51a5-991">Small to medium sized queries will not display a perceptible performance improvement when using database null semantics, but the difference will become more noticeable on queries with a large number of potential null comparisons.</span></span>

<span data-ttu-id="a51a5-992">В приведенном выше запросе разница в производительности составила менее 2% в микробенчмарке, работаемом в контролируемой среде.</span><span class="sxs-lookup"><span data-stu-id="a51a5-992">In the example query above, the performance difference was less than 2% in a microbenchmark running in a controlled environment.</span></span>

### <a name="95-async"></a><span data-ttu-id="a51a5-993">9.5 Асин</span><span class="sxs-lookup"><span data-stu-id="a51a5-993">9.5      Async</span></span>

<span data-ttu-id="a51a5-994">Система сущности 6 ввела поддержку операций async при работе на .NET 4.5 или позже.</span><span class="sxs-lookup"><span data-stu-id="a51a5-994">Entity Framework 6 introduced support of async operations when running on .NET 4.5 or later.</span></span> <span data-ttu-id="a51a5-995">По большей части приложения, имеющие спор, связанный с IO, получат наибольшую выгоду от использования асинхронного запроса и сохранения операций.</span><span class="sxs-lookup"><span data-stu-id="a51a5-995">For the most part, applications that have IO related contention will benefit the most from using asynchronous query and save operations.</span></span> <span data-ttu-id="a51a5-996">Если ваша заявка не страдает от спора с IO, использование async в лучшем случае будет работать синхронно и возвращает результат в такое же количество времени, как синхронный вызов, или в худшем случае, просто отложить выполнение к асинхронной задаче и добавить дополнительное время к завершению вашего сценария.</span><span class="sxs-lookup"><span data-stu-id="a51a5-996">If your application does not suffer from IO contention, the use of async will, in the best cases, run synchronously and return the result in the same amount of time as a synchronous call, or in the worst case, simply defer execution to an asynchronous task and add extra time to the completion of your scenario.</span></span>

<span data-ttu-id="a51a5-997">Для получения информации о том, как работает асинхронное программирование, [http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx)которое поможет вам решить, улучшит ли async производительность вашего посещения приложения.</span><span class="sxs-lookup"><span data-stu-id="a51a5-997">For information on how asynchronous programming work that will help you deciding if async will improve the performance of your application visit [http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx).</span></span> <span data-ttu-id="a51a5-998">Для получения дополнительной информации об использовании операций async в рамках entity, [см.](~/ef6/fundamentals/async.md
)</span><span class="sxs-lookup"><span data-stu-id="a51a5-998">For more information on the use of async operations on Entity Framework, see [Async Query and Save](~/ef6/fundamentals/async.md
).</span></span>

### <a name="96-ngen"></a><span data-ttu-id="a51a5-999">9.6 NGEN</span><span class="sxs-lookup"><span data-stu-id="a51a5-999">9.6      NGEN</span></span>

<span data-ttu-id="a51a5-1000">Система Сущности 6 не приходит в установку по умолчанию фреза .NET.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1000">Entity Framework 6 does not come in the default installation of .NET framework.</span></span> <span data-ttu-id="a51a5-1001">Таким образом, сборки рамок сущности не являются NGEN'd по умолчанию, что означает, что весь фреймворк entity подлежит той же стоимости JIT'ing, что и любая другая сборка MSIL.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1001">As such, the Entity Framework assemblies are not NGEN’d by default which means that all the Entity Framework code is subject to the same JIT’ing costs as any other MSIL assembly.</span></span> <span data-ttu-id="a51a5-1002">Это может ухудшить опыт F5 при разработке, а также холодный запуск вашего приложения в производственных средах.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1002">This might degrade the F5 experience while developing and also the cold startup of your application in the production environments.</span></span> <span data-ttu-id="a51a5-1003">Для того, чтобы уменьшить стоимость процессора и памяти JIT'ing, рекомендуется NGEN Изображения Entity Framework по мере необходимости.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1003">In order to reduce the CPU and memory costs of JIT’ing it is advisable to NGEN the Entity Framework images as appropriate.</span></span> <span data-ttu-id="a51a5-1004">Для получения дополнительной информации о том, как улучшить производительность запуска Entity Framework 6 с NGEN, [см.](~/ef6/fundamentals/performance/ngen.md)</span><span class="sxs-lookup"><span data-stu-id="a51a5-1004">For more information on how to improve the startup performance of Entity Framework 6 with NGEN, see [Improving Startup Performance with NGen](~/ef6/fundamentals/performance/ngen.md).</span></span>

### <a name="97-code-first-versus-edmx"></a><span data-ttu-id="a51a5-1005">9.7 Код первый против EDMX</span><span class="sxs-lookup"><span data-stu-id="a51a5-1005">9.7      Code First versus EDMX</span></span>

<span data-ttu-id="a51a5-1006">Рамки сущности причины о проблеме несоответствия impedance между объектно-ориентированным программированием и реляционными базами данных, имея в памяти представление концептуальной модели (объектов), схему хранения (база данных) и отображение между ними.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1006">Entity Framework reasons about the impedance mismatch problem between object oriented programming and relational databases by having an in-memory representation of the conceptual model (the objects), the storage schema (the database) and a mapping between the two.</span></span> <span data-ttu-id="a51a5-1007">Эти метаданные называются моделью данных сущности, или EDM для краткости.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1007">This metadata is called an Entity Data Model, or EDM for short.</span></span> <span data-ttu-id="a51a5-1008">Из этого EDM, Entity Framework будет получать представления для данных туда и обратно от объектов в памяти в базу данных и обратно.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1008">From this EDM, Entity Framework will derive the views to roundtrip data from the objects in memory to the database and back.</span></span>

<span data-ttu-id="a51a5-1009">Когда система Entity Framework используется с файлом EDMX, который формально определяет концептуальную модель, схему хранения и отображение, то этап загрузки модели должен только подтвердить, что EDM является правильным (например, убедитесь, что нет отображения отсутствуют), затем генерировать представления, а затем проверить представления и иметь эти метаданные готовы к использованию.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1009">When Entity Framework is used with an EDMX file that formally specifies the conceptual model, the storage schema, and the mapping, then the model loading stage only has to validate that the EDM is correct (for example, make sure that no mappings are missing), then generate the views, then validate the views and have this metadata ready for use.</span></span> <span data-ttu-id="a51a5-1010">Только после этого можно выполнить запрос или сохранить новые данные в хранилище данных.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1010">Only then can a query be executed or new data be saved to the data store.</span></span>

<span data-ttu-id="a51a5-1011">Подход Code First по своей сути является сложным генератором модели данных Entity.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1011">The Code First approach is, at its heart, a sophisticated Entity Data Model generator.</span></span> <span data-ttu-id="a51a5-1012">Рамочная система должна производить EDM из предоставленного кода; он делает это путем анализа классов, участвующих в модели, применения конвенций и настройки модели через Fluent API.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1012">The Entity Framework has to produce an EDM from the provided code; it does so by analyzing the classes involved in the model, applying conventions and configuring the model via the Fluent API.</span></span> <span data-ttu-id="a51a5-1013">После построения EDM структура entity по существу ведет себя так же, как и файл EDMX в проекте.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1013">After the EDM is built, the Entity Framework essentially behaves the same way as it would had an EDMX file been present in the project.</span></span> <span data-ttu-id="a51a5-1014">Таким образом, построение модели с Code First добавляет дополнительную сложность, что приводит к более медленному времени запуска для Рамочной системы сущности по сравнению с EDMX.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1014">Thus, building the model from Code First adds extra complexity that translates into a slower startup time for the Entity Framework when compared to having an EDMX.</span></span> <span data-ttu-id="a51a5-1015">Стоимость полностью зависит от размера и сложности модели, которая строится.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1015">The cost is completely dependent on the size and complexity of the model that’s being built.</span></span>

<span data-ttu-id="a51a5-1016">При выборе использования EDMX против Code First важно знать, что гибкость, введенная Code First, увеличивает стоимость создания модели впервые.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1016">When choosing to use EDMX versus Code First, it’s important to know that the flexibility introduced by Code First increases the cost of building the model for the first time.</span></span> <span data-ttu-id="a51a5-1017">Если ваше приложение может выдержать стоимость этой первой нагрузки, то обычно Code First будет предпочтительным способом.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1017">If your application can withstand the cost of this first-time load then typically Code First will be the preferred way to go.</span></span>

## <a name="10-investigating-performance"></a><span data-ttu-id="a51a5-1018">10 Исследование производительности</span><span class="sxs-lookup"><span data-stu-id="a51a5-1018">10 Investigating Performance</span></span>

### <a name="101-using-the-visual-studio-profiler"></a><span data-ttu-id="a51a5-1019">10.1 Использование визуальной студии Профилер</span><span class="sxs-lookup"><span data-stu-id="a51a5-1019">10.1 Using the Visual Studio Profiler</span></span>

<span data-ttu-id="a51a5-1020">Если у вас возникли проблемы с производительностью с рамочным образованием, вы можете использовать профайлер, как тот, который встроен в Visual Studio, чтобы увидеть, где ваше приложение тратит свое время.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1020">If you are having performance issues with the Entity Framework, you can use a profiler like the one built into Visual Studio to see where your application is spending its time.</span></span> <span data-ttu-id="a51a5-1021">Это инструмент, который мы использовали для создания круговых диаграмм в "Изучение производительности ADO.NET \< https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1>) Entity Framework - Часть 1" блога (которые показывают, где Entity Framework проводит свое время во время холодных и теплых запросов.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1021">This is the tool we used to generate the pie charts in the “Exploring the Performance of the ADO.NET Entity Framework - Part 1” blog post ( \<https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1>) that show where Entity Framework spends its time during cold and warm queries.</span></span>

<span data-ttu-id="a51a5-1022">В блоге "Профилирование entity Framework с использованием Visual Studio 2010 Profiler", написанном Консультативной группой по обработке данных и моделированию, показан реальный пример того, как они использовали профайлер для расследования проблемы производительности.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1022">The "Profiling Entity Framework using the Visual Studio 2010 Profiler" blog post written by the Data and Modeling Customer Advisory Team shows a real-world example of how they used the profiler to investigate a performance problem.</span></span><span data-ttu-id="a51a5-1023">\<https://docs.microsoft.com/archive/blogs/dmcat/profiling-entity-framework-using-the-visual-studio-2010-profiler>.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1023">  \<https://docs.microsoft.com/archive/blogs/dmcat/profiling-entity-framework-using-the-visual-studio-2010-profiler>.</span></span> <span data-ttu-id="a51a5-1024">Этот пост был написан для приложения окна.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1024">This post was written for a windows application.</span></span> <span data-ttu-id="a51a5-1025">Если вам нужно профиль веб-приложения Windows Performance Recorder (WPR) и Windows Performance Analyzer (WPA) инструменты могут работать лучше, чем работа с Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1025">If you need to profile a web application the Windows Performance Recorder (WPR) and Windows Performance Analyzer (WPA) tools may work better than working from Visual Studio.</span></span> <span data-ttu-id="a51a5-1026">WPR и WPA являются частью инструментария производительности Windows, который [http://www.microsoft.com/download/details.aspx?id=39982](https://www.microsoft.com/download/details.aspx?id=39982)включен в комплект для оценки и развертывания Windows ().</span><span class="sxs-lookup"><span data-stu-id="a51a5-1026">WPR and WPA are part of the Windows Performance Toolkit which is included with the Windows Assessment and Deployment Kit ( [http://www.microsoft.com/download/details.aspx?id=39982](https://www.microsoft.com/download/details.aspx?id=39982)).</span></span>

### <a name="102-applicationdatabase-profiling"></a><span data-ttu-id="a51a5-1027">10.2 Профилирование приложений/базы данных</span><span class="sxs-lookup"><span data-stu-id="a51a5-1027">10.2 Application/Database profiling</span></span>

<span data-ttu-id="a51a5-1028">Такие инструменты, как профайлер, встроенный в Visual Studio, говорят вам, где ваше приложение проводит время.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1028">Tools like the profiler built into Visual Studio tell you where your application is spending time.</span></span><span data-ttu-id="a51a5-1029">Доступен другой тип профилировщика, который выполняет динамический анализ вашего запущенного приложения, как в производстве, так и в предсерийном производстве в зависимости от потребностей, и ищет общие подводные камни и антишаблоны доступа к базе данных.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1029">  Another type of profiler is available that performs dynamic analysis of your running application, either in production or pre-production depending on needs, and looks for common pitfalls and anti-patterns of database access.</span></span>

<span data-ttu-id="a51a5-1030">Два коммерчески доступных профайлера являются \< http://efprof.com>) Entity Framework Profiler ( и ORMProfiler ( \< http://ormprofiler.com>).</span><span class="sxs-lookup"><span data-stu-id="a51a5-1030">Two commercially available profilers are the Entity Framework Profiler ( \<http://efprof.com>) and ORMProfiler ( \<http://ormprofiler.com>).</span></span>

<span data-ttu-id="a51a5-1031">Если приложение является приложением MVC с использованием Code First, вы можете использовать MiniProfiler StackExchange.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1031">If your application is an MVC application using Code First, you can use StackExchange's MiniProfiler.</span></span> <span data-ttu-id="a51a5-1032">Скотт Hanselman описывает этот инструмент \< http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx>в своем блоге на: .</span><span class="sxs-lookup"><span data-stu-id="a51a5-1032">Scott Hanselman describes this tool in his blog at: \<http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx>.</span></span>

<span data-ttu-id="a51a5-1033">Для получения дополнительной информации о профилировании деятельности базы данных вашего приложения, см. [Profiling Database Activity in the Entity Framework](https://msdn.microsoft.com/magazine/gg490349.aspx)</span><span class="sxs-lookup"><span data-stu-id="a51a5-1033">For more information on profiling your application's database activity, see Julie Lerman's MSDN Magazine article titled [Profiling Database Activity in the Entity Framework](https://msdn.microsoft.com/magazine/gg490349.aspx).</span></span>

### <a name="103-database-logger"></a><span data-ttu-id="a51a5-1034">10.3 Регистратор баз данных</span><span class="sxs-lookup"><span data-stu-id="a51a5-1034">10.3 Database logger</span></span>

<span data-ttu-id="a51a5-1035">Если вы используете Entity Framework 6, также рассмотрите возможность использования встроенной функциональности ведения журнала.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1035">If you are using Entity Framework 6 also consider using the built-in logging functionality.</span></span> <span data-ttu-id="a51a5-1036">Свойство контекста базы данных может быть проинструктировано регистрировать свою деятельность с помощью простой одностроковой конфигурации:</span><span class="sxs-lookup"><span data-stu-id="a51a5-1036">The Database property of the context can be instructed to log its activity via a simple one-line configuration:</span></span>

``` csharp
    using (var context = newQueryComparison.DbC.NorthwindEntities())
    {
        context.Database.Log = Console.WriteLine;
        var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
        q.ToList();
    }
```

<span data-ttu-id="a51a5-1037">В этом примере действие базы данных будет зарегистрировано на консоль, но&lt;&gt; свойство журнала может быть настроено для вызова любого делегата строки действий.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1037">In this example the database activity will be logged to the console, but the Log property can be configured to call any Action&lt;string&gt; delegate.</span></span>

<span data-ttu-id="a51a5-1038">Если вы хотите включить журнал данных без перекомпиляции, и вы используете Entity Framework 6.1 или позже, вы можете сделать это, добавив перехватчик в web.config или файл app.config вашего приложения.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1038">If you want to enable database logging without recompiling, and you are using Entity Framework 6.1 or later, you can do so by adding an interceptor in the web.config or app.config file of your application.</span></span>

``` xml
  <interceptors>
    <interceptor type="System.Data.Entity.Infrastructure.Interception.DatabaseLogger, EntityFramework">
      <parameters>
        <parameter value="C:\Path\To\My\LogOutput.txt"/>
      </parameters>
    </interceptor>
  </interceptors>
```

<span data-ttu-id="a51a5-1039">Для получения дополнительной информации о том, \< http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/>как добавить журнал без перекомпиляции перейдите на .</span><span class="sxs-lookup"><span data-stu-id="a51a5-1039">For more information on how to add logging without recompiling go to \<http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/>.</span></span>

## <a name="11-appendix"></a><span data-ttu-id="a51a5-1040">11 Приложение</span><span class="sxs-lookup"><span data-stu-id="a51a5-1040">11 Appendix</span></span>

### <a name="111-a-test-environment"></a><span data-ttu-id="a51a5-1041">11.1 A. Тестовая среда</span><span class="sxs-lookup"><span data-stu-id="a51a5-1041">11.1 A. Test Environment</span></span>

<span data-ttu-id="a51a5-1042">Эта среда использует 2-автоматную настройку с базой данных на отдельной машине от клиентского приложения.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1042">This environment uses a 2-machine setup with the database on a separate machine from the client application.</span></span> <span data-ttu-id="a51a5-1043">Машины находятся в одной стойке, поэтому задержка сети относительно низка, но более реалистична, чем одномашинная среда.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1043">Machines are in the same rack, so network latency is relatively low, but more realistic than a single-machine environment.</span></span>

#### <a name="1111-app-server"></a><span data-ttu-id="a51a5-1044">11.1.1 App Server</span><span class="sxs-lookup"><span data-stu-id="a51a5-1044">11.1.1       App Server</span></span>

##### <a name="11111-software-environment"></a><span data-ttu-id="a51a5-1045">11.1.1.1 Программное обеспечение</span><span class="sxs-lookup"><span data-stu-id="a51a5-1045">11.1.1.1      Software Environment</span></span>

-   <span data-ttu-id="a51a5-1046">Сущность Рамочная 4 Среда программного обеспечения</span><span class="sxs-lookup"><span data-stu-id="a51a5-1046">Entity Framework 4 Software Environment</span></span>
    -   <span data-ttu-id="a51a5-1047">Название ОС: Windows Server 2008 R2 Enterprise SP1.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1047">OS Name: Windows Server 2008 R2 Enterprise SP1.</span></span>
    -   <span data-ttu-id="a51a5-1048">Визуальная студия 2010 - Ultimate.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1048">Visual Studio 2010 – Ultimate.</span></span>
    -   <span data-ttu-id="a51a5-1049">Visual Studio 2010 SP1 (только для некоторых сравнений).</span><span class="sxs-lookup"><span data-stu-id="a51a5-1049">Visual Studio 2010 SP1 (only for some comparisons).</span></span>
-   <span data-ttu-id="a51a5-1050">Система сущности 5 и 6 Программная среда</span><span class="sxs-lookup"><span data-stu-id="a51a5-1050">Entity Framework 5 and 6 Software Environment</span></span>
    -   <span data-ttu-id="a51a5-1051">Имя ОС: Windows 8.1 Предприятие</span><span class="sxs-lookup"><span data-stu-id="a51a5-1051">OS Name: Windows 8.1 Enterprise</span></span>
    -   <span data-ttu-id="a51a5-1052">Визуальная студия 2013 - Ultimate.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1052">Visual Studio 2013 – Ultimate.</span></span>

##### <a name="11112-hardware-environment"></a><span data-ttu-id="a51a5-1053">11.1.1.2 Аппаратная среда</span><span class="sxs-lookup"><span data-stu-id="a51a5-1053">11.1.1.2      Hardware Environment</span></span>

-   <span data-ttu-id="a51a5-1054">Двойной процессор: Intel (R) Xeon (R) процессор L5520 W3530 2,27 ГГц, 2261 ГГц, 4 Core (ы), 84 Логический процессор (ы).</span><span class="sxs-lookup"><span data-stu-id="a51a5-1054">Dual Processor:     Intel(R) Xeon(R) CPU L5520 W3530 @ 2.27GHz, 2261 Mhz8 GHz, 4 Core(s), 84 Logical Processor(s).</span></span>
-   <span data-ttu-id="a51a5-1055">2412 ГБ RamRAM.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1055">2412 GB RamRAM.</span></span>
-   <span data-ttu-id="a51a5-1056">136 ГБ SCSI250 ГБ SATA 7200 об/мин 3 ГБ/с привода разделены на 4 перегородки.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1056">136 GB SCSI250GB SATA 7200 rpm 3GB/s drive split into 4 partitions.</span></span>

#### <a name="1112-db-server"></a><span data-ttu-id="a51a5-1057">11.1.2 DB-сервер</span><span class="sxs-lookup"><span data-stu-id="a51a5-1057">11.1.2       DB server</span></span>

##### <a name="11121-software-environment"></a><span data-ttu-id="a51a5-1058">11.1.2.1 Программная среда</span><span class="sxs-lookup"><span data-stu-id="a51a5-1058">11.1.2.1      Software Environment</span></span>

-   <span data-ttu-id="a51a5-1059">Имя ОС: Windows Server 2008 R28.1 Предприятие SP1.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1059">OS Name: Windows Server 2008 R28.1 Enterprise SP1.</span></span>
-   <span data-ttu-id="a51a5-1060">Сервер S'L 2008 R22012.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1060">SQL Server 2008 R22012.</span></span>

##### <a name="11122-hardware-environment"></a><span data-ttu-id="a51a5-1061">11.1.2.2 Аппаратная среда</span><span class="sxs-lookup"><span data-stu-id="a51a5-1061">11.1.2.2      Hardware Environment</span></span>

-   <span data-ttu-id="a51a5-1062">Единый процессор: Intel (R) Xeon (R) процессор L5520 2,27 ГГц, 2261 МГц-1620 0 - 3,60 ГГц, 4 Ядра (ы), 8 Логический процессор (ы).</span><span class="sxs-lookup"><span data-stu-id="a51a5-1062">Single Processor: Intel(R) Xeon(R) CPU L5520  @ 2.27GHz, 2261 MhzES-1620 0 @ 3.60GHz, 4 Core(s), 8 Logical Processor(s).</span></span>
-   <span data-ttu-id="a51a5-1063">824 ГБ RamRAM.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1063">824 GB RamRAM.</span></span>
-   <span data-ttu-id="a51a5-1064">465 ГБ ATA500GB SATA 7200 об/мин 6 ГБ/с диска разделены на 4 перегородки.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1064">465 GB ATA500GB SATA 7200 rpm 6GB/s drive split into 4 partitions.</span></span>

### <a name="112-b-query-performance-comparison-tests"></a><span data-ttu-id="a51a5-1065">11.2 B. Сравнительные тесты на производительность запросов</span><span class="sxs-lookup"><span data-stu-id="a51a5-1065">11.2      B. Query performance comparison tests</span></span>

<span data-ttu-id="a51a5-1066">Для выполнения этих тестов использовалась модель Northwind.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1066">The Northwind model was used to execute these tests.</span></span> <span data-ttu-id="a51a5-1067">Она была создана из базы данных с помощью конструктора Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1067">It was generated from the database using the Entity Framework designer.</span></span> <span data-ttu-id="a51a5-1068">Затем для сравнения производительности вариантов выполнения запроса был использован следующий код:</span><span class="sxs-lookup"><span data-stu-id="a51a5-1068">Then, the following code was used to compare the performance of the query execution options:</span></span>

``` csharp
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.Entity.Infrastructure;
using System.Data.EntityClient;
using System.Data.Objects;
using System.Linq;

namespace QueryComparison
{
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
                );

        public IQueryable<Product> InvokeProductsForCategoryCQ(string categoryName)
        {
            return productsForCategoryCQ(this, categoryName);
        }
    }

    public class QueryTypePerfComparison
    {
        private static string entityConnectionStr = @"metadata=res://*/Northwind.csdl|res://*/Northwind.ssdl|res://*/Northwind.msl;provider=System.Data.SqlClient;provider connection string='data source=.;initial catalog=Northwind;integrated security=True;multipleactiveresultsets=True;App=EntityFramework'";

        public void LINQIncludingContextCreation()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTracking()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                context.Products.MergeOption = MergeOption.NoTracking;

                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void CompiledQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                var q = context.InvokeProductsForCategoryCQ("Beverages");
                q.ToList();
            }
        }

        public void ObjectQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
                products.ToList();
            }
        }

        public void EntityCommand()
        {
            using (EntityConnection eConn = new EntityConnection(entityConnectionStr))
            {
                eConn.Open();
                EntityCommand cmd = eConn.CreateCommand();
                cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

                using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
                {
                    List<Product> productsList = new List<Product>();
                    while (reader.Read())
                    {
                        DbDataRecord record = (DbDataRecord)reader.GetValue(0);

                        // 'materialize' the product by accessing each field and value. Because we are materializing products, we won't have any nested data readers or records.
                        int fieldCount = record.FieldCount;

                        // Treat all products as Product, even if they are the subtype DiscontinuedProduct.
                        Product product = new Product();  

                        product.ProductID = record.GetInt32(0);
                        product.ProductName = record.GetString(1);
                        product.SupplierID = record.GetInt32(2);
                        product.CategoryID = record.GetInt32(3);
                        product.QuantityPerUnit = record.GetString(4);
                        product.UnitPrice = record.GetDecimal(5);
                        product.UnitsInStock = record.GetInt16(6);
                        product.UnitsOnOrder = record.GetInt16(7);
                        product.ReorderLevel = record.GetInt16(8);
                        product.Discontinued = record.GetBoolean(9);

                        productsList.Add(product);
                    }
                }
            }
        }

        public void ExecuteStoreQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectResult<Product> beverages = context.ExecuteStoreQuery<Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Database.SqlQuery\<QueryComparison.DbC.Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbSet()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Products.SqlQuery(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void LINQIncludingContextCreationDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTrackingDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var q = context.Products.AsNoTracking().Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }
    }
}
```

### <a name="113-c-navision-model"></a><span data-ttu-id="a51a5-1069">11.3 C. Модель Navision</span><span class="sxs-lookup"><span data-stu-id="a51a5-1069">11.3 C. Navision Model</span></span>

<span data-ttu-id="a51a5-1070">База данных Navision — это большая база данных, используемая для демонстрации Microsoft Dynamics - NAV.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1070">The Navision database is a large database used to demo Microsoft Dynamics – NAV.</span></span> <span data-ttu-id="a51a5-1071">Генерируемая концептуальная модель содержит 1005 наборов сущностей и 4227 наборов ассоциаций.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1071">The generated conceptual model contains 1005 entity sets and 4227 association sets.</span></span> <span data-ttu-id="a51a5-1072">Модель, используемая в тесте, является "плоской" - к ней не добавлено наследование.</span><span class="sxs-lookup"><span data-stu-id="a51a5-1072">The model used in the test is “flat” – no inheritance has been added to it.</span></span>

#### <a name="1131-queries-used-for-navision-tests"></a><span data-ttu-id="a51a5-1073">11.3.1 Запросы, используемые для тестов Navision</span><span class="sxs-lookup"><span data-stu-id="a51a5-1073">11.3.1 Queries used for Navision tests</span></span>

<span data-ttu-id="a51a5-1074">Список запросов, используемый в модели Navision, содержит 3 категории запросов Entity S'L:</span><span class="sxs-lookup"><span data-stu-id="a51a5-1074">The queries list used with the Navision model contains 3 categories of Entity SQL queries:</span></span>

##### <a name="11311-lookup"></a><span data-ttu-id="a51a5-1075">11.3.1.1 Поиск</span><span class="sxs-lookup"><span data-stu-id="a51a5-1075">11.3.1.1 Lookup</span></span>

<span data-ttu-id="a51a5-1076">Простой запрос поиска без агрегаций</span><span class="sxs-lookup"><span data-stu-id="a51a5-1076">A simple lookup query with no aggregations</span></span>

-   <span data-ttu-id="a51a5-1077">Количество голосов: 16232</span><span class="sxs-lookup"><span data-stu-id="a51a5-1077">Count: 16232</span></span>
-   <span data-ttu-id="a51a5-1078">Пример</span><span class="sxs-lookup"><span data-stu-id="a51a5-1078">Example:</span></span>

``` xml
  <Query complexity="Lookup">
    <CommandText>Select value distinct top(4) e.Idle_Time From NavisionFKContext.Session as e</CommandText>
  </Query>
```

##### <a name="11312singleaggregating"></a><span data-ttu-id="a51a5-1079">11.3.1.2 Одноразовие</span><span class="sxs-lookup"><span data-stu-id="a51a5-1079">11.3.1.2 SingleAggregating</span></span>

<span data-ttu-id="a51a5-1080">Обычный запрос BI с несколькими агрегатами, но без субтоталов (один запрос)</span><span class="sxs-lookup"><span data-stu-id="a51a5-1080">A normal BI query with multiple aggregations, but no subtotals (single query)</span></span>

-   <span data-ttu-id="a51a5-1081">Количество голосов: 2313</span><span class="sxs-lookup"><span data-stu-id="a51a5-1081">Count: 2313</span></span>
-   <span data-ttu-id="a51a5-1082">Пример</span><span class="sxs-lookup"><span data-stu-id="a51a5-1082">Example:</span></span>

``` xml
  <Query complexity="SingleAggregating">
    <CommandText>NavisionFK.MDF_SessionLogin_Time_Max()</CommandText>
  </Query>
```

<span data-ttu-id="a51a5-1083">Где MDF\_SessionLogin\_Время\_Макс () определяется в модели как:</span><span class="sxs-lookup"><span data-stu-id="a51a5-1083">Where MDF\_SessionLogin\_Time\_Max() is defined in the model as:</span></span>

``` xml
  <Function Name="MDF_SessionLogin_Time_Max" ReturnType="Collection(DateTime)">
    <DefiningExpression>SELECT VALUE Edm.Min(E.Login_Time) FROM NavisionFKContext.Session as E</DefiningExpression>
  </Function>
```

##### <a name="11313aggregatingsubtotals"></a><span data-ttu-id="a51a5-1084">11.3.1.3 Агрегатора</span><span class="sxs-lookup"><span data-stu-id="a51a5-1084">11.3.1.3 AggregatingSubtotals</span></span>

<span data-ttu-id="a51a5-1085">Запрос BI с агрегатами и субтоталами (через союз все)</span><span class="sxs-lookup"><span data-stu-id="a51a5-1085">A BI query with aggregations and subtotals (via union all)</span></span>

-   <span data-ttu-id="a51a5-1086">Количество голосов: 178</span><span class="sxs-lookup"><span data-stu-id="a51a5-1086">Count: 178</span></span>
-   <span data-ttu-id="a51a5-1087">Пример</span><span class="sxs-lookup"><span data-stu-id="a51a5-1087">Example:</span></span>

``` xml
  <Query complexity="AggregatingSubtotals">
    <CommandText>
using NavisionFK;
function AmountConsumed(entities Collection([CRONUS_International_Ltd__Zone])) as
(
    Edm.Sum(select value N.Block_Movement FROM entities as E, E.CRONUS_International_Ltd__Bin as N)
)
function AmountConsumed(P1 Edm.Int32) as
(
    AmountConsumed(select value e from NavisionFKContext.CRONUS_International_Ltd__Zone as e where e.Zone_Ranking = P1)
)
----------------------------------------------------------------------------------------------------------------------
(
    select top(10) Zone_Ranking, Cross_Dock_Bin_Zone, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking, E.Cross_Dock_Bin_Zone
)
union all
(
    select top(10) Zone_Ranking, Cast(null as Edm.Byte) as P2, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking
)
union all
{
    Row(Cast(null as Edm.Int32) as P1, Cast(null as Edm.Byte) as P2, AmountConsumed(select value E
                                                                         from NavisionFKContext.CRONUS_International_Ltd__Zone as E
                                                                         where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed))
}</CommandText>
    <Parameters>
      <Parameter Name="MinAmountConsumed" DbType="Int32" Value="10000" />
    </Parameters>
  </Query>
```
