---
title: Рекомендации по производительности для EF4, EF5 и EF6-EF6
description: Рекомендации по производительности для Entity Framework 4, 5 и 6
author: divega
ms.date: 10/23/2016
uid: ef6/fundamentals/performance/perf-whitepaper
ms.openlocfilehash: 65584382df3d510f314a576f41c5dee3d2e718e7
ms.sourcegitcommit: abda0872f86eefeca191a9a11bfca976bc14468b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/14/2020
ms.locfileid: "90070540"
---
# <a name="performance-considerations-for-ef-4-5-and-6"></a>Вопросы производительности для EF 4, 5 и 6
Дэвид Обандо, Деттинжер и др.

Опубликовано: Апрель 2012

Последнее обновление: май 2014

------------------------------------------------------------------------

## <a name="1-introduction"></a>1. Введение

Объектно-реляционные платформы сопоставления — это удобный способ предоставления абстракции для доступа к данным в объектно-ориентированном приложении. Для приложений .NET рекомендуемый для корпорации Майкрософт объект O/RM Entity Framework. Однако при любой абстракции производительность может стать проблемой.

В этом техническом документе были написаны рекомендации по повышению производительности при разработке приложений с помощью Entity Framework, чтобы дать разработчикам представление о внутренних алгоритмах Entity Framework, которые могут повлиять на производительность, и предоставить советы по исследованию и повышению производительности в приложениях, использующих Entity Framework. Существует ряд хороших подразделов о производительности, уже доступных в Интернете, и мы также попытались указать эти ресурсы там, где это возможно.

Производительность — это несложная тема. Этот технический документ является ресурсом, помогающим принимать решения, связанные с производительностью приложений, использующих Entity Framework. Мы включили некоторые метрики тестирования, чтобы продемонстрировать производительность, но эти метрики не предназначены как абсолютные индикаторы производительности, которые будут отображаться в приложении.

Для практического использования в этом документе предполагается, что Entity Framework 4 работает в .NET 4,0, а Entity Framework 5 и 6 — в .NET 4,5. Многие улучшения производительности, производимые для Entity Framework 5, находятся в основных компонентах, поставляемых с .NET 4,5.

Entity Framework 6 является выпуском аппаратного контроллера управления и не зависит от компонентов Entity Framework, поставляемых с .NET. Entity Framework 6 работает как с .NET 4,0, так и с .NET 4,5, и может обеспечить значительное повышение производительности для тех, кто не обновлялся с версии .NET 4,0, но в приложении должны быть новейшие Entity Frameworkные биты. Когда в этом документе упоминается Entity Framework 6, он ссылается на последнюю версию, доступную на момент написания статьи: Version 6.1.0.

## <a name="2-cold-vs-warm-query-execution"></a>2. холодное и теплое выполнение запросов

При первом выполнении любого запроса к данной модели Entity Framework выполняет массу работы в фоновом режиме для загрузки и проверки модели. Этот первый запрос часто упоминается как «холодный» запрос.Дальнейшие запросы к уже загруженной модели называются «горячими» запросами и выполняются гораздо быстрее.

Давайте взглянем на обобщенное представление времени, затрачиваемого на выполнение запроса с помощью Entity Framework, и Узнайте, где можно улучшить Entity Framework 6.

**Выполнение первого запроса — холодный запрос**

| Написание кода для пользователя                                                                                     | Действие                    | Влияние EF4 производительности на производительность                                                                                                                                                                                                                                                                                                                                                                                                        | Влияние EF5 производительности на производительность                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Влияние EF6 производительности на производительность                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | Создание контекста          | Средн.                                                                                                                                                                                                                                                                                                                                                                                                                        | Средний                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | Создание выражения запроса | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                           | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var c1 = q1.First();`                                                                             | Выполнение запросов LINQ      | — Загрузка метаданных: высокая, но кэшированная <br/> — Создание представления: потенциально очень высокое, но кэшированное <br/> -Вычисление параметров: средний <br/> -Перевод запроса: средний <br/> — Создание материализации: средний, но кэшированный <br/> -Выполнение запроса к базе данных: потенциально высокое <br/> + Connection. Open <br/> + Command.ExeКутереадер <br/> + DataReader. Read <br/> Материализация объекта: средний <br/> — Поиск удостоверения: средний | — Загрузка метаданных: высокая, но кэшированная <br/> — Создание представления: потенциально очень высокое, но кэшированное <br/> -Вычисление параметров: низкое <br/> -Перевод запроса: средний, но кэшированный <br/> — Создание материализации: средний, но кэшированный <br/> Выполнение запроса к базе данных: потенциально высокое (более удачные запросы в некоторых ситуациях) <br/> + Connection. Open <br/> + Command.ExeКутереадер <br/> + DataReader. Read <br/> Материализация объекта: средний <br/> — Поиск удостоверения: средний | — Загрузка метаданных: высокая, но кэшированная <br/> — Создание представления: средний, но кэшированный <br/> -Вычисление параметров: низкое <br/> -Перевод запроса: средний, но кэшированный <br/> — Создание материализации: средний, но кэшированный <br/> Выполнение запроса к базе данных: потенциально высокое (более удачные запросы в некоторых ситуациях) <br/> + Connection. Open <br/> + Command.ExeКутереадер <br/> + DataReader. Read <br/> Материализация объекта: средний (быстрее, чем EF5) <br/> — Поиск удостоверения: средний |
| `}`                                                                                                  | Подключение. закрыть          | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                           | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |


**Выполнение второго запроса — горячий запрос**

| Написание кода для пользователя                                                                                     | Действие                    | Влияние EF4 производительности на производительность                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Влияние EF5 производительности на производительность                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Влияние EF6 производительности на производительность                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | Создание контекста          | Средн.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Средний                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | Создание выражения запроса | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var c1 = q1.First();`                                                                             | Выполнение запросов LINQ      | - ~~Загрузка~~ метаданных Lookup: ~~высокая, но кэшированная~~ низкая <br/> — Просмотр ~~создания~~ представления: ~~потенциально очень высокий, но кэшированный~~ низкий <br/> -Вычисление параметров: средний <br/> -Поиск ~~перевода~~ запроса: средний <br/> -Поиск с ~~созданием~~ материализации: ~~средний, но кэшированный~~ низкий <br/> -Выполнение запроса к базе данных: потенциально высокое <br/> + Connection. Open <br/> + Command.ExeКутереадер <br/> + DataReader. Read <br/> Материализация объекта: средний <br/> — Поиск удостоверения: средний | - ~~Загрузка~~ метаданных Lookup: ~~высокая, но кэшированная~~ низкая <br/> — Просмотр ~~создания~~ представления: ~~потенциально очень высокий, но кэшированный~~ низкий <br/> -Вычисление параметров: низкое <br/> -Поиск ~~перевода~~ запроса: ~~средний, но кэшированный~~ низкий <br/> -Поиск с ~~созданием~~ материализации: ~~средний, но кэшированный~~ низкий <br/> Выполнение запроса к базе данных: потенциально высокое (более удачные запросы в некоторых ситуациях) <br/> + Connection. Open <br/> + Command.ExeКутереадер <br/> + DataReader. Read <br/> Материализация объекта: средний <br/> — Поиск удостоверения: средний | - ~~Загрузка~~ метаданных Lookup: ~~высокая, но кэшированная~~ низкая <br/> — Поиск по ~~созданию~~ представления: ~~средний, но кэшированный~~ низкий <br/> -Вычисление параметров: низкое <br/> -Поиск ~~перевода~~ запроса: ~~средний, но кэшированный~~ низкий <br/> -Поиск с ~~созданием~~ материализации: ~~средний, но кэшированный~~ низкий <br/> Выполнение запроса к базе данных: потенциально высокое (более удачные запросы в некоторых ситуациях) <br/> + Connection. Open <br/> + Command.ExeКутереадер <br/> + DataReader. Read <br/> Материализация объекта: средний (быстрее, чем EF5) <br/> — Поиск удостоверения: средний |
| `}`                                                                                                  | Подключение. закрыть          | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |


Существует несколько способов снизить затраты на производительность как для холодного, так и для горячего запроса, и мы рассмотрим их в следующем разделе. В частности, мы рассмотрим снижение затрат на загрузку модели в холодных запросах с помощью предварительно созданных представлений, которые должны помочь в уменьшении производительности, возникших во время создания представления. Для теплого запроса мы расскажем о кэшировании планов запросов, отсутствии запросов отслеживания и различных параметрах выполнения запроса.

### <a name="21-what-is-view-generation"></a>2,1 что такое создание представления?

Чтобы понять, что такое создание представления, сначала необходимо понять, что такое представления сопоставления. Представления сопоставления являются исполняемыми представлениями преобразований, указанных в сопоставлении для каждого набора сущностей и ассоциации. На внутреннем уровне эти представления сопоставления принимают форму ККТС (канонические деревья запросов). Существует два типа представлений сопоставления:

-   Представления запросов. они представляют преобразование, необходимое для перехода от схемы базы данных к концептуальной модели.
-   Обновления представлений. они представляют преобразование, необходимое для перехода от концептуальной модели к схеме базы данных.

Помните, что концептуальная модель может отличаться от схемы базы данных различными способами. Например, одна таблица может использоваться для хранения данных двух различных типов сущностей. Наследование и нетривиальные сопоставления играют роль в сложности представлений сопоставления.

Процесс вычисления этих представлений на основе спецификации сопоставления — это то, что мы вызываем создание представления. Создание представления может быть выполнено динамически при загрузке модели или во время сборки с помощью "предварительно созданных представлений"; Последний сериализуется в виде Entity SQL инструкций в \# файл C или VB.

При создании представлений они также проверяются. С точки зрения производительности подавляющее большинство затрат на создание представления фактически является проверкой представлений, гарантирующих, что соединения между сущностями имеют смысл и имеют правильную кратность для всех поддерживаемых операций.

При выполнении запроса к набору сущностей запрос объединяется с соответствующим представлением запроса, а результат этой композиции выполняется с помощью компилятора планов для создания представления запроса, который может быть понят резервному хранилищу. Для SQL Server окончательным результатом этой компиляции будет инструкция T-SQL SELECT. При первом выполнении обновления над набором сущностей представление обновления выполняется с помощью аналогичного процесса преобразования в инструкции DML для целевой базы данных.

### <a name="22-factors-that-affect-view-generation-performance"></a>2,2 факторов, влияющих на производительность создания представления

Производительность шага создания представления не только зависит от размера модели, а также от способа взаимосвязи модели. Если две сущности соединены через цепочку наследования или ассоциацию, говорят, что они подключены. Аналогично, если две таблицы соединены через внешний ключ, они соединяются. По мере увеличения числа подключенных сущностей и таблиц в схемах увеличивается стоимость создания представления.

Алгоритм, используемый для создания и проверки представлений, является экспоненциальным в худшем случае, хотя мы используем некоторые оптимизации для улучшения этого. Ниже перечислены наиболее существенные факторы, которые могут отрицательно сказаться на производительности.

-   Размер модели, ссылающийся на количество сущностей и количество ассоциаций между этими сущностями.
-   Сложность модели, в частности наследование с использованием большого количества типов.
-   Использование независимых ассоциаций, а не связей по внешнему ключу.

Для небольших простых моделей затраты могут быть достаточно малыми, чтобы не тратиться на использование предварительно созданных представлений. При увеличении размера и сложности модели существует несколько вариантов снижения затрат на создание и проверку представления.

### <a name="23-using-pre-generated-views-to-decrease-model-load-time"></a>2,3. Использование предварительно созданных представлений для сокращения времени загрузки модели

Подробные сведения об использовании предварительно созданных представлений в Entity Framework 6 см. в [предварительно созданных представлениях сопоставления](xref:ef6/fundamentals/performance/pre-generated-views) .

#### <a name="231-pre-generated-views-using-the-entity-framework-power-tools-community-edition"></a>2.3.1 предварительно созданные представления с помощью Entity Framework Power Tools Community Edition

Вы можете использовать [Entity Framework 6 Power Tools Community Edition](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) для создания представлений EDMX и Code First моделей, щелкнув правой кнопкой мыши файл класса модели и выбрав пункт "сформировать представления" в меню Entity Framework. Выпуск Entity Framework Power Tools Community Edition работает только с контекстами, производными от DbContext.

#### <a name="232-how-to-use-pre-generated-views-with-a-model-created-by-edmgen"></a>2.3.2. как использовать предварительно созданные представления с моделью, созданной с помощью EDMGen

EDMGen — это служебная программа, входящая в состав .NET и работающая с Entity Framework 4 и 5, но не с Entity Framework 6. EDMGen позволяет создавать файл модели, слой объектов и представления из командной строки. Один из выходных данных будет файлом представления на выбранном вами языке, VB или C \# . Это файл кода, содержащий Entity SQL фрагменты для каждого набора сущностей. Чтобы включить предварительно созданные представления, просто включите файл в проект.

Если вы вручную вносите изменения в файлы схемы для модели, необходимо будет повторно создать файл представлений. Это можно сделать, запустив EDMGen с флагом **/mode: виевженератион** .

#### <a name="233-how-to-use-pre-generated-views-with-an-edmx-file"></a>2.3.3. как использовать предварительно созданные представления с EDMX-файлом

Кроме того, с помощью EDMGen можно создавать представления для EDMX-файла. ранее упоминаемый раздел MSDN описывает, как добавить событие перед сборкой для этого, но это очень сложно, и в некоторых случаях это невозможно. Обычно проще использовать шаблон T4 для создания представлений, когда модель находится в EDMX-файле.

В блоге группы ADO.NET есть запись, в которой описывается использование шаблона T4 для создания представления ( \<https://docs.microsoft.com/archive/blogs/adonet/how-to-use-a-t4-template-for-view-generation> ). В эту запись входит шаблон, который можно скачать и добавить в проект. Шаблон был написан для первой версии Entity Framework, поэтому он не гарантирует работу с последними версиями Entity Framework. Однако вы можете скачать более новый набор шаблонов создания представлений для Entity Framework 4 и 5from коллекцию Visual Studio:

-   VB.NET: \<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d>
-   C \# : \<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d>

Если вы используете Entity Framework 6, вы можете получить шаблоны T4 для создания представлений из коллекции Visual Studio по адресу \<http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f> .

### <a name="24-reducing-the-cost-of-view-generation"></a>2,4. сокращение затрат на создание представления

Использование предварительно созданных представлений позволяет переключать затраты на создание представления от загрузки модели (времени выполнения) до времени разработки. Хотя это повышает производительность при запуске во время выполнения, вы все равно будете испытывать трудности при разработке представлений. Существует несколько дополнительных приемов, которые помогут снизить затраты на создание представления, как во время компиляции, так и во время выполнения.

#### <a name="241-using-foreign-key-associations-to-reduce-view-generation-cost"></a>2.4.1 с использованием ассоциаций по внешнему ключу для сокращения стоимости создания представления

Мы рассмотрели ряд случаев, в которых при переключении взаимосвязей модели из независимых взаимосвязей на внешние ключи значительно улучшилось время, затраченное на создание представления.

Чтобы продемонстрировать это улучшение, мы создали две версии модели Navision с помощью EDMGen. *Примечание. Описание модели Navision см. в приложении в.* Модель Navision является интересной для этого упражнения из-за большого количества сущностей и связей между ними.

Одна версия этой очень большой модели была создана с помощью ассоциаций внешних ключей, а другая — с независимыми ассоциациями. Затем время, затраченное на создание представлений для каждой модели, истекло. Entity Framework 5 тестов использовался метод Женератевиевс () из класса Ентитивиевженератор для создания представлений, а Entity Framework 6-тест использовал метод Женератевиевс () из класса Сторажемаппингитемколлектион. Это обусловлено реструктуризацией кода, произошедшей в Entity Framework 6 CodeBase.

При использовании Entity Framework 5 на компьютере лаборатории создается представление для модели с внешними ключами 65 минут. Неизвестно, сколько времени заняло бы создание представлений для модели, использующей независимые ассоциации. Мы оставили тест, который выполнялся в течение месяца до перезагрузки компьютера в лабораторной среде для установки ежемесячных обновлений.

С помощью Entity Framework 6 Создание представления для модели с внешними ключами заняло 28 секунд на одном и том же компьютере лаборатории. Создание представления для модели, использующей независимые ассоциации, заняло 58 секунд. Улучшения, выполняемые для Entity Framework 6 по коду создания представления, означают, что многим проектам не потребуется предварительно сформированные представления для ускорения времени запуска.

Важно отметить, что предварительные представления в Entity Framework 4 и 5 могут выполняться с помощью программы EDMGen или Entity Framework Power Tools. Для создания Entity Framework 6 представлений можно использовать средства Entity Framework Power Tools или программно, как описано в [предварительно созданных представлениях сопоставления](xref:ef6/fundamentals/performance/pre-generated-views).

##### <a name="2411-how-to-use-foreign-keys-instead-of-independent-associations"></a>2.4.1.1 использование внешних ключей вместо независимых ассоциаций

При использовании EDMGen или Entity Designer в Visual Studio вы получаете внешние ключи по умолчанию, и для переключения между внешние ключи и IAs принимается только один флажок или флаг командной строки.

При наличии большой Code Firstной модели использование независимых ассоциаций будет иметь тот же результат при формировании представления. Это влияние можно избежать, включив свойства внешнего ключа в классы для зависимых объектов, хотя некоторые разработчики считают, что замусоривать их объектная модель. Дополнительные сведения об этой теме можно найти в \<http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/> .

| В языке      | выполните следующее:                                                                                                                                                                                                                                                                                                                              |
|:----------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Entity Designer | После добавления связи между двумя сущностями убедитесь, что у вас есть справочное ограничение. Ссылочные ограничения указывают Entity Framework использовать внешние ключи вместо независимых ассоциаций. Дополнительные сведения см. на странице \<https://docs.microsoft.com/archive/blogs/efdesign/foreign-keys-in-the-entity-framework> . |
| Помощи          | При использовании EDMGen для создания файлов из базы данных внешние ключи будут соблюдаться и добавляться в модель. Дополнительные сведения о различных параметрах, предоставляемых функцией EDMGen, см [http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx) . здесь.                           |
| Code First      | Сведения о том, как включать свойства внешнего ключа в зависимые объекты при использовании Code First, см. в разделе "соглашение о отношениях" статьи [Code First соглашений](xref:ef6/modeling/code-first/conventions/built-in) .                                                                                              |

#### <a name="242-moving-your-model-to-a-separate-assembly"></a>2.4.2 перемещение модели в отдельную сборку

Если модель включена непосредственно в проект приложения и вы создаете представления с помощью события перед сборкой или шаблона T4, создание и проверка представлений будут происходить при каждом перестроении проекта, даже если модель не была изменена. При перемещении модели в отдельную сборку и сослаться на нее из проекта приложения можно вносить другие изменения в приложение без необходимости перестраивать проект, содержащий модель.

*Примечание.*   При перемещении модели в отдельные сборки не забывайте копировать строки подключения для модели в файл конфигурации приложения клиентского проекта.

#### <a name="243-disable-validation-of-an-edmx-based-model"></a>2.4.3 отключить проверку модели на основе EDMX

Модели EDMX проверяются во время компиляции, даже если модель не изменилась. Если модель уже проверена, можно отключить проверку во время компиляции, задав для свойства "Проверка при сборке" значение false в окне "Свойства". При изменении сопоставления или модели можно временно повторно включить проверку для проверки изменений.

Обратите внимание, что в Entity Framework Designer для Entity Framework 6 были внесены улучшения производительности, а стоимость "Проверка сборки" значительно ниже, чем в предыдущих версиях конструктора.

## <a name="3-caching-in-the-entity-framework"></a>3 кэширование в Entity Framework

Entity Framework имеет следующие формы встроенного кэширования:

1.  Кэширование объектов — Диспетчер ObjectStateManager, встроенный в экземпляр ObjectContext, отслеживает в памяти объекты, которые были получены с помощью этого экземпляра. Это также называется кэшем первого уровня.
2.  Кэширование плана запроса — повторное использование созданной команды хранилища при выполнении запроса более одного раза.
3.  Кэширование метаданных — совместное использование метаданных для модели в разных соединениях с одной и той же моделью.

Помимо кэшей, предоставляемых EF, можно использовать специальный поставщик данных ADO.NET, известный как поставщик обертки, для расширения Entity Framework с кэшем для получения результатов, полученных из базы данных, также известного как кэширование второго уровня.

### <a name="31-object-caching"></a>3,1 кэширование объектов

По умолчанию, когда сущность возвращается в результатах запроса непосредственно перед тем, как EF материализовать его, контекст ObjectContext проверяет, загружена ли сущность с таким же ключом в Диспетчер ObjectStateManager. Если сущность с такими же ключами уже существует, EF будет включать ее в результаты запроса. Хотя EF по-прежнему будет выдавать запрос к базе данных, это поведение может обходить большую часть стоимости материализации сущности несколько раз.

#### <a name="311-getting-entities-from-the-object-cache-using-dbcontext-find"></a>3.1.1 получение сущностей из кэша объектов с помощью DbContext Find

В отличие от обычного запроса, метод Find в DbSet (интерфейсы API, которые впервые входят в EF 4,1) выполняет поиск в памяти, прежде чем даже выдавать запрос к базе данных. Важно отметить, что два разных экземпляра ObjectContext будут иметь два разных экземпляра ObjectStateManager, то есть они имеют отдельные кэши объектов.

Поиск использует значение первичного ключа, чтобы попытаться найти сущность, отслеживание контекстом. Если сущность не находится в контексте, будет выполнен запрос и выполнена оценка базы данных, а если сущность не найдена в контексте или в базе данных, возвращается значение null. Обратите внимание, что функция find также возвращает сущности, которые были добавлены в контекст, но еще не сохранены в базе данных.

При использовании функции найти необходимо принять во внимание производительность. Вызовы этого метода по умолчанию активируют проверку кэша объектов для обнаружения изменений, которые все еще ожидают фиксации в базе данных. Этот процесс может быть очень ресурсоемким, если имеется очень большое количество объектов в кэше объектов или графа больших объектов, добавляемых в кэш объектов, но его также можно отключить. В некоторых случаях при отключении автоматического обнаружения изменений может быть замечено различие в порядке вызова метода Find. Однако второй порядок величины считается тем, что объект фактически находится в кэше, и когда объект необходимо извлечь из базы данных. Ниже приведен пример диаграммы с измерениями, взятыми с использованием некоторых из наших микротестов, выраженных в миллисекундах, с нагрузкой 5000 сущностей:

![Логарифмическая шкала .NET 4,5](~/ef6/media/net45logscale.png ".NET 4,5-логарифмическая шкала")

Пример поиска с отключенными изменениями автоматического обнаружения:

``` csharp
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    context.Configuration.AutoDetectChangesEnabled = true;
    ...
```

При использовании метода Find необходимо учитывать следующее:

1.  Если объект не находится в кэше, преимущества Find будут отрицанием, но синтаксис по-прежнему проще, чем запрос по ключу.
2.  Если включено автоматическое обнаружение изменений, стоимость метода Find может увеличиваться на один порядок или даже больше в зависимости от сложности модели и количества сущностей в кэше объектов.

Кроме того, помните, что функция find возвращает только искомую сущность и не загружает автоматически связанные сущности, если они еще не находятся в кэше объектов. Если необходимо получить связанные сущности, можно использовать запрос по ключу с безотлагательной загрузкой. Дополнительные сведения см. в статье **8,1 ленивая загрузка и безотлагательная**загрузка.

#### <a name="312-performance-issues-when-the-object-cache-has-many-entities"></a>3.1.2 проблемы с производительностью, если в кэше объектов содержится много сущностей

Кэш объектов помогает увеличить общую скорость реагирования Entity Framework. Однако если в кэше объектов содержится очень большой объем загруженных сущностей, это может повлиять на определенные операции, такие как добавление, удаление, поиск, запись, SaveChanges и т. д. В частности, операции, которые активируют вызов DetectChanges, будут отрицательно затронуты большими кэшами объектов. DetectChanges синхронизирует граф объектов с диспетчером состояния объектов, и его производительность определяется непосредственно размером графа объекта. Дополнительные сведения о DetectChanges см. [в разделе Отслеживание изменений в сущностях POCO](https://msdn.microsoft.com/library/dd456848.aspx).

При использовании Entity Framework 6 разработчики могут вызывать метод AddRange и Ремоверанже непосредственно в DbSet, вместо того чтобы выполнять итерацию по коллекции и вызывать Add один раз для каждого экземпляра. Преимущество использования методов range заключается в том, что стоимость DetectChanges оплачивается только один раз для всего набора сущностей, а не один раз в каждой добавляемой сущности.

### <a name="32-query-plan-caching"></a>3,2 кэширование планов запросов

При первом выполнении запроса он проходит через внутренний компилятор плана, чтобы преобразовать концептуальный запрос в команду Store (например, T-SQL, выполняемый при выполнении в SQL Server).Если кэширование планов запросов включено, при следующем выполнении запроса команда Store извлекается непосредственно из кэша планов запросов для выполнения, минуя компилятор плана.

Кэш планов запросов совместно используется экземплярами ObjectContext в одном домене AppDomain. Чтобы воспользоваться кэшированием плана запроса, не нужно хранить экземпляр ObjectContext.

#### <a name="321-some-notes-about-query-plan-caching"></a>3.2.1. Некоторые замечания о кэшировании планов запросов

-   Кэш планов запросов является общим для всех типов запросов: Entity SQL, LINQ to Entities и объектов CompiledQuery.
-   По умолчанию кэширование планов запросов включено для запросов Entity SQL, выполняемых с помощью EntityCommand или ObjectQuery. Он также включен по умолчанию для запросов LINQ to Entities в Entity Framework в .NET 4,5 и в Entity Framework 6.
    -   Кэширование плана запроса можно отключить, задав для свойства Енаблепланкачинг (для EntityCommand или ObjectQuery) значение false. Пример:
``` csharp
                    var query = from customer in context.Customer
                                where customer.CustomerId == id
                                select new
                                {
                                    customer.CustomerId,
                                    customer.Name
                                };
                    ObjectQuery oQuery = query as ObjectQuery;
                    oQuery.EnablePlanCaching = false;
```
-   При выполнении параметризованных запросов изменение значения параметра приведет к попаданию в кэшированный запрос. Но изменение аспектов параметра (например, размера, точности или масштаба) приведет к подостижению другой записи в кэше.
-   При использовании Entity SQL строка запроса является частью ключа. Изменение запроса может привести к появлению различных записей кэша, даже если запросы функционально эквивалентны. К ним относятся изменения регистра или пробелов.
-   При использовании LINQ запрос обрабатывается для создания части ключа. Таким образом, изменение выражения LINQ приведет к формированию другого ключа.
-   Могут применяться другие технические ограничения. Дополнительные сведения см. в разделе автокомпилируемые запросы.

#### <a name="322-cache-eviction-algorithm"></a>алгоритм вытеснения кэша 3.2.2

Понимание того, как работает внутренний алгоритм, поможет понять, когда следует включать или отключать кэширование планов запросов. Алгоритм очистки выглядит следующим образом:

1.  Когда кэш содержит заданное число записей (800), запускается таймер, который периодически (раз в минуту) выгружает кэш.
2.  Во время очистки кэша записи удаляются из кэша на основе ЛФРУ (как правило, чаще всего — недавно использованные). При принятии решения о том, какие записи будут извлечены, в этом алгоритме учитывается количество попаданий и возраст.
3.  В конце каждой очистки кэша кэш снова содержит 800 записей.

Все записи кэша обрабатываются одинаково при определении того, какие записи следует исключить. Это означает, что команда Store для CompiledQuery имеет ту же вероятность вытеснения, что и команда Store для Entity SQL запроса.

Обратите внимание, что таймер вытеснения кэша запускается в том случае, если в кэше 800 сущностей, а кэш — только очистка 60 секунд после запуска этого таймера. Это означает, что размер кэша до 60 секунд может быть довольно большим.

#### <a name="323-test-metrics-demonstrating-query-plan-caching-performance"></a>3.2.3 тестовые метрики, демонстрирующие производительность кэширования плана запроса

Чтобы продемонстрировать воздействие кэширования плана запроса на производительность приложения, мы выполнили тест, в котором мы выполняли ряд Entity SQLных запросов к модели Navision. Описание модели Navision и типов выполненных запросов см. в приложении. В этом тесте сначала выполняется перебор списка запросов и выполняется каждый из них, чтобы добавить их в кэш (если кэширование включено). Этот шаг не имеет времени. Далее мы запустим основной поток в течение более 60 секунд, чтобы разрешить выполнение очистки кэша. Наконец, мы перебираем в список второй раз, чтобы выполнить кэшированные запросы. Кроме того, кэш планов SQL Server очищается перед выполнением каждого набора запросов, что позволяет точно отразить преимущества, предоставляемые кэшем планов запросов.

##### <a name="3231-test-results"></a>3.2.3.1 результаты теста

| Тест                                                                   | EF5 без кэша | EF5 в кэше | EF6 без кэша | EF6 в кэше |
|:-----------------------------------------------------------------------|:-------------|:-----------|:-------------|:-----------|
| Перечисление всех запросов 18723                                          | 124          | 125,4      | 124,3        | 125,3      |
| Предотвращение очистки (только первые 800 запросов, независимо от сложности)  | 41,7         | 5.5        | 40,5         | 5,4        |
| Только запросы Аггрегатингсубтоталс (Total 178, что позволяет избежать очистки); | 39,5         | 4,5        | 38,1         | 4.6        |

*Все значения времени в секундах.*

Мораль — при выполнении большого количества различных запросов (например, динамически создаваемых запросов) кэширование не помогает, а результирующий сброс кэша может обеспечить максимальную пользу из кэширования планов, от фактического использования.

Запросы Аггрегатингсубтоталс являются наиболее сложными из запросов, которые мы протестировали. Как и ожидалось, чем сложнее запрос, тем больше преимуществ вы увидите из кэша планов запросов.

Так как CompiledQuery является запросом LINQ с кэшированным планом, сравнение CompiledQuery и эквивалентного Entity SQL запроса должно иметь аналогичные результаты. На самом деле, если приложение содержит много динамических Entity SQLных запросов, заполнение кэша запросами также приведет к Компиледкуериес декомпиляции, когда они будут сброшены из кэша. В этом сценарии производительность может быть улучшена путем отключения кэширования в динамических запросах для определения приоритета Компиледкуериес. Но лучше, конечно, будет переписать приложение, чтобы использовать параметризованные запросы вместо динамических запросов.

### <a name="33-using-compiledquery-to-improve-performance-with-linq-queries"></a>3,3 использование CompiledQuery для повышения производительности с помощью запросов LINQ

Наши тесты указывают, что использование CompiledQuery может привести к попреимуществам 7% по отношению к автокомпилируемым запросам LINQ; Это означает, что вы потратите на 7% меньше времени на исполнение кода из стека Entity Framework; Это не означает, что приложение будет выполняться на 7% быстрее. В целом, затраты на написание и обслуживание объектов CompiledQuery в EF 5,0 могут не полагаться на проблемы по сравнению с преимуществами. Расстояние может отличаться, поэтому рекомендуется использовать этот вариант, если для проекта требуется дополнительно отправить. Обратите внимание, что Компиледкуериес совместимы только с моделями, производными от ObjectContext, и не совместима с моделями, производными от DbContext.

Дополнительные сведения о создании и вызове CompiledQuery см. в разделе [скомпилированные запросы (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx).

Существует два аспекта, которые необходимо выполнить при использовании CompiledQuery, а именно — требование использовать статические экземпляры и проблемы с компонуемости. Ниже приведено подробное описание этих двух аспектов.

#### <a name="331-use-static-compiledquery-instances"></a>3.3.1 использовать статические экземпляры CompiledQuery

Поскольку компиляция запроса LINQ является трудоемким процессом, мы не хотим делать это каждый раз, когда нужно извлечь данные из базы данных. Экземпляры CompiledQuery позволяют компилировать один раз и выполнять несколько раз, но необходимо быть осторожным и получать многократное использование одного и того же экземпляра CompiledQuery каждый раз, вместо того чтобы повторно компилировать его. Использование статических членов для хранения экземпляров CompiledQuery станет необходимым; в противном случае вы не увидите никаких преимуществ.

Например, предположим, что страница имеет следующий основной текст метода для отображения продуктов для выбранной категории:

``` csharp
    // Warning: this is the wrong way of using CompiledQuery
    using (NorthwindEntities context = new NorthwindEntities())
    {
        string selectedCategory = this.categoriesList.SelectedValue;

        var productsForCategory = CompiledQuery.Compile<NorthwindEntities, string, IQueryable<Product>>(
            (NorthwindEntities nwnd, string category) =>
                nwnd.Products.Where(p => p.Category.CategoryName == category)
        );

        this.productsGrid.DataSource = productsForCategory.Invoke(context, selectedCategory).ToList();
        this.productsGrid.DataBind();
    }

    this.productsGrid.Visible = true;
```

В этом случае новый экземпляр CompiledQuery будет создаваться в режиме реального времени при каждом вызове метода. Вместо того чтобы видеть преимущества производительности, извлекая команду Store из кэша планов запросов, CompiledQuery будет проходить через компилятор планов каждый раз, когда создается новый экземпляр. На самом деле кэш планов запросов будет замусоривать с новой записью CompiledQuery каждый раз при вызове метода.

Вместо этого необходимо создать статический экземпляр скомпилированного запроса, поэтому при каждом вызове метода вызывается тот же скомпилированный запрос. Одним из способов это является добавление экземпляра CompiledQuery в качестве члена контекста объекта.После этого можно сделать небольшую чистку, обратившись к CompiledQuery через вспомогательный метод:

``` csharp
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IEnumerable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
            );

        public IEnumerable<Product> GetProductsForCategory(string categoryName)
        {
            return productsForCategoryCQ.Invoke(this, categoryName).ToList();
        }
```

Этот вспомогательный метод будет вызываться следующим образом:

``` csharp
    this.productsGrid.DataSource = context.GetProductsForCategory(selectedCategory);
```

#### <a name="332-composing-over-a-compiledquery"></a>3.3.2, составленный на CompiledQuery

Возможность объединения запросов LINQ чрезвычайно полезна. для этого просто вызовите метод после IQueryable, например *Skip ()* или *Count ()*. Однако при этом возвращается новый объект IQueryable. Несмотря на то, что вы не можете прерывать вас технически из-за CompiledQuery, это приведет к созданию нового объекта IQueryable, требующего повторной передачи через компилятор планов.

Некоторые компоненты будут использовать составные объекты IQueryable для включения расширенных функций. Например, ASP. GridView NET может быть привязан к данным объекта IQueryable через свойство SelectMethod. Затем GridView получит доступ к этому объекту IQueryable, чтобы разрешить сортировку и разбиение по модели данных. Как видите, использование CompiledQuery для GridView не будет отпопаданием в скомпилированный запрос, но создаст новый автоматически скомпилированный запрос.

В одном месте это можно делать при добавлении последовательных фильтров к запросу. Например, предположим, что у вас есть страница Customers с несколькими раскрывающимися списками для необязательных фильтров (например, Country и Ордерскаунт). Эти фильтры можно составить с помощью IQueryable результатов CompiledQuery, но это приведет к тому, что новый запрос будет проходить через компилятор планов при каждом выполнении.

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployee();

        if (this.orderCountFilterList.SelectedItem.Value != defaultFilterText)
        {
            int orderCount = int.Parse(orderCountFilterList.SelectedValue);
            myCustomers = myCustomers.Where(c => c.Orders.Count > orderCount);
        }

        if (this.countryFilterList.SelectedItem.Value != defaultFilterText)
        {
            myCustomers = myCustomers.Where(c => c.Address.Country == countryFilterList.SelectedValue);
        }

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 Чтобы избежать этой повторной компиляции, можно переписать CompiledQuery, чтобы сделать возможными фильтры в учетной записи:

``` csharp
    private static readonly Func<NorthwindEntities, int, int?, string, IQueryable<Customer>> customersForEmployeeWithFiltersCQ = CompiledQuery.Compile(
        (NorthwindEntities context, int empId, int? countFilter, string countryFilter) =>
            context.Customers.Where(c => c.Orders.Any(o => o.EmployeeID == empId))
            .Where(c => countFilter.HasValue == false || c.Orders.Count > countFilter)
            .Where(c => countryFilter == null || c.Address.Country == countryFilter)
        );
```

Который будет вызываться в пользовательском интерфейсе следующим образом:

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        int? countFilter = (this.orderCountFilterList.SelectedIndex == 0) ?
            (int?)null :
            int.Parse(this.orderCountFilterList.SelectedValue);

        string countryFilter = (this.countryFilterList.SelectedIndex == 0) ?
            null :
            this.countryFilterList.SelectedValue;

        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployeeWithFilters(
                countFilter, countryFilter);

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 Компромисс здесь — созданная команда хранилища всегда будет иметь фильтры с проверками null, но они должны быть довольно простыми для оптимизации сервера базы данных:

``` SQL
...
WHERE ((0 = (CASE WHEN (@p__linq__1 IS NOT NULL) THEN cast(1 as bit) WHEN (@p__linq__1 IS NULL) THEN cast(0 as bit) END)) OR ([Project3].[C2] > @p__linq__2)) AND (@p__linq__3 IS NULL OR [Project3].[Country] = @p__linq__4)
```

### <a name="34-metadata-caching"></a>3,4 кэширование метаданных

Entity Framework также поддерживает кэширование метаданных. Это, по сути, кэширование информации о типе и сопоставления типа с базой данных в разных соединениях с одной и той же моделью. Кэш метаданных уникален для каждого домена AppDomain.

#### <a name="341-metadata-caching-algorithm"></a>алгоритм кэширования метаданных 3.4.1

1.  Сведения о метаданных для модели хранятся в ItemCollection для каждого EntityConnection.
    -   В качестве побочной заметки существуют различные объекты ItemCollection для разных частей модели. Например, Стореитемколлектионс содержит сведения о модели базы данных. Обжектитемколлектион содержит сведения о модели данных; Коллекций EdmItemCollection содержит сведения о концептуальной модели.

2.  Если два соединения используют одну и ту же строку подключения, они будут совместно использовать один и тот же экземпляр ItemCollection.
3.  Функционально эквивалентные, но строки подключения, отличные от текста, могут привести к различным кэшам метаданных. Мы размечаем строки подключения, поэтому простое изменение порядка маркеров должно привести к созданию общих метаданных. Но две строки подключения, которые кажутся функционально одинаковыми, могут не оцениваться как идентичные после разметки.
4.  ItemCollection периодически проверяется на использование. Если определено, что к рабочей области нет доступа в последнее время, она будет помечена для очистки при следующей очистке кэша.
5.  Просто создание EntityConnection приведет к созданию кэша метаданных (хотя коллекции элементов в нем не будут инициализированы до открытия соединения). Эта Рабочая область останется в памяти до тех пор, пока алгоритм кэширования не определит, что он не используется.

Группа консультирования клиентов написала запись блога, в которой описывается хранение ссылки на ItemCollection, чтобы избежать "нерекомендуемых" при использовании больших моделей: \<https://docs.microsoft.com/archive/blogs/appfabriccat/holding-a-reference-to-the-ef-metadataworkspace-for-wcf-services> .

#### <a name="342-the-relationship-between-metadata-caching-and-query-plan-caching"></a>3.4.2 связи между кэшированием метаданных и кэшированием плана запроса

Экземпляр кэша плана запроса находится в ItemCollectionах хранилища для области MetadataWorkspace. Это означает, что команды кэшированного хранилища будут использоваться для запросов к любому контексту, созданному с помощью заданной области MetadataWorkspace. Это также означает, что при наличии двух строк соединения, которые немного отличаются друг от друга и не совпадают после маркировки, у вас будут разные экземпляры кэша планов запросов.

### <a name="35-results-caching"></a>3,5. Кэширование результатов

При кэшировании результатов (также известном как "кэширование второго уровня") результаты запросов сохраняются в локальном кэше. При выдаче запроса сначала вы узнаете, доступны ли результаты локально перед запросом к хранилищу. Хотя кэширование результатов не поддерживается напрямую Entity Framework, можно добавить кэш второго уровня с помощью поставщика обтекания. Пример поставщика с поддержкой оболочки для кэша второго уровня — это компания Alachisoft [Entity Framework кэша второго уровня на основе NCache](https://www.alachisoft.com/ncache/entity-framework.html).

Эта реализация кэширования второго уровня — это внедренная функция, которая выполняется после вычисления выражения LINQ (и функлетизед), а план выполнения запроса вычисляется или извлекается из кэша первого уровня. Затем кэш второго уровня сохранит только результаты необработанной базы данных, поэтому конвейер материализации по-прежнему будет выполняться позже.

#### <a name="351-additional-references-for-results-caching-with-the-wrapping-provider"></a>3.5.1. Дополнительные ссылки на кэширование результатов с помощью поставщика упаковки

-   Юлия Лерман написала "кэширование второго уровня в Entity Framework и Windows Azure" MSDN, которое содержит сведения об обновлении примера поставщика упаковки для использования кэширования Windows Server AppFabric: [https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)
-   Если вы работаете с Entity Framework 5, в блоге группы есть запись, в которой описывается, как получить сведения о работе с поставщиком кэширования для Entity Framework 5: \<https://docs.microsoft.com/archive/blogs/adonet/ef-caching-with-jarek-kowalskis-provider> . Он также содержит шаблон T4, позволяющий автоматизировать добавление второго уровня кэширования в проект.

## <a name="4-autocompiled-queries"></a>4 скомпилированные запросы

При выполнении запроса к базе данных с помощью Entity Framework необходимо выполнить ряд действий, прежде чем фактически приступить к материализации результатов; одним из таких шагов является компиляция запросов. Entity SQLные запросы имели хорошую производительность, так как они кэшируются автоматически, поэтому во второй или третий раз при выполнении одного и того же запроса можно пропустить компилятор плана и использовать кэшированный план.

Entity Framework 5 также предоставили автоматическое кэширование для LINQ to Entitiesных запросов. В прошлых выпусках Entity Framework создание CompiledQuery для ускорения производительности была распространенной практикой, так как это сделает LINQ to Entities кэшированием запросов. Так как кэширование теперь выполняется автоматически без использования CompiledQuery, мы вызываем эту функцию как «автоматически скомпилированные запросы». Дополнительные сведения о кэше планов запросов и его механиках см. в разделе кэширование планов запросов.

Entity Framework определяет, когда требуется перекомпилировать запрос, и делает это при вызове запроса, даже если он был скомпилирован ранее. Ниже перечислены распространенные условия, вызывающие повторную компиляцию запроса.

-   Изменение собой MergeOption, связанного с запросом. Кэшированный запрос не будет использоваться, вместо этого компилятор плана будет запущен снова, а созданный план получится в кэше.
-   Изменение значения Контекстоптионс. Усекшарпнуллкомпарисонбехавиор. Вы получаете тот же результат, что и при изменении собой MergeOption.

Другие условия могут помешать вашему запросу использовать кэш. Ниже приведены распространенные примеры.

-   Использование IEnumerable &lt; T &gt; . Contains &lt; &gt; (значение T).
-   Использование функций, создающих запросы с константами.
-   Использование свойств несопоставленного объекта.
-   Связывание запроса с другим запросом, который необходимо перекомпилировать.

### <a name="41-using-ienumerablelttgtcontainslttgtt-value"></a>4,1. Использование IEnumerable &lt; T &gt; . Содержит &lt; t &gt; (значение t)

Entity Framework не кэширует запросы, которые вызывают IEnumerable &lt; T &gt; . Содержит &lt; t &gt; (значение t) для коллекции в памяти, так как значения коллекции считаются временными. Следующий пример запроса не будет кэшироваться, поэтому он всегда будет обрабатываться компилятором плана:

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var query = context.MyEntities
                    .Where(entity => ids.Contains(entity.Id));

    var results = query.ToList();
    ...
}
```

Обратите внимание, что размер IEnumerable, по отношению к которому выполняется, определяет скорость и скорость компиляции запроса. Производительность может значительно снизиться при использовании больших коллекций, например, показанных в приведенном выше примере.

Entity Framework 6 содержит оптимизацию для методов IEnumerable &lt; T &gt; . Содержит &lt; t &gt; (значение t) работает при выполнении запросов. Создаваемый код SQL гораздо быстрее для создания и чтения, и в большинстве случаев он также выполняется быстрее на сервере.

### <a name="42-using-functions-that-produce-queries-with-constants"></a>4,2. Использование функций, создающих запросы с константами

Операторы "Skip" (), Take (), Contains () и Дефаутифемпти () не создают SQL-запросы с параметрами, а вместо этого помещают значения, передаваемые в них, в виде констант. В связи с этим запросы, которые могли бы быть идентичными, в итоге замусоривать кэш планов запросов, как в стеке EF, так и на сервере базы данных, и не будут использоваться повторно, если в последующем выполнении запроса не используются одни и те же константы. Пример:

``` csharp
var id = 10;
...
using (var context = new MyContext())
{
    var query = context.MyEntities.Select(entity => entity.Id).Contains(id);

    var results = query.ToList();
    ...
}
```

В этом примере каждый раз, когда этот запрос выполняется с другим значением идентификатора, запрос будет скомпилирован в новый план.

Обратите особое внимание на использование параметра пропустить и выполнить при разбиении на страницы. В EF6 эти методы имеют лямбда-перегрузку, которая фактически делает кэшированный план запроса многократно используемым, так как EF может записывать переменные, передаваемые этим методам, и переводить их в Склпараметерс. Это также помогает избежать очистки кэша, поскольку в противном случае каждый запрос с другой константой для Skip и Take будет получать собственную запись кэша плана запроса.

Рассмотрим следующий код, который является неоптимальным, но предназначен только для того, чтобы проиллюстрировать этот класс запросов:

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

Более быстрая версия этого же кода будет содержать вызов Skip с лямбда-выражением:

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(() => i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

Второй фрагмент кода может работать быстрее, чем на 11%, поскольку один и тот же план запроса используется каждый раз при выполнении запроса, что экономит время ЦП и позволяет избежать замусоривать кэша запросов. Более того, так как параметр для пропуска находится в закрытии, код может выглядеть так, как показано далее:

``` csharp
var i = 0;
var skippyCustomers = context.Customers.OrderBy(c => c.LastName).Skip(() => i);
for (; i < count; ++i)
{
    var currentCustomer = skippyCustomers.FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

### <a name="43-using-the-properties-of-a-non-mapped-object"></a>4,3. Использование свойств несопоставленного объекта

Если запрос использует свойства несопоставленного типа объекта в качестве параметра, запрос не будет кэшироваться. Пример:

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();

    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myObject.MyProperty)
                select entity;

   var results = query.ToList();
    ...
}
```

В этом примере предположим, что класс Нонмаппедтипе не является частью модели сущности. Этот запрос можно легко изменить, чтобы не использовать Несопоставленный тип, а использовать локальную переменную в качестве параметра запроса:

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();
    var myValue = myObject.MyProperty;
    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myValue)
                select entity;

    var results = query.ToList();
    ...
}
```

В этом случае запрос будет иметь возможность кэширования и будет полезен из кэша планов запросов.

### <a name="44-linking-to-queries-that-require-recompiling"></a>4,4. Связывание с запросами, требующими перекомпиляции

В том же примере, что и выше, при наличии второго запроса, который полагается на запрос, который необходимо перекомпилировать, будет также выполнена повторная компиляция всего второго запроса. Ниже приведен пример, иллюстрирующий этот сценарий:

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var firstQuery = from entity in context.MyEntities
                        where ids.Contains(entity.Id)
                        select entity;

    var secondQuery = from entity in context.MyEntities
                        where firstQuery.Any(otherEntity => otherEntity.Id == entity.Id)
                        select entity;

    var results = secondQuery.ToList();
    ...
}
```

Этот пример является универсальным, но он показывает, как связывание с Фирсткуери приводит к тому, что Секондкуери не удается получить кэширование. Если Фирсткуери не был запрос, требующий перекомпиляции, то Секондкуери бы был кэширован.

## <a name="5-notracking-queries"></a>5 запросов с отслеживанием

### <a name="51-disabling-change-tracking-to-reduce-state-management-overhead"></a>5,1 Отключение отслеживания изменений для сокращения затрат на управление состоянием

Если вы используете сценарий только для чтения и хотите избежать издержек при загрузке объектов в ObjectStateManager, можно выдавать запросы "без отслеживания".Отслеживание изменений может быть отключено на уровне запроса.

Обратите внимание, что при отключении отслеживания изменений вы фактически отключаете кэш объектов. При запросе сущности мы не можем пропустить материализации, выполнив предварительно материализованные результаты запроса из ObjectStateManager. Если вы регулярно выполняете запрос для одних и тех же сущностей в том же контексте, вы можете увидеть выигрыш в производительности от включения отслеживания изменений.

При выполнении запросов с помощью ObjectContext экземпляры ObjectQuery и Object Set запоминают собой MergeOption после задания, а запросы, составленные из них, наследуют действующий собой MergeOption родительского запроса. При использовании DbContext отслеживание можно отключить, вызвав модификатор Asnotrackin () в DbSet.

#### <a name="511-disabling-change-tracking-for-a-query-when-using-dbcontext"></a>5.1.1 Отключение отслеживания изменений для запроса при использовании DbContext

Можно переключить режим запроса на отслеживание путем сцепления вызова метода Asnotrackin () в запросе. В отличие от ObjectQuery, классы DbSet и Дбкуери в API DbContext не имеют изменяемого свойства для собой MergeOption.

``` csharp
    var productsForCategory = from p in context.Products.AsNoTracking()
                                where p.Category.CategoryName == selectedCategory
                                select p;


```

#### <a name="512-disabling-change-tracking-at-the-query-level-using-objectcontext"></a>5.1.2 Отключение отслеживания изменений на уровне запросов с помощью ObjectContext

``` csharp
    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;

    ((ObjectQuery)productsForCategory).MergeOption = MergeOption.NoTracking;
```

#### <a name="513-disabling-change-tracking-for-an-entire-entity-set-using-objectcontext"></a>5.1.3 Отключение отслеживания изменений для всего набора сущностей с помощью ObjectContext

``` csharp
    context.Products.MergeOption = MergeOption.NoTracking;

    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;
```

### <a name="52test-metrics-demonstrating-the-performance-benefit-of-notracking-queries"></a>5,2. тестовые метрики демонстрируют преимущества производительности запросов с неотслеживающими показателями

В этом тесте мы рассмотрим затраты на заполнение ObjectStateManager, сравнив отслеживание с запросами "не отслеживает" для модели Navision. Описание модели Navision и типов выполненных запросов см. в приложении. В этом тесте выполняется итерация по списку запросов и выполнение каждого из них один раз. Мы выполняли два варианта теста, один раз с запросами with Track и один раз с параметром слияния по умолчанию «Аппендонли». Мы запускали каждый вариант 3 раз и принимаем среднее значение выполнения. Между тестами мы очищают кэш запросов на SQL Server и уменьшаем базу данных tempdb, выполняя следующие команды:

1.  DBCC DROPCLEANBUFFERS
2.  DBCC FREEPROCCACHE
3.  DBCC SHRINKDATABASE (tempdb, 0)

Результаты теста, медиана более 3 запусков:

|                        | БЕЗ ОТСЛЕЖИВАНИЯ — РАБОЧИЙ НАБОР | БЕЗ ОТСЛЕЖИВАНИЯ — ВРЕМЯ | ТОЛЬКО ДОБАВЛЕНИЕ — РАБОЧИЙ НАБОР | ТОЛЬКО ДОБАВЛЕНИЕ — ВРЕМЯ |
|:-----------------------|:--------------------------|:-------------------|:--------------------------|:-------------------|
| **Entity Framework 5** | 460361728                 | 1163536 МС         | 596545536                 | 1273042 МС         |
| **Entity Framework 6** | 647127040                 | 190228 МС          | 832798720                 | 195521 МС          |

Entity Framework 5 будет иметь меньший объем памяти в конце выполнения, чем Entity Framework 6. Дополнительная память, потребляемая Entity Framework 6, является результатом дополнительных структур памяти и кода, обеспечивающего новые функции и более высокую производительность.

Также есть четкое различие в объеме памяти при использовании ObjectStateManager. Entity Framework 5 увеличилось на 30%, когда отслеживаются все сущности, материализованные из базы данных. При этом Entity Framework 6 увеличилось на 28%.

В то время Entity Framework 6 выполняет Entity Framework 5 в этом тесте по большому полю. Entity Framework 6 завершил тест примерно на 16% времени, потребляемого Entity Framework 5. Кроме того, при использовании ObjectStateManager Entity Framework 5 занимает 9% времени. В сравнении с диспетчером ObjectStateManager Entity Framework 6 использует более 3% времени.

## <a name="6-query-execution-options"></a>6 параметры выполнения запроса

Entity Framework предлагает несколько различных способов запроса. Мы рассмотрим следующие варианты, Сравните преимущества и недостатки каждого из них и изучите их характеристики производительности:

-   LINQ to Entities.
-   Нет LINQ to Entities отслеживания.
-   Entity SQL ObjectQuery.
-   Entity SQL с помощью EntityCommand.
-   ExecuteStoreQuery.
-   SqlQuery.
-   CompiledQuery.

### <a name="61-linq-to-entities-queries"></a>6,1 LINQ to Entities запросов

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

**Преимущества**

-   Подходит для операций CUD.
-   Полностью Материализованные объекты.
-   Проще писать с помощью синтаксиса, встроенного в язык программирования.
-   Хорошая производительность.

**Недостатки**

-   Некоторые технические ограничения, например:
    -   Шаблоны, использующие DefaultIfEmpty для запросов внешнего объединения, приводят к более сложным запросам, чем простые инструкции внешнего объединения в Entity SQL.
    -   Вы по-прежнему не можете использовать, как в общем шаблоне сопоставления.

### <a name="62-no-tracking-linq-to-entities-queries"></a>6,2 нет запросов на отслеживание LINQ to Entities

Когда контекст является производным ObjectContext:

``` csharp
context.Products.MergeOption = MergeOption.NoTracking;
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

Когда контекст является производным DbContext:

``` csharp
var q = context.Products.AsNoTracking()
                        .Where(p => p.Category.CategoryName == "Beverages");
```

**Преимущества**

-   Улучшенная производительность по сравнению с обычными запросами LINQ.
-   Полностью Материализованные объекты.
-   Проще писать с помощью синтаксиса, встроенного в язык программирования.

**Недостатки**

-   Не подходит для операций CUD.
-   Некоторые технические ограничения, например:
    -   Шаблоны, использующие DefaultIfEmpty для запросов внешнего объединения, приводят к более сложным запросам, чем простые инструкции внешнего объединения в Entity SQL.
    -   Вы по-прежнему не можете использовать, как в общем шаблоне сопоставления.

Обратите внимание, что запросы, которые являются скалярными свойствами проекта, не отправляются, даже если не указан параметр-Track. Пример:

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages").Select(p => new { p.ProductName });
```

В этом конкретном запросе явно не указывается параметр WITH Tracking, но поскольку он не материализации тип, известный диспетчеру состояний объектов, материализованный результат не отслеживается.

### <a name="63-entity-sql-over-an-objectquery"></a>6,3 Entity SQL ObjectQuery

``` csharp
ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
```

**Преимущества**

-   Подходит для операций CUD.
-   Полностью Материализованные объекты.
-   Поддерживает кэширование планов запросов.

**Недостатки**

-   Включает текстовые строки запросов, которые более подвержены ошибкам пользователя, чем конструкции запросов, встроенные в язык.

### <a name="64-entity-sql-over-an-entity-command"></a>6,4 Entity SQL над командой сущности

``` csharp
EntityCommand cmd = eConn.CreateCommand();
cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
{
    while (reader.Read())
    {
        // manually 'materialize' the product
    }
}
```

**Преимущества**

-   Поддерживает кэширование планов запросов в .NET 4,0 (кэширование планов поддерживается всеми остальными типами запросов в .NET 4,5).

**Недостатки**

-   Включает текстовые строки запросов, которые более подвержены ошибкам пользователя, чем конструкции запросов, встроенные в язык.
-   Не подходит для операций CUD.
-   Результаты не сохранятся автоматически и должны считываться из модуля чтения данных.

### <a name="65-sqlquery-and-executestorequery"></a>6,5 SqlQuery и ExecuteStoreQuery

SqlQuery в базе данных:

``` csharp
// use this to obtain entities and not track them
var q1 = context.Database.SqlQuery<Product>("select * from products");
```

SqlQuery на DbSet:

``` csharp
// use this to obtain entities and have them tracked
var q2 = context.Products.SqlQuery("select * from products");
```

Ексецитесторекуери:

``` csharp
var beverages = context.ExecuteStoreQuery<Product>(
@"     SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued, P.DiscontinuedDate
       FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
       WHERE        (C.CategoryName = 'Beverages')"
);
```

**Преимущества**

-   Как правило, самая высокая производительность, так как компилятор планов обходится.
-   Полностью Материализованные объекты.
-   Подходит для операций CUD при использовании из DbSet.

**Недостатки**

-   Запрос является текстовым и подверженным ошибкам.
-   Запрос привязан к определенной серверной части с помощью семантики хранилища, а не концептуальной семантики.
-   При наличии наследования собственноручно созданные запрос должен учитывать условия сопоставления для запрошенного типа.

### <a name="66-compiledquery"></a>6,6 CompiledQuery

``` csharp
private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
    (NorthwindEntities context, string categoryName) =>
        context.Products.Where(p => p.Category.CategoryName == categoryName)
        );
…
var q = context.InvokeProductsForCategoryCQ("Beverages");
```

**Преимущества**

-   Обеспечивает повышение производительности до 7% по сравнению с регулярными запросами LINQ.
-   Полностью Материализованные объекты.
-   Подходит для операций CUD.

**Недостатки**

-   Повышенная сложность и затраты на программирование.
-   Улучшение производительности теряется при создании поверх скомпилированного запроса.
-   Некоторые запросы LINQ не могут быть записаны как CompiledQuery, например проекции анонимных типов.

### <a name="67-performance-comparison-of-different-query-options"></a>6,7 Сравнение производительности различных параметров запроса

Простые микротестовые тесты, в которых время создания контекста не было превышено в тест. Мы измеряем запросы 5000 раз для набора некэшированных сущностей в управляемой среде. Эти числа должны быть получены с помощью предупреждения: они не отображают фактические числа, создаваемые приложением, но они являются очень точным измерением того, насколько разница в производительности зависит от того, насколько разные варианты запросов сравниваются с яблоками, за исключением затрат на создание нового контекста.

| EF  | Тест                                 | Время (МС) | Память   |
|:----|:-------------------------------------|:----------|:---------|
| EF5 | ObjectContext ESQL                   | 2414      | 38801408 |
| EF5 | Запрос LINQ ObjectContext             | 2692      | 38277120 |
| EF5 | Запрос LINQ DbContext без отслеживания     | 2818      | 41840640 |
| EF5 | Запрос LINQ DbContext                 | 2930      | 41771008 |
| EF5 | Запрос на языке ObjectContext LINQ без отслеживания | 3013      | 38412288 |
|     |                                      |           |          |
| EF6 | ObjectContext ESQL                   | 2059      | 46039040 |
| EF6 | Запрос LINQ ObjectContext             | 3074      | 45248512 |
| EF6 | Запрос LINQ DbContext без отслеживания     | 3125      | 47575040 |
| EF6 | Запрос LINQ DbContext                 | 3420      | 47652864 |
| EF6 | Запрос на языке ObjectContext LINQ без отслеживания | 3593      | 45260800 |

![EF5 microических тестов, 5000 горячий итерации](~/ef6/media/ef5micro5000warm.png)

![EF6 microических тестов, 5000 горячий итерации](~/ef6/media/ef6micro5000warm.png)

Микротестовые тесты очень чувствительны к небольшим изменениям в коде. В этом случае разница между затратами Entity Framework 5 и Entity Framework 6 связана с добавлением [перехватов](xref:ef6/fundamentals/logging-and-interception) и [транзакционных усовершенствований](xref:ef6/saving/transactions). Однако эти номера микротестовых тестов — это концепция с повышенным зрением в очень небольшом фрагменте Entity Framework. Реальные сценарии горячий запрос не должны видеть регрессию производительности при обновлении с Entity Framework 5 до Entity Framework 6.

Чтобы сравнить реальную производительность различных параметров запроса, мы создали 5 отдельных вариантов тестирования, в которых мы используем другой вариант запроса, чтобы выбрать все продукты, имя категории которых — "напитки". Каждая итерация включает затраты на создание контекста и стоимость материализации всех возвращенных сущностей. 10 итераций выполняются неоднократно, прежде чем будет вычислить сумму 1000 итераций по времени. Отображаемые результаты — это медианный запуск, взятый из 5 запусков каждого теста. Дополнительные сведения см. в приложении б, которое содержит код для теста.

| EF  | Тест                                        | Время (МС) | Память   |
|:----|:--------------------------------------------|:----------|:---------|
| EF5 | Команда объекта ObjectContext                | 621       | 39350272 |
| EF5 | Запрос SQL DbContext в базе данных             | 825       | 37519360 |
| EF5 | Запрос к хранилищу ObjectContext                   | 878       | 39460864 |
| EF5 | Запрос на языке ObjectContext LINQ без отслеживания        | 969       | 38293504 |
| EF5 | Сущность SQL ObjectContext с использованием запроса объектов | 1089      | 38981632 |
| EF5 | Скомпилированный запрос ObjectContext                | 1099      | 38682624 |
| EF5 | Запрос LINQ ObjectContext                    | 1152      | 38178816 |
| EF5 | Запрос LINQ DbContext без отслеживания            | 1208      | 41803776 |
| EF5 | Запрос SQL DbContext в DbSet                | 1414      | 37982208 |
| EF5 | Запрос LINQ DbContext                        | 1574      | 41738240 |
|     |                                             |           |          |
| EF6 | Команда объекта ObjectContext                | 480       | 47247360 |
| EF6 | Запрос к хранилищу ObjectContext                   | 493       | 46739456 |
| EF6 | Запрос SQL DbContext в базе данных             | 614       | 41607168 |
| EF6 | Запрос на языке ObjectContext LINQ без отслеживания        | 684       | 46333952 |
| EF6 | Сущность SQL ObjectContext с использованием запроса объектов | 767       | 48865280 |
| EF6 | Скомпилированный запрос ObjectContext                | 788       | 48467968 |
| EF6 | Запрос LINQ DbContext без отслеживания            | 878       | 47554560 |
| EF6 | Запрос LINQ ObjectContext                    | 953       | 47632384 |
| EF6 | Запрос SQL DbContext в DbSet                | 1023      | 41992192 |
| EF6 | Запрос LINQ DbContext                        | 1290      | 47529984 |


![EF5 горячий запрос 1000 итерации](~/ef6/media/ef5warmquery1000.png)

![EF6 горячий запрос 1000 итерации](~/ef6/media/ef6warmquery1000.png)

> [!NOTE]
> Для полноты мы включили вариант, в котором мы выполняем Entity SQL запрос к EntityCommand. Однако поскольку результаты не сохранятся в таких запросах, сравнение не обязательно относится к яблокам. Тест включает в себя приближение для материализации, чтобы попытаться сделать более адекватным сравнение.

В этом комплексном случае Entity Framework 6 выполняет Entity Framework 5 из-за улучшений производительности в нескольких частях стека, включая гораздо более светлую инициализацию DbContext и более быстрые операции поиска Метадатаколлектион &lt; T &gt; .

## <a name="7-design-time-performance-considerations"></a>7. рекомендации по производительности во время разработки

### <a name="71-inheritance-strategies"></a>7,1 стратегии наследования

При использовании Entity Framework в качестве стратегии наследования следует учитывать еще одно снижение производительности. Entity Framework поддерживает три базовых типа наследования и их сочетания:

-   Таблица на иерархию (в каждой иерархии). Каждый набор наследования сопоставляется с таблицей со столбцом дискриминатора, чтобы указать, какой конкретный тип в иерархии представлен в строке.
-   Таблица на тип (TPT) — где каждый тип имеет собственную таблицу в базе данных; дочерние таблицы определяют только те столбцы, которые не содержат родительскую таблицу.
-   Таблица на класс (TPC) — где каждый тип имеет собственную полную таблицу в базе данных; дочерние таблицы определяют все их поля, включая те, которые определены в родительских типах.

Если модель использует наследование TPT, создаваемые запросы будут более сложными, чем созданные с помощью других стратегий наследования, что может привести к более длительному времени выполнения в хранилище.Как правило, создание запросов по модели TPT и формирование результирующих объектов занимает больше времени.

См. раздел "вопросы производительности при использовании наследования TPT (таблица на тип)" в Entity Framework "статьи блога MSDN: \<https://docs.microsoft.com/archive/blogs/adonet/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework> .

#### <a name="711-avoiding-tpt-in-model-first-or-code-first-applications"></a>7.1.1 предотвращение TPT в приложениях Model First или Code First

При создании модели для существующей базы данных, имеющей схему TPT, не существует много вариантов. Но при создании приложения с помощью Model First или Code First следует избегать наследования TPT для обеспечения производительности.

При использовании Model First в мастере Entity Designer будет получен TPT для любого наследования в модели. Если вы хотите переключиться на стратегию наследования с Model First, можно использовать "Entity Designer создания пакета управления базами данных", доступный в коллекции Visual Studio ( \<http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/> ).

При использовании Code First для настройки сопоставления модели с наследованием EF по умолчанию использует иерархическую подстановку, поэтому все сущности в иерархии наследования будут сопоставляться с одной и той же таблицей. Дополнительные сведения см. в разделе "сопоставление с API Fluent" статьи "Code First In Entity Framework 4.1" в журнале MSDN Magazine ( [http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx) ).

### <a name="72-upgrading-from-ef4-to-improve-model-generation-time"></a>7,2. обновление с EF4 для улучшения времени создания модели

SQL Serverное улучшение алгоритма, создающего уровень хранилища (SSDL) модели, доступно в Entity Framework 5 и 6, а также как обновление до Entity Framework 4 при установке Visual Studio 2010 с пакетом обновления 1 (SP1). Следующие результаты теста демонстрируют улучшение при создании очень большой модели, в данном случае в модели Navision. Дополнительные сведения о нем см. в приложении в.

Модель содержит 1005 наборов сущностей и 4227 наборов ассоциаций.

| Конфигурация                              | Распределение затраченного времени                                                                                                                                               |
|:-------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Visual Studio 2010, Entity Framework 4     | Создание SSDL: 2 часа 27 мин. <br/> Создание сопоставления: 1 секунда <br/> Создание языка CSDL: 1 секунда <br/> Создание Обжектлайер: 1 секунда <br/> Создание представления: 2 ч 14 мин |
| Visual Studio 2010 SP1, Entity Framework 4 | Создание SSDL: 1 секунда <br/> Создание сопоставления: 1 секунда <br/> Создание языка CSDL: 1 секунда <br/> Создание Обжектлайер: 1 секунда <br/> Создание представления: 1 ч 53 мин   |
| Visual Studio 2013, Entity Framework 5     | Создание SSDL: 1 секунда <br/> Создание сопоставления: 1 секунда <br/> Создание языка CSDL: 1 секунда <br/> Создание Обжектлайер: 1 секунда <br/> Создание представления: 65 минут    |
| Visual Studio 2013, Entity Framework 6     | Создание SSDL: 1 секунда <br/> Создание сопоставления: 1 секунда <br/> Создание языка CSDL: 1 секунда <br/> Создание Обжектлайер: 1 секунда <br/> Создание представления: 28 секунд.   |


Стоит отметить, что при создании SSDL нагрузка почти полностью потратила на SQL Server, тогда как компьютер разработки клиента ждет бездействия, чтобы вернуть результаты с сервера. Администраторы баз данных должны в особенной мере оценить это улучшение. Также стоит отметить, что фактически все затраты на создание модели происходят в выколении представления.

### <a name="73-splitting-large-models-with-database-first-and-model-first"></a>7,3. Разделение больших моделей с помощью Database First и Model First

При увеличении размера модели поверхность конструктора становится недостаточной и сложна для использования. Как правило, модель с более чем 300 сущностями имеет слишком большой размер для эффективного использования конструктора. В следующей записи блога описаны несколько вариантов разделения больших моделей: \<https://docs.microsoft.com/archive/blogs/adonet/working-with-large-models-in-entity-framework-part-2> .

Запись была написана для первой версии Entity Framework, но действия по-прежнему применимы.

### <a name="74-performance-considerations-with-the-entity-data-source-control"></a>7,4. вопросы производительности при использовании элемента управления источником данных сущности

Мы показали случаи, когда производительность веб-приложения, использующего элемент управления EntityDataSource, значительно снижается в многопоточных и нагрузочных тестах. Основная причина заключается в том, что EntityDataSource многократно вызывает пространство MetadataWorkspace. Лоадфромассембли для сборок, на которые ссылается веб-приложение, для обнаружения типов, которые будут использоваться в качестве сущностей.

Решение заключается в том, чтобы задать для свойства ContextTypeName элемента EntityDataSource имя типа производного класса ObjectContext. Это отключает механизм, который сканирует все сборки, на которые имеются ссылки, для типов сущностей.

Установка поля ContextTypeName также предотвращает функциональную проблему, когда EntityDataSource в .NET 4,0 создает исключение ReflectionTypeLoadException, когда не удается загрузить тип из сборки через отражение. Эта проблема исправлена в .NET 4,5.

### <a name="75-poco-entities-and-change-tracking-proxies"></a>7,5 сущности POCO и прокси отслеживания изменений

Entity Framework позволяет использовать пользовательские классы данных вместе с моделью данных, не внося никаких изменений в сами классы данных. Это означает, что с моделью данных могут быть использованы традиционные объекты среды CLR (POCO), например существующие объекты домена. Эти классы данных POCO (также называемые объектами сохраняемости игнорирующих), которые сопоставляются с сущностями, определенными в модели данных, поддерживают большинство аналогичных поведений запросов, вставки, обновления и удаления в виде типов сущностей, созданных инструментами EDM.

Entity Framework также могут создавать классы-посредники, производные от типов POCO, которые используются, если требуется включить такие функции, как отложенная загрузка и автоматическое отслеживание изменений для сущностей POCO. Классы POCO должны отвечать определенным требованиям, чтобы разрешить Entity Framework использовать прокси-серверы, как описано здесь: [http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx) .

При каждом изменении значения свойств сущностей учетные записи-посредники будут уведомлять диспетчер состояния объектов, поэтому Entity Framework знать фактическое состояние сущностей в любое время. Это делается путем добавления событий уведомления в тело методов задания свойств и при обработке таких событий диспетчером состояния объектов. Обратите внимание, что создание прокси-объекта, как правило, является более затратным, чем создание непрокси-объекта POCO из-за добавленного набора событий, созданных Entity Framework.

Если у сущности POCO нет прокси-сервера отслеживания изменений, то изменения будут обнаружены путем сравнения содержимого сущностей с копией предыдущего сохраненного состояния. Это глубокое сравнение станет длительным процессом, если в контексте имеется много сущностей или если сущности имеют очень большой объем свойств, даже если они не были изменены с момента последнего сравнения.

В сводке: при создании прокси отслеживания изменений будет взиматься снижение производительности, но отслеживание изменений поможет ускорить процесс обнаружения изменений, если у сущностей много свойств или если в модели имеется много сущностей. Для сущностей с небольшим количеством свойств, в которых количество сущностей не слишком велико, наличие прокси-серверов отслеживания изменений может быть не слишком большим преимуществом.

## <a name="8-loading-related-entities"></a>8 Загрузка связанных сущностей

### <a name="81-lazy-loading-vs-eager-loading"></a>8,1. отложенная загрузка и безотлагательная загрузка

Entity Framework предлагает несколько различных способов загрузки сущностей, связанных с целевой сущностью. Например, при запросе продуктов существуют различные способы загрузки связанных заказов в диспетчер состояний объектов. С точки зрения производительности, главный вопрос, который следует учитывать при загрузке связанных сущностей, будет использовать отложенную загрузку или безотлагательную загрузку.

При использовании безотлагательной загрузки связанные сущности загружаются вместе с целевым набором сущностей. Используйте инструкцию include в запросе, чтобы указать, в каких связанных сущностях вы хотите добавить.

При использовании отложенной загрузки начальный запрос переносится только в целевой набор сущностей. Но при каждом обращении к свойству навигации в хранилище создается другой запрос для загрузки связанной сущности.

После загрузки сущности все последующие запросы для сущности загружают его непосредственно из диспетчера состояний объектов независимо от того, используется ли отложенная загрузка или упреждающая загрузка.

### <a name="82-how-to-choose-between-lazy-loading-and-eager-loading"></a>8,2. Выбор между отложенной загрузкой и безотлагательной загрузкой

Важно то, что вы понимаете разницу между отложенной загрузкой и безотлагательной загрузкой, чтобы вы могли выбрать правильный вариант для вашего приложения. Это позволит оценить компромисс между несколькими запросами к базе данных и одним запросом, который может содержать большие полезные данные. Может быть целесообразно использовать безотлагательную загрузку в некоторых частях приложения и отложенную загрузку в других частях.

В качестве примера того, что происходит внутри, предположим, что вам нужно запросить клиентов, проживающих в Великобритании, и их количество заказов.

**Использование безотлагательной загрузки**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var ukCustomers = context.Customers.Include(c => c.Orders).Where(c => c.Address.Country == "UK");
    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

**Использование отложенной загрузки**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    context.ContextOptions.LazyLoadingEnabled = true;

    //Notice that the Include method call is missing in the query
    var ukCustomers = context.Customers.Where(c => c.Address.Country == "UK");

    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

При использовании безотлагательной загрузки вы выдаете один запрос, возвращающий всех клиентов и все заказы. Команда Store выглядит следующим образом:

``` SQL
SELECT
[Project1].[C1] AS [C1],
[Project1].[CustomerID] AS [CustomerID],
[Project1].[CompanyName] AS [CompanyName],
[Project1].[ContactName] AS [ContactName],
[Project1].[ContactTitle] AS [ContactTitle],
[Project1].[Address] AS [Address],
[Project1].[City] AS [City],
[Project1].[Region] AS [Region],
[Project1].[PostalCode] AS [PostalCode],
[Project1].[Country] AS [Country],
[Project1].[Phone] AS [Phone],
[Project1].[Fax] AS [Fax],
[Project1].[C2] AS [C2],
[Project1].[OrderID] AS [OrderID],
[Project1].[CustomerID1] AS [CustomerID1],
[Project1].[EmployeeID] AS [EmployeeID],
[Project1].[OrderDate] AS [OrderDate],
[Project1].[RequiredDate] AS [RequiredDate],
[Project1].[ShippedDate] AS [ShippedDate],
[Project1].[ShipVia] AS [ShipVia],
[Project1].[Freight] AS [Freight],
[Project1].[ShipName] AS [ShipName],
[Project1].[ShipAddress] AS [ShipAddress],
[Project1].[ShipCity] AS [ShipCity],
[Project1].[ShipRegion] AS [ShipRegion],
[Project1].[ShipPostalCode] AS [ShipPostalCode],
[Project1].[ShipCountry] AS [ShipCountry]
FROM ( SELECT
      [Extent1].[CustomerID] AS [CustomerID],
       [Extent1].[CompanyName] AS [CompanyName],
       [Extent1].[ContactName] AS [ContactName],
       [Extent1].[ContactTitle] AS [ContactTitle],
       [Extent1].[Address] AS [Address],
       [Extent1].[City] AS [City],
       [Extent1].[Region] AS [Region],
       [Extent1].[PostalCode] AS [PostalCode],
       [Extent1].[Country] AS [Country],
       [Extent1].[Phone] AS [Phone],
       [Extent1].[Fax] AS [Fax],
      1 AS [C1],
       [Extent2].[OrderID] AS [OrderID],
       [Extent2].[CustomerID] AS [CustomerID1],
       [Extent2].[EmployeeID] AS [EmployeeID],
       [Extent2].[OrderDate] AS [OrderDate],
       [Extent2].[RequiredDate] AS [RequiredDate],
       [Extent2].[ShippedDate] AS [ShippedDate],
       [Extent2].[ShipVia] AS [ShipVia],
       [Extent2].[Freight] AS [Freight],
       [Extent2].[ShipName] AS [ShipName],
       [Extent2].[ShipAddress] AS [ShipAddress],
       [Extent2].[ShipCity] AS [ShipCity],
       [Extent2].[ShipRegion] AS [ShipRegion],
       [Extent2].[ShipPostalCode] AS [ShipPostalCode],
       [Extent2].[ShipCountry] AS [ShipCountry],
      CASE WHEN ([Extent2].[OrderID] IS NULL) THEN CAST(NULL AS int) ELSE 1 END AS [C2]
      FROM  [dbo].[Customers] AS [Extent1]
      LEFT OUTER JOIN [dbo].[Orders] AS [Extent2] ON [Extent1].[CustomerID] = [Extent2].[CustomerID]
      WHERE N'UK' = [Extent1].[Country]
)  AS [Project1]
ORDER BY [Project1].[CustomerID] ASC, [Project1].[C2] ASC
```

При использовании отложенной загрузки вы сначала выполните следующий запрос:

``` SQL
SELECT
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[CompanyName] AS [CompanyName],
[Extent1].[ContactName] AS [ContactName],
[Extent1].[ContactTitle] AS [ContactTitle],
[Extent1].[Address] AS [Address],
[Extent1].[City] AS [City],
[Extent1].[Region] AS [Region],
[Extent1].[PostalCode] AS [PostalCode],
[Extent1].[Country] AS [Country],
[Extent1].[Phone] AS [Phone],
[Extent1].[Fax] AS [Fax]
FROM [dbo].[Customers] AS [Extent1]
WHERE N'UK' = [Extent1].[Country]
```

И каждый раз, когда вы обращаетесь к свойству навигации Orders клиента, для магазина выдается еще один запрос, аналогичный приведенному ниже.

``` SQL
exec sp_executesql N'SELECT
[Extent1].[OrderID] AS [OrderID],
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[EmployeeID] AS [EmployeeID],
[Extent1].[OrderDate] AS [OrderDate],
[Extent1].[RequiredDate] AS [RequiredDate],
[Extent1].[ShippedDate] AS [ShippedDate],
[Extent1].[ShipVia] AS [ShipVia],
[Extent1].[Freight] AS [Freight],
[Extent1].[ShipName] AS [ShipName],
[Extent1].[ShipAddress] AS [ShipAddress],
[Extent1].[ShipCity] AS [ShipCity],
[Extent1].[ShipRegion] AS [ShipRegion],
[Extent1].[ShipPostalCode] AS [ShipPostalCode],
[Extent1].[ShipCountry] AS [ShipCountry]
FROM [dbo].[Orders] AS [Extent1]
WHERE [Extent1].[CustomerID] = @EntityKeyValue1',N'@EntityKeyValue1 nchar(5)',@EntityKeyValue1=N'AROUT'
```

Дополнительные сведения см. в разделе [Загрузка связанных объектов](https://msdn.microsoft.com/library/bb896272.aspx).

#### <a name="821-lazy-loading-versus-eager-loading-cheat-sheet"></a>8.2.1 отложенная загрузка и непрямое Загрузка Памятка по листа

Нет ничего такого, чтобы выбрать неленивую загрузку и отложенную загрузку. Сначала попробуйте понять различия между обеими стратегиями, чтобы вы могли принимать взвешенные решения. Кроме того, рассмотрим, подходит ли код для любого из следующих сценариев:

| Сценарий                                                                    | Наше предложение                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|:----------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Требуется ли доступ ко многим свойствам навигации из выбранных сущностей? | Оба варианта, вероятно **, не будут** . Тем не менее, если полезная нагрузка, используемая запросом, не слишком велика, вы можете столкнуться с производительностью с помощью безотлагательной загрузки, так как для материализации объектов требуется меньшее количество циклов передачи по сети. <br/> <br/> **Да** . Если необходимо получить доступ ко многим свойствам навигации из сущностей, это можно сделать с помощью нескольких инструкций include в запросе с безотлагательной загрузкой. Чем больше сущностей вы включаете, тем больше полезных данных, которые будет возвращать запрос. После включения в запрос трех или более сущностей рассмотрите возможность переключения на отложенную загрузку. |
| Точно известно, какие данные потребуются во время выполнения?                   | **No** Неленивая загрузка будет лучше. В противном случае может оказаться, что запрос данных будет ненужным. <br/> <br/> **Да** — возможно, вам подойдет самый подходящий элемент. Это поможет ускорить загрузку целых наборов. Если запрос требует выборки очень большого объема данных, и это происходит слишком быстро, попробуйте вместо этого использовать отложенную загрузку.                                                                                                                                                                                                                                                       |
| Код выполнялся далеко из базы данных? (Увеличенная задержка сети)  | **Нет** — если задержка в сети не является проблемой, использование отложенной загрузки может упростить код. Помните, что топология приложения может изменяться, поэтому не следует использовать базу данных для предоставления разрешений. <br/> <br/> **Да** . Если сеть является проблемой, вы можете решить, что именно лучше подходит для вашего сценария. Обычно упреждающая загрузка будет лучше, так как для нее требуется меньше циклов обработки.                                                                                                                                                                                                      |


#### <a name="822-performance-concerns-with-multiple-includes"></a>8.2.2 проблемы с производительностью с помощью нескольких включений

Когда мы будем слышать вопросы о производительности, связанные с проблемами времени ответа сервера, источником проблемы часто являются запросы с несколькими инструкциями include. Хотя связанные сущности в запросе являются мощными, важно понимать, что происходит на самом деле.

Запрос с несколькими инструкциями include в нем занимает относительно много времени, чтобы пройти внутренний компилятор плана для создания команды Store. Большая часть этого времени потратила на попытку оптимизации результирующего запроса. Созданная команда хранилища будет содержать внешнее соединение или объединение для каждого включаемого объекта в зависимости от сопоставления. Такие запросы будут использовать большие подключенные графы из базы данных в одной полезной нагрузке, что будет ацербате любые проблемы с пропускной способностью, особенно при большом объеме полезных данных (например, если для обхода ассоциаций в направлении «один ко многим» используется несколько уровней включения).

Можно проверить случаи, когда запросы возвращают чрезмерно большие полезные данные, обращаясь к соответствующему TSQL для запроса с помощью ToTraceString и выполнив команду Store в SQL Server Management Studio, чтобы увидеть размер полезных данных. В таких случаях можно попытаться сократить количество инструкций include в запросе, чтобы просто перенести нужные данные. Вы также можете разбить запрос на более низкую последовательность вложенных запросов, например:

**Прежде чем прерывать запрос:**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var customers = from c in context.Customers.Include(c => c.Orders)
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

**После прерывания запроса:**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var orders = from o in context.Orders
                 where o.Customer.LastName.StartsWith(lastNameParameter)
                 select o;

    orders.Load();

    var customers = from c in context.Customers
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

Это будет работать только с отслеживанием запросов, так как мы используем возможность, чтобы контекст мог автоматически выполнять разрешение удостоверения и привязку привязок.

Как и при отложенной загрузке, компромисс будет больше запросов для небольших полезных данных. Можно также использовать проекции отдельных свойств, чтобы явно выбирать только те данные, которые необходимы для каждой сущности, но в этом случае не будет загружать сущности, а обновления не будут поддерживаться.

#### <a name="823-workaround-to-get-lazy-loading-of-properties"></a>обходной путь 8.2.3 для получения отложенной загрузки свойств

Entity Framework в настоящее время не поддерживает отложенную загрузку скалярных или сложных свойств. Однако в случаях, когда имеется таблица, включающая большой объект, например BLOB-объекты, можно использовать разбиение таблицы для разделения больших свойств на отдельную сущность. Например, предположим, что имеется таблица Product, включающая в себя столбец с фотографиями типа varbinary. Если вам часто не требуется доступ к этому свойству в запросах, можно использовать разделение таблиц, чтобы привести только к тем частям сущности, которые обычно требуются. Сущность, представляющая фотографию продукта, будет загружена только в том случае, если она явно нужна.

Хорошим ресурсом, показывающим, как включить разделение таблицы, является Джил Финк «разделение таблицы» в записи блога «Entity Framework»: \<http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx> .

## <a name="9-other-considerations"></a>9 других вопросов

### <a name="91-server-garbage-collection"></a>Сборка мусора сервера 9,1

Некоторые пользователи могут столкнуться с состязанием за ресурсы, которые ограничивают ожидаемый параллелизм при неправильной настройке сборщика мусора. При использовании EF в многопоточном сценарии или в любом приложении, похожем на серверную систему, обязательно включите сборку мусора сервера. Это делается с помощью простого параметра в файле конфигурации приложения:

``` xml
<?xmlversion="1.0" encoding="utf-8" ?>
<configuration>
        <runtime>
               <gcServer enabled="true" />
        </runtime>
</configuration>
```

Это должно уменьшить состязание за поток и увеличить пропускную способность до 30% в сценариях с насыщенным использованием ЦП. В общих чертах следует всегда тестировать работу приложения с помощью классической сборки мусора (которая лучше настроена для сценариев пользовательского интерфейса и клиента), а также для сборки мусора сервера.

### <a name="92-autodetectchanges"></a>9,2 Аутодетектчанжес

Как упоминалось ранее, Entity Framework может показывать проблемы с производительностью, если в кэше объектов содержится много сущностей. Некоторые операции, такие как добавление, удаление, поиск, запись и SaveChanges, инициируют вызовы DetectChanges, которые могут потреблять большой объем ресурсов ЦП в зависимости от размера кэша объектов. Причина в том, что кэш объектов и диспетчер состояний объектов пытаются обеспечить максимально возможную синхронизацию при каждой операции, выполняемой в контексте, чтобы гарантировать правильность данных в широком массиве сценариев.

Как правило, рекомендуется оставить автоматическое обнаружение изменений Entity Framework включенным для всего жизненного цикла приложения. Если ваш сценарий отрицательно сказывается на высокой загрузке ЦП, а профили указывают на то, что это вызов DetectChanges, попробуйте временно отключить Аутодетектчанжес в конфиденциальной части кода:

``` csharp
try
{
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    ...
}
finally
{
    context.Configuration.AutoDetectChangesEnabled = true;
}
```

Прежде чем отключить Аутодетектчанжес, лучше понять, что это может привести к тому, что Entity Framework потерять возможность отслеживания определенных сведений об изменениях, происходящих в сущностях. В случае неправильной обработки это может привести к несогласованности данных в приложении. Дополнительные сведения о выключении Аутодетектчанжес см. в статье \<http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/> .

### <a name="93-context-per-request"></a>9,3. контекст на запрос

Контексты Entity Framework предназначены для использования в качестве кратковременных экземпляров, чтобы обеспечить наиболее оптимальное функционирование. Предполагается, что контексты имеют короткий срок существования и отбрасываются, и, по возможности, они были очень простыми и используют метаданные, когда это возможно. В веб-сценариях важно помнить о том, что контекст не должен превышать длительность одного запроса. Аналогично, в сценариях, отличных от веб-служб, контекст следует отменять в зависимости от понимания различных уровней кэширования в Entity Framework. В целом, одна из них не должна иметь экземпляр контекста в течение всего жизненного цикла приложения, а также контексты для каждого потока и статических контекстов.

### <a name="94-database-null-semantics"></a>9,4 семантика NULL базы данных

Entity Framework по умолчанию будет создавать код SQL с \# семантикой сравнения C NULL. Рассмотрим следующий запрос:

``` csharp
            int? categoryId = 7;
            int? supplierId = 8;
            decimal? unitPrice = 0;
            short? unitsInStock = 100;
            short? unitsOnOrder = 20;
            short? reorderLevel = null;

            var q = from p incontext.Products
                    wherep.Category.CategoryName == "Beverages"
                          || (p.CategoryID == categoryId
                                || p.SupplierID == supplierId
                                || p.UnitPrice == unitPrice
                                || p.UnitsInStock == unitsInStock
                                || p.UnitsOnOrder == unitsOnOrder
                                || p.ReorderLevel == reorderLevel)
                    select p;

            var r = q.ToList();
```

В этом примере мы сравниваем число переменных, допускающих значение null, по отношению к свойствам, допускающим значение null, в сущности, например «КодПоставщика» и «цена». Созданный SQL для этого запроса запрашивает, совпадает ли значение параметра со значением столбца, или если оба параметра и значения столбца равны NULL. Это приведет к скрытию способа обработки значений NULL сервером базы данных и обеспечения согласованного \# интерфейса C NULL для разных поставщиков баз данных. С другой стороны, созданный код является немного сложные и может не работать, когда количество сравнений в инструкции WHERE запроса увеличивается до большого числа.

Одним из способов решения этой ситуации является использование семантики значений NULL базы данных. Обратите внимание, что это может вести себя по-разному для \# семантики C NULL, так как теперь Entity Framework создаст упрощенный SQL, предоставляющий способ обработки значений NULL ядром СУБД. Семантика значений NULL базы данных может быть активирована для каждого контекста с одной отдельной строкой конфигурации в соответствии с конфигурацией контекста:

``` csharp
                context.Configuration.UseDatabaseNullSemantics = true;
```

Запросы малых и средних размеров не отображают заметный рост производительности при использовании семантики NULL базы данных, но разница становится более заметной для запросов с большим количеством возможных сравнений null.

В приведенном выше примере запроса разница в производительности была менее 2% в микротесте, работающем в управляемой среде.

### <a name="95-async"></a>9,5 Async

В Entity Framework 6 появилась поддержка асинхронных операций при работе в .NET 4,5 или более поздней версии. В большинстве случаев для приложений с состязанием, связанным с операциями ввода-вывода, будет выгоднее использовать асинхронные запросы и операции сохранения. Если в приложении не страдает состязание за операции ввода-вывода, использование Async в лучших случаях будет выполняться синхронно и вернуть результат в то же время, что и синхронный вызов, или в худшем случае просто отложить выполнение на асинхронную задачу и добавить дополнительное время к завершению вашего сценария.

Сведения о том, как работает асинхронное программирование, которое поможет решить, может ли асинхронно поспособствовать повышению производительности посещения приложения [http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx) . Дополнительные сведения об использовании асинхронных операций с Entity Framework см. в разделе [Async Query и Save](xref:ef6/fundamentals/async
).

### <a name="96-ngen"></a>9,6 NGEN

Entity Framework 6 не входят в установку .NET Framework по умолчанию. Таким образом, Entity Framework сборки по умолчанию не являются NGEN. Это означает, что весь код Entity Framework подчиняются тем же Жит'инг затратам, что и любая другая сборка MSIL. Это может привести к снижению возможностей F5 при разработке, а также к холодному запуску приложения в рабочей среде. Чтобы сократить затраты ресурсов ЦП и памяти на Жит'инг, рекомендуется при необходимости NGEN Entity Framework образов. Дополнительные сведения о том, как повысить производительность при запуске Entity Framework 6 с помощью генератора NGEN, см. в статье [повышение производительности при запуске с помощью генератора NGen](xref:ef6/fundamentals/performance/ngen).

### <a name="97-code-first-versus-edmx"></a>9,7 Code First и EDMX

Entity Framework причины несоответствия проблем между объектно-ориентированным программированием и реляционными базами данных путем наличия в памяти представления концептуальной модели (объектов), схемы хранения (базы данных) и сопоставления между ними. Эти метаданные называются EDM или моделью EDM для краткости. Из этой модели EDM Entity Framework выводят представления для получения данных из объектов в памяти в базу данных и обратно.

Если Entity Framework используется с EDMX-файлом, который формально указывает концептуальную модель, схему хранилища и сопоставление, то стадия загрузки модели должна проверять правильность модели EDM (например, убедиться, что нет отсутствующих сопоставлений), затем сформировать представления, затем проверить представления и подготовить эти метаданные к использованию. Только после этого можно выполнить запрос или сохранить новые данные в хранилище данных.

Code First подход — это, в свою основу, сложный генератор EDM. Entity Framework должен создать модель EDM из предоставленного кода; Это осуществляется путем анализа классов, участвующих в модели, применения соглашений и настройки модели через API Fluent. После построения модели EDM Entity Framework, по сути, ведет себя так же, как при наличии файла EDMX в проекте. Поэтому создание модели из Code First добавляет дополнительную сложность, которая преобразуется в медленный период запуска Entity Framework по сравнению с наличием EDMX. Стоимость полностью зависит от размера и сложности создаваемой модели.

При выборе использования EDMX и Code First важно помнить, что гибкость, появившаяся в Code First, увеличивает затраты на сборку модели в первый раз. Если приложение может выдерживать затраты на эту загрузку первого раза, обычно Code First будет предпочтительным способом.

## <a name="10-investigating-performance"></a>10 исследование производительности

### <a name="101-using-the-visual-studio-profiler"></a>10,1. Использование профилировщика Visual Studio

При возникновении проблем с производительностью Entity Framework можно использовать профилировщик, встроенный в Visual Studio, чтобы узнать, где тратится ваше приложение на свое время. Это средство, которое мы использовали для создания круговых диаграмм в разделе «Исследование производительности ADO.NET Entity Framework-Part 1» ( \<https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1> ), которое показывает, где Entity Framework тратит время во время холодного и горячего запроса.

В записи блога "профилирование Entity Framework с помощью профилировщика Visual Studio 2010", написанной группой консультирования клиентов по данным и моделированию, представлен реальный пример использования профилировщика для исследования проблемы с производительностью   \<https://docs.microsoft.com/archive/blogs/dmcat/profiling-entity-framework-using-the-visual-studio-2010-profiler> . Эта запись была написана для приложения Windows. Если необходимо профилировать веб-приложение, средства записи производительности Windows (ЗВЧ) и анализатор производительности Windows (WPA) могут работать лучше, чем при работе с Visual Studio. ЗВЧ и WPA являются частью набора средств производительности Windows, включенного в комплект средств для развертывания и оценки Windows ( [http://www.microsoft.com/download/details.aspx?id=39982](https://www.microsoft.com/download/details.aspx?id=39982) ).

### <a name="102-applicationdatabase-profiling"></a>10,2. Профилирование приложения/базы данных

Такие средства, как профилировщик, встроенный в Visual Studio, показывают, где ваше приложение тратит время.Доступен еще один тип профилировщика, который выполняет динамический анализ работающего приложения в рабочей среде или в предварительной рабочей среде в зависимости от потребностей, а также ищет распространенные ловушки и защиту доступа к базам данных.

Два доступных в коммерческой основе профилировщика — это Entity Framework Profiler ( \<http://efprof.com> ) и ормпрофилер ( \<http://ormprofiler.com> ).

Если приложение является приложением MVC с помощью Code First, можно использовать MiniProfiler StackExchange. Скотт Hanselman описывает это средство в своем блоге по адресу: \<http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx> .

Дополнительные сведения о профилировании действий с базами данных в приложении см. в статье о том, как Джулия Лерман, озаглавленная ["профилирование действий базы данных" в Entity Framework](https://msdn.microsoft.com/magazine/gg490349.aspx).

### <a name="103-database-logger"></a>10,3. средство ведения журнала базы данных

Если вы используете Entity Framework 6, рассмотрите возможность использования встроенных функций ведения журнала. В качестве значения свойства базы данных контекста можно указать ведение журнала действий с помощью простой однострочной конфигурации:

``` csharp
    using (var context = newQueryComparison.DbC.NorthwindEntities())
    {
        context.Database.Log = Console.WriteLine;
        var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
        q.ToList();
    }
```

В этом примере действие базы данных будет зарегистрировано в консоли, но свойство Log может быть настроено для вызова любого &lt; &gt; делегата строки действия.

Если вы хотите включить ведение журнала базы данных без перекомпиляции и вы используете Entity Framework 6,1 или более поздней версии, это можно сделать, добавив перехватчик в web.config или app.config файл приложения.

``` xml
  <interceptors>
    <interceptor type="System.Data.Entity.Infrastructure.Interception.DatabaseLogger, EntityFramework">
      <parameters>
        <parameter value="C:\Path\To\My\LogOutput.txt"/>
      </parameters>
    </interceptor>
  </interceptors>
```

Дополнительные сведения о том, как добавить ведение журнала без повторной компиляции, см. на странице \<http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/> .

## <a name="11-appendix"></a>11 приложение

### <a name="111-a-test-environment"></a>11,1. тестовая среда

В этом окружении используется установка 2 компьютера с базой данных на отдельном компьютере из клиентского приложения. Компьютеры находятся в одной стойке, поэтому задержка в сети относительно низкая, но более реалистичной, чем среда с одним компьютером.

#### <a name="1111-app-server"></a>Сервер приложений 11.1.1

##### <a name="11111-software-environment"></a>Программная среда 11.1.1.1

-   Программная среда Entity Framework 4
    -   Имя ОС: Windows Server 2008 R2 Enterprise с пакетом обновления 1 (SP1).
    -   Visual Studio 2010 — Ultimate.
    -   Visual Studio 2010 с пакетом обновления 1 (SP1) (только для некоторых сравнений).
-   Entity Framework 5 и 6 программной среды
    -   Имя ОС: Windows 8.1 Enterprise
    -   Visual Studio 2013 — Ultimate.

##### <a name="11112-hardware-environment"></a>аппаратная среда 11.1.1.2

-   Два процессора: Intel (R) Xeon (R) CPU L5520 W3530 @ 2.27 ГГц, 2261 Mhz8 ГГц, 4 ядра, 84 логических процессоров.
-   2412 ГБ Рамрам.
-   136 ГБ SCSI250GB SATA 7200 RPM/s диск делится на 4 раздела.

#### <a name="1112-db-server"></a>сервер 11.1.2 DB

##### <a name="11121-software-environment"></a>Программная среда 11.1.2.1

-   Имя ОС: Windows Server 2008 R 28.1 Enterprise SP1.
-   SQL Server 2008 R22012.

##### <a name="11122-hardware-environment"></a>аппаратная среда 11.1.2.2

-   Один процессор: Intel (R) Xeon (R) CPU L5520 @ 2.27 ГГц, 2261 Мхзес-1620 0 @ 3,60 ГГц, 4 ядра, 8 логических процессоров.
-   824 ГБ Рамрам.
-   465 ГБ ATA500GB SATA 7200 RPM 6 ГБ/s разделить на 4 раздела.

### <a name="112-b-query-performance-comparison-tests"></a>11,2. Тестирование сравнения производительности запросов

Для выполнения этих тестов использовалась модель Northwind. Он был создан из базы данных с помощью конструктора Entity Framework. Затем для сравнения производительности параметров выполнения запроса использовался следующий код:

``` csharp
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.Entity.Infrastructure;
using System.Data.EntityClient;
using System.Data.Objects;
using System.Linq;

namespace QueryComparison
{
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
                );

        public IQueryable<Product> InvokeProductsForCategoryCQ(string categoryName)
        {
            return productsForCategoryCQ(this, categoryName);
        }
    }

    public class QueryTypePerfComparison
    {
        private static string entityConnectionStr = @"metadata=res://*/Northwind.csdl|res://*/Northwind.ssdl|res://*/Northwind.msl;provider=System.Data.SqlClient;provider connection string='data source=.;initial catalog=Northwind;integrated security=True;multipleactiveresultsets=True;App=EntityFramework'";

        public void LINQIncludingContextCreation()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTracking()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                context.Products.MergeOption = MergeOption.NoTracking;

                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void CompiledQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                var q = context.InvokeProductsForCategoryCQ("Beverages");
                q.ToList();
            }
        }

        public void ObjectQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
                products.ToList();
            }
        }

        public void EntityCommand()
        {
            using (EntityConnection eConn = new EntityConnection(entityConnectionStr))
            {
                eConn.Open();
                EntityCommand cmd = eConn.CreateCommand();
                cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

                using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
                {
                    List<Product> productsList = new List<Product>();
                    while (reader.Read())
                    {
                        DbDataRecord record = (DbDataRecord)reader.GetValue(0);

                        // 'materialize' the product by accessing each field and value. Because we are materializing products, we won't have any nested data readers or records.
                        int fieldCount = record.FieldCount;

                        // Treat all products as Product, even if they are the subtype DiscontinuedProduct.
                        Product product = new Product();  

                        product.ProductID = record.GetInt32(0);
                        product.ProductName = record.GetString(1);
                        product.SupplierID = record.GetInt32(2);
                        product.CategoryID = record.GetInt32(3);
                        product.QuantityPerUnit = record.GetString(4);
                        product.UnitPrice = record.GetDecimal(5);
                        product.UnitsInStock = record.GetInt16(6);
                        product.UnitsOnOrder = record.GetInt16(7);
                        product.ReorderLevel = record.GetInt16(8);
                        product.Discontinued = record.GetBoolean(9);

                        productsList.Add(product);
                    }
                }
            }
        }

        public void ExecuteStoreQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectResult<Product> beverages = context.ExecuteStoreQuery<Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Database.SqlQuery\<QueryComparison.DbC.Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbSet()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Products.SqlQuery(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void LINQIncludingContextCreationDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTrackingDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var q = context.Products.AsNoTracking().Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }
    }
}
```

### <a name="113-c-navision-model"></a>11,3 C. Navision, модель

База данных Navision — это большая база данных, используемая для демонстрации Microsoft Dynamics – NAV. Созданная концептуальная модель содержит 1005 наборов сущностей и 4227 наборов ассоциаций. Модель, используемая в тесте, имеет плоский характер — в нее не Добавлено наследование.

#### <a name="1131-queries-used-for-navision-tests"></a>запросы 11.3.1, используемые для тестов Navision

Список запросов, используемый в модели Navision, содержит 3 категории Entity SQL запросов:

##### <a name="11311-lookup"></a>11.3.1.1 Поиск

Простой запрос уточняющего запроса без агрегатов

-   Число: 16232
-   Пример:

``` xml
  <Query complexity="Lookup">
    <CommandText>Select value distinct top(4) e.Idle_Time From NavisionFKContext.Session as e</CommandText>
  </Query>
```

##### <a name="11312singleaggregating"></a>11.3.1.2 Синглеаггрегатинг

Стандартный запрос BI с несколькими агрегатами, но без промежуточных итогов (один запрос)

-   Число: 2313
-   Пример:

``` xml
  <Query complexity="SingleAggregating">
    <CommandText>NavisionFK.MDF_SessionLogin_Time_Max()</CommandText>
  </Query>
```

Где \_ \_ \_ в модели для MDF сессионлогин Time Max () определено значение:

``` xml
  <Function Name="MDF_SessionLogin_Time_Max" ReturnType="Collection(DateTime)">
    <DefiningExpression>SELECT VALUE Edm.Min(E.Login_Time) FROM NavisionFKContext.Session as E</DefiningExpression>
  </Function>
```

##### <a name="11313aggregatingsubtotals"></a>11.3.1.3 Аггрегатингсубтоталс

Запрос бизнес-аналитики с агрегатами и промежуточными итогами (через UNION ALL)

-   Число: 178
-   Пример:

``` xml
  <Query complexity="AggregatingSubtotals">
    <CommandText>
using NavisionFK;
function AmountConsumed(entities Collection([CRONUS_International_Ltd__Zone])) as
(
    Edm.Sum(select value N.Block_Movement FROM entities as E, E.CRONUS_International_Ltd__Bin as N)
)
function AmountConsumed(P1 Edm.Int32) as
(
    AmountConsumed(select value e from NavisionFKContext.CRONUS_International_Ltd__Zone as e where e.Zone_Ranking = P1)
)
----------------------------------------------------------------------------------------------------------------------
(
    select top(10) Zone_Ranking, Cross_Dock_Bin_Zone, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking, E.Cross_Dock_Bin_Zone
)
union all
(
    select top(10) Zone_Ranking, Cast(null as Edm.Byte) as P2, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking
)
union all
{
    Row(Cast(null as Edm.Int32) as P1, Cast(null as Edm.Byte) as P2, AmountConsumed(select value E
                                                                         from NavisionFKContext.CRONUS_International_Ltd__Zone as E
                                                                         where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed))
}</CommandText>
    <Parameters>
      <Parameter Name="MinAmountConsumed" DbType="Int32" Value="10000" />
    </Parameters>
  </Query>
```
