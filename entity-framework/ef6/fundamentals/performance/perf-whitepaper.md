---
title: Соображения производительности для EF4, EF5 и EF6 - EF6
author: divega
ms.date: 10/23/2016
ms.assetid: d6d5a465-6434-45fa-855d-5eb48c61a2ea
ms.openlocfilehash: 0ece383bb5083b41c7a2636c009473333af6d3e2
ms.sourcegitcommit: 144edccf9b29a7ffad119c235ac9808ec1a46193
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2020
ms.locfileid: "81434343"
---
# <a name="performance-considerations-for-ef-4-5-and-6"></a>Соображения производительности для EF 4, 5 и 6
Дэвид Оландо, Эрик Деттингер и другие

Опубликовано: Апрель 2012

Последнее обновление: май 2014 г.

------------------------------------------------------------------------

## <a name="1-introduction"></a>1. Введение

Платформы объектно-реляционного картирования — это удобный способ обеспечить абстракцию для доступа к данным в объектно-ориентированном приложении. Для приложений .NET рекомендуемая корпорация Майкрософт O/RM является системой Entity Framework. С любой абстракции, хотя, производительность может стать проблемой.

Этот документ был написан, чтобы показать соображения производительности при разработке приложений с использованием Entity Framework, дать разработчикам представление о внутренних алгоритмах Entity Framework, которые могут повлиять на производительность, и предоставить советы по исследованию и повышению производительности в своих приложениях, использующих рамки сущности. Есть ряд хороших тем по производительности уже доступны в Интернете, и мы также пытались указывая на эти ресурсы, где это возможно.

Производительность является сложной темой. Этот информационный документ предназначен в качестве ресурса, который поможет вам принимать решения, связанные с производительностью, для приложений, которые используют рамки сущности. Мы включили некоторые тестовые метрики, чтобы продемонстрировать производительность, но эти показатели не предназначены в качестве абсолютных показателей производительности, которые вы увидите в приложении.

Для практических целей этот документ предполагает, что Рамочная система сущности 4 работает в соответствии с .NET 4.0, а Рамочная система сущности 5 и 6 — под .NET 4.5. Многие улучшения производительности, сделанные для Entity Framework 5, находятся в основных компонентах, которые появляются с .NET 4.5.

Entity Framework 6 является выходом из диапазона и не зависит от компонентов Entity Framework, которые появляются с .NET. Система Entity Framework 6 работает как на .NET 4.0, так и на .NET 4.5, и может предложить большую выгоду для производительности для тех, кто еще не обновился с .NET 4.0, но хочет последние биты Entity Framework в их приложении. Когда в этом документе упоминается рамка сущности 6, он ссылается на последнюю версию, доступную на момент написания настоящего письма: версия 6.1.0.

## <a name="2-cold-vs-warm-query-execution"></a>2. Холод против теплого исполнения запросов

При первом запросе, который выполняется в отношении данной модели, система entity Framework выполняет большую работу за кулисами для загрузки и проверки модели. Мы часто называем этот первый запрос «холодным».Дальнейшие запросы в отношении уже загруженной модели известны как "теплые" запросы и гораздо быстрее.

Давайте рассмотрим, где время тратится на выполнение запроса с использованием рамочного образования, и посмотрим, где ситуация улучшается в рамках entity 6.

**Первое выполнение запроса - холодный запрос**

| Записывает код пользователя                                                                                     | Действие                    | Влияние производительности EF4                                                                                                                                                                                                                                                                                                                                                                                                        | Влияние производительности EF5                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Влияние производительности EF6                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | Создание контекста          | Средний                                                                                                                                                                                                                                                                                                                                                                                                                        | Средний                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | Создание выражения запроса | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                           | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var c1 = q1.First();`                                                                             | Выполнение запроса LIN's      | - Метаданные загрузки: высокая, но кэшированная <br/> - Представление поколения: Потенциально очень высокий, но кэшированный <br/> - Оценка параметров: Средний <br/> - Перевод запроса: Средний <br/> - Материализатор поколения: Средний, но кэшированный <br/> - Выполнение запроса базы данных: потенциально высокий <br/> Подключение.Открытый <br/> - Command.ExecuteReader <br/> - DataReader.Read <br/> Материализация объекта: Средний <br/> - Идентификационный поиск: Средний | - Метаданные загрузки: высокая, но кэшированная <br/> - Представление поколения: Потенциально очень высокий, но кэшированный <br/> - Оценка параметров: Низкая <br/> - Перевод запроса: Средний, но кэшированный <br/> - Материализатор поколения: Средний, но кэшированный <br/> - Выполнение запроса базы данных: потенциально высокий (лучшие запросы в некоторых ситуациях) <br/> Подключение.Открытый <br/> - Command.ExecuteReader <br/> - DataReader.Read <br/> Материализация объекта: Средний <br/> - Идентификационный поиск: Средний | - Метаданные загрузки: высокая, но кэшированная <br/> - Представление поколения: Средний, но кэшированный <br/> - Оценка параметров: Низкая <br/> - Перевод запроса: Средний, но кэшированный <br/> - Материализатор поколения: Средний, но кэшированный <br/> - Выполнение запроса базы данных: потенциально высокий (лучшие запросы в некоторых ситуациях) <br/> Подключение.Открытый <br/> - Command.ExecuteReader <br/> - DataReader.Read <br/> Материализация объекта: Средний (Быстрее, чем EF5) <br/> - Идентификационный поиск: Средний |
| `}`                                                                                                  | Соединение.Закрыть          | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                           | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |


**Выполнение второго запроса — теплый запрос**

| Записывает код пользователя                                                                                     | Действие                    | Влияние производительности EF4                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Влияние производительности EF5                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Влияние производительности EF6                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | Создание контекста          | Средний                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Средний                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | Создание выражения запроса | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var c1 = q1.First();`                                                                             | Выполнение запроса LIN's      | - Метаданные ~~загрузки~~ поиска: ~~Высокий, но кэшированный~~ Низкий <br/> - Просмотр ~~поколения~~ поиска: ~~Потенциально очень высокий, но кэшированный~~ Низкий <br/> - Оценка параметров: Средний <br/> - Поиск ~~перевода~~ запроса: Средний <br/> - Materializer ~~поколения~~ поиска: ~~Средний, но кэшированный~~ Низкий <br/> - Выполнение запроса базы данных: потенциально высокий <br/> Подключение.Открытый <br/> - Command.ExecuteReader <br/> - DataReader.Read <br/> Материализация объекта: Средний <br/> - Идентификационный поиск: Средний | - Метаданные ~~загрузки~~ поиска: ~~Высокий, но кэшированный~~ Низкий <br/> - Просмотр ~~поколения~~ поиска: ~~Потенциально очень высокий, но кэшированный~~ Низкий <br/> - Оценка параметров: Низкая <br/> - Поиск ~~перевода~~ запроса: ~~Средний, но кэшированный~~ Низкий <br/> - Materializer ~~поколения~~ поиска: ~~Средний, но кэшированный~~ Низкий <br/> - Выполнение запроса базы данных: потенциально высокий (лучшие запросы в некоторых ситуациях) <br/> Подключение.Открытый <br/> - Command.ExecuteReader <br/> - DataReader.Read <br/> Материализация объекта: Средний <br/> - Идентификационный поиск: Средний | - Метаданные ~~загрузки~~ поиска: ~~Высокий, но кэшированный~~ Низкий <br/> - Просмотр ~~поколения~~ поиска: ~~Средний, но кэшированный~~ Низкий <br/> - Оценка параметров: Низкая <br/> - Поиск ~~перевода~~ запроса: ~~Средний, но кэшированный~~ Низкий <br/> - Materializer ~~поколения~~ поиска: ~~Средний, но кэшированный~~ Низкий <br/> - Выполнение запроса базы данных: потенциально высокий (лучшие запросы в некоторых ситуациях) <br/> Подключение.Открытый <br/> - Command.ExecuteReader <br/> - DataReader.Read <br/> Материализация объекта: Средний (Быстрее, чем EF5) <br/> - Идентификационный поиск: Средний |
| `}`                                                                                                  | Соединение.Закрыть          | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Низкий                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |


Существует несколько способов снижения эксплуатационных расходов как холодных, так и теплых запросов, и мы рассмотрим их в следующем разделе. В частности, мы рассмотрим снижение стоимости загрузки модели в холодных запросах с помощью предварительно созданных представлений, которые должны помочь облегчить работу с нагрузками, испытываемыми во время генерации представления. Для теплых запросов мы рассмотрим кэширование плана запросов, отсутствие запросов отслеживания и различные параметры выполнения запросов.

### <a name="21-what-is-view-generation"></a>2.1 Что такое поколение представления?

Для того, чтобы понять, что такое генерация представления, мы должны сначала понять, что такое "Картирование просмотров". Представления отображения являются исполняемыми представлениями преобразований, указанных в отображении для каждого набора и ассоциации сущности. Внутренне эти отображающие представления принимают форму КТ (канонических деревьев запросов). Существует два типа картографических представлений:

-   Представления запросов: они представляют собой преобразование, необходимое для перехода от схемы базы данных к концептуальной модели.
-   Обновления представлений: они представляют собой преобразование, необходимое для перехода от концептуальной модели к схеме базы данных.

Имейте в виду, что концептуальная модель может отличаться от схемы базы данных различными способами. Например, для хранения данных для двух типов различных сущностей может использоваться одна таблица. Наследование и нетривиальные отображения играют определенную роль в сложности представлений отображения.

Процесс вычисления этих представлений на основе спецификации отображения является то, что мы называем генерации представления. Генерация представления может происходить динамически при загрузке модели или во время сборки, используя "предварительно созданные представления"; последние сериализируются в виде инструкций Entity\# S'L к файлу C или VB.

При сгенерировании представлений они также проверяются. С точки зрения производительности, подавляющее большинство затрат генерации представления на самом деле является проверка представлений, которая гарантирует, что соединения между объектами имеют смысл и имеют правильную кардинальность для всех поддерживаемых операций.

При выполнении запроса над набором сущности запрос сочетается с соответствующим представлением запроса, и результат этой композиции выполняется через компилятор плана для создания представления запроса, который может понять резервный магазин. Для сервера S'L, конечным результатом этой компиляции будет заявление T-S'L SELECT. При первом выполнении обновления набора сущности представление обновления выполняется аналогичным процессом для преобразования его в DML-выписки для целевой базы данных.

### <a name="22-factors-that-affect-view-generation-performance"></a>2.2 Факторы, влияющие на производительность генерации представления

Производительность шага генерации представления зависит не только от размера модели, но и от того, насколько взаимосвязана модель. Если две Сущности связаны через цепочку наследования или Ассоциацию, они, как утверждается, связаны между собой. Аналогичным образом, если две таблицы соединены через иностранный ключ, они соединены. По мере увеличения числа подключенных сущностей и таблиц в схемах увеличивается стоимость генерации представления.

Алгоритм, который мы используем для генерации и проверки представлений, является экспоненциальным в худшем случае, хотя мы используем некоторые оптимизации для улучшения этого. Самые большие факторы, которые, как представляется, негативно влияют на производительность являются:

-   Размер модели, относящийся к количеству сущностей и количеству ассоциаций между этими сущностями.
-   Сложность модели, в частности наследования с большим количеством типов.
-   Использование независимых ассоциаций, а не иностранных ключевых ассоциаций.

Для небольших, простых моделей стоимость может быть достаточно небольшой, чтобы не беспокоить с помощью предварительно сгенерированных представлений. По мере увеличения размера и сложности модели существует несколько вариантов снижения стоимости генерации и проверки представления.

### <a name="23-using-pre-generated-views-to-decrease-model-load-time"></a>2.3 Использование предгенерированных представлений для уменьшения времени загрузки модели

Для получения подробной информации о том, как использовать предварительно созданные представления на рамках Entity Framework 6, посетите [предварительно созданные представления о сопоставлении](~/ef6/fundamentals/performance/pre-generated-views.md)

#### <a name="231-pre-generated-views-using-the-entity-framework-power-tools-community-edition"></a>2.3.1 Предварительно созданные представления с помощью сообщества Entity Framework Power Tools Edition

Вы можете использовать [Entity Framework 6 Power Tools Community Edition](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) для генерации представлений моделей EDMX и Code First, нажав правой кнопкой мыши на файл класса модели и используя меню Entity Framework для выбора "Generate Views". Сообщество Power Tools Community Edition работает только на контекстах, полученных из DbContext.

#### <a name="232-how-to-use-pre-generated-views-with-a-model-created-by-edmgen"></a>2.3.2 Как использовать предгенерированные представления с моделью, созданной EDMGen

EDMGen — это утилита, которая поставляется с .NET и работает с Entity Framework 4 и 5, но не с Entity Framework 6. EDMGen позволяет создавать файл модели, слой объекта и представления из командной строки. Одним из выходов будет файл просмотров на вашем языке\#выбора, VB или C . Это кодовый файл, содержащий фрагменты entity S'L для каждого набора сущностей. Для включения предварительно созданных представлений вы просто включаете файл в проект.

Если вы вручную внесете теки в файлы схемы для модели, необходимо повторно создать файл представлений. Вы можете сделать это, запустив EDMGen с **флагом /mode:ViewGeneration.**

#### <a name="233-how-to-use-pre-generated-views-with-an-edmx-file"></a>2.3.3 Как использовать предгенерированные представления с файлом EDMX

Вы также можете использовать EDMGen для создания представлений для файла EDMX - ранее ссылалась тема MSDN описывает, как добавить событие предварительной сборки, чтобы сделать это, - но это сложно, и Есть некоторые случаи, когда это невозможно. Как правило, проще использовать шаблон T4 для генерации представлений, когда модель находится в файле edmx.

В блоге ADO.NET команды есть пост, который описывает, как \< https://docs.microsoft.com/archive/blogs/adonet/how-to-use-a-t4-template-for-view-generation>)использовать шаблон T4 для представления поколения ( . Эта публикация включает в себя шаблон, который можно загрузить и добавить в ваш проект. Шаблон был написан для первой версии Системы сущности, поэтому они не гарантированно работают с последними версиями Рамочной системы сущности. Тем не менее, вы можете скачать более современный набор шаблонов генерации представлений для Entity Framework 4 и 5 из галереи Visual Studio:

-   VB.NET:\<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d>
-   C\#:\<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d>

Если вы используете Entity Framework 6, вы можете получить шаблоны поколения \< http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f>представления T4 из галереи Visual Studio Gallery в .

### <a name="24-reducing-the-cost-of-view-generation"></a>2.4 Снижение стоимости генерации представлений

Использование предварительно сгенерированных представлений перемещает стоимость генерации представления от загрузки модели (время выполнения) к времени проектирования. Хотя это улучшает производительность запуска во время выполнения, вы все равно будете испытывать боль поколения представлений, пока вы развиваетесь. Есть несколько дополнительных приемов, которые могут помочь снизить стоимость генерации представления, как во время компиляции, так и во время выполнения.

#### <a name="241-using-foreign-key-associations-to-reduce-view-generation-cost"></a>2.4.1 Использование ассоциаций иностранных ключей для снижения стоимости генерации представления

Мы видели ряд случаев, когда переключение ассоциаций в модели с независимых ассоциаций на иностранные ключевые ассоциации резко улучшили время, проведенное в виде поколения.

Чтобы продемонстрировать это улучшение, мы создали две версии модели Navision с помощью EDMGen. *Примечание: см. приложение C для описания модели Navision.* Модель Navision интересна для этого упражнения из-за его очень большого количества сущностей и отношений между ними.

Одна версия этой очень большой модели была создана с иностранными ассоциациями ключей, а другая была создана с независимыми ассоциациями. Затем мы приурочили, сколько времени потребовалось для создания представлений для каждой модели. Для генерации представлений в тесте Entity Framework 5 Была использована метод GenerateViews() из класса EntityViewGenerator, в то время как тест Entity Framework 6 использовал метод GenerateViews() из класса StorageMappingItemCollection. Это связано с реструктуризацией кода, которая произошла в кодовой базе Entity Framework 6.

Использование Entity Framework 5, генерация представления для модели с иностранными ключами заняла 65 минут в лабораторной машине. Неизвестно, сколько времени потребовалось бы для создания представлений для модели, которая использовала независимые ассоциации. Мы оставили тест работает в течение месяца, прежде чем машина была перезагружена в нашей лаборатории для установки ежемесячных обновлений.

Использование Entity Framework 6, генерация представления для модели с иностранными ключами заняла 28 секунд в той же лабораторной машине. Представление поколения для модели, используюейй независимые ассоциации, заняло 58 секунд. Улучшения, внесенные в систему Entity Framework 6 в коде генерации представлений, означают, что многим проектам не потребуется предварительно созданных представлений для получения более быстрого времени запуска.

Важно отметить, что предварительно генерирующие представления в рамках Entity Framework 4 и 5 могут быть выполнены с помощью EDMGen или Системных Power Tools Entity. Для Entity Framework 6 представление поколения может быть сделано через Entity Framework Power Tools или программно, как описано в [предварительно созданных картографических представлений](~/ef6/fundamentals/performance/pre-generated-views.md).

##### <a name="2411-how-to-use-foreign-keys-instead-of-independent-associations"></a>2.4.1.1 Как использовать иностранные ключи вместо независимых ассоциаций

При использовании EDMGen или Entity Designer в Visual Studio, вы получаете FKs по умолчанию, и это займет всего один флажок или флаг командной строки для переключения между FKs и IAs.

Если у вас есть большая модель Code First, использование независимых ассоциаций будет иметь такое же влияние на генерацию представления. Это влияние можно избежать, включив свойства Foreign Key в классы зависимых объектов, хотя некоторые разработчики будут считать, что это загрязняет модель их объектов. Вы можете найти более подробную информацию по этому вопросу в \< http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/>.

| В языке      | выполните следующее:                                                                                                                                                                                                                                                                                                                              |
|:----------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Entity Designer | После добавления связи между двумя сущностями убедитесь, что у вас есть референциальные ограничения. Референтные ограничения говорят об использовании Иностранных ключей вместо независимых ассоциаций. Для получения дополнительной \< https://docs.microsoft.com/archive/blogs/efdesign/foreign-keys-in-the-entity-framework>информации посетите . |
| EDMGen          | При использовании EDMGen для генерации файлов из базы данных ваши иностранные ключи будут соблюдаться и добавлены в модель как таковую. Для получения дополнительной информации о различных [http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx)вариантах, выставленных EDMGen визита .                           |
| Code First      | Подробнее о том, как включать иностранные ключевые свойства в зависимые объекты при использовании Code First, читайте в разделе "Конвенция о [взаимоотношениях"](~/ef6/modeling/code-first/conventions/built-in.md) В Первом кодексе.                                                                                              |

#### <a name="242-moving-your-model-to-a-separate-assembly"></a>2.4.2 Перемещение модели в отдельную сборку

Когда модель включена непосредственно в проект приложения и вы генерируете представления через событие предварительной сборки или шаблон T4, генерация представления и проверка будут происходить всякий раз, когда проект перестроен, даже если модель не была изменена. Если вы переместите модель в отдельную сборку и ссылаетесь на нее из проекта приложения, можно внести другие изменения в приложение без необходимости восстановления проекта, содержащего модель.

*Примечание:*  при перемещении модели в отдельные сборки не забудьте скопировать строки соединения для модели в файл конфигурации приложения проекта клиента.

#### <a name="243-disable-validation-of-an-edmx-based-model"></a>2.4.3 Отключить проверку модели на основе edmx

Модели EDMX проверяются во время компиляции, даже если модель не изменина. Если модель уже была проверена, можно пресечь проверку во время компиляции, установив свойство "Validate on Build" на ложное в окне свойств. При изменении отображения или модели можно временно повторно включить проверку для проверки изменений.

Обратите внимание, что в рамках entity Framework Designer для Entity Framework 6 были улучшены, а стоимость "Validate on Build" значительно ниже, чем в предыдущих версиях конструктора.

## <a name="3-caching-in-the-entity-framework"></a>3 Кэширование в рамочной системе entity

Система entity имеет следующие формы встроенного кэширования:

1.  Кэширование объектов — objectStateManager, встроенный в экземпляр ObjectContext, отслеживает память объектов, извлеченных с помощью этого экземпляра. Это также известно как кэш первого уровня.
2.  Кэширование плана запроса - повторное использование генерируемой команды хранилища при выполнении запроса более одного раза.
3.  Кэширование метаданных - совместное использование метаданных для модели по разным соединениям с одной и той же моделью.

Помимо кэшов, которые EF предоставляет из коробки, специальный вид поставщика ADO.NET данных, известный как поставщик упаковки, также может быть использован для расширения рамок Entity с помощью кэша для результатов, извлеченных из базы данных, также известного как кэширование второго уровня.

### <a name="31-object-caching"></a>3.1 Кэшинг объекта

По умолчанию, когда объект возвращается в результатах запроса, непосредственно перед его материализуемым EF, ObjectContext проверяет, была ли объект с тем же ключом уже загружен в свой ObjectStateManager. Если организация с теми же ключами уже присутствует, EF будет включать его в результаты запроса. Хотя EF по-прежнему будет выдавать запрос против базы данных, такое поведение может обойти большую часть затрат на материализацию сущности несколько раз.

#### <a name="311-getting-entities-from-the-object-cache-using-dbcontext-find"></a>3.1.1 Получение сущностей из кэша объектов с помощью DbContext Find

В отличие от обычного запроса, метод Поиска в DbSet (AIS, включенный в первые разы в EF 4.1) будет выполнять поиск в памяти еще до выдачи запроса против базы данных. Важно отметить, что два разных экземпляра ObjectContext будут иметь два разных экземпляра ObjectStateManager, что означает, что они имеют отдельные кэши объектов.

Find использует основное значение ключа, чтобы попытаться найти сущность, отслеживаемую контекстом. Если сущность не находится в контексте, то запрос будет выполнен и оценен в базе данных, и нулевые возвращается, если объект не найден в контексте или в базе данных. Обратите внимание, что Find также возвращает объекты, которые были добавлены в контекст, но еще не сохранены в базе данных.

При использовании Find необходимо учитывать производительность. Вызовы к этому методу по умолчанию вызовут проверку кэша объекта для обнаружения изменений, которые еще не завершены в базе данных. Этот процесс может быть очень дорогим, если в кэше объекта есть очень большое количество объектов или в большой график объекта, добавляемый в кэш объекта, но он также может быть отключен. В некоторых случаях вы можете воспринимать на порядок величину разницы в вызове метода Поиска, когда вы откажете сьюет изменения автоматического обнаружения. Однако второй порядок величины воспринимается, когда объект фактически находится в кэше по сравнению с тем, когда объект должен быть извлечен из базы данных. Вот пример графика с измерениями, сделанными с использованием некоторых из наших микробенчмарков, выраженных в миллисекундах, с нагрузкой 5000 сущностей:

![.NET 4.5 логарифмическая шкала](~/ef6/media/net45logscale.png ".NET 4.5 - логарифмическая шкала")

Пример поиска с автоматическим обнаружением изменений отключен:

``` csharp
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    context.Configuration.AutoDetectChangesEnabled = true;
    ...
```

При использовании метода «Найти» необходимо учитывать:

1.  Если объект не находится в кэше, преимущества Поиска сведены на нет, но синтаксис все еще проще, чем запрос ключа.
2.  Если автоматические изменения обнаруживаются, стоимость метода Поиска может увеличиться на один порядок величины или даже больше в зависимости от сложности модели и количества сущностей в кэше объектов.

Кроме того, имейте в виду, что Find возвращает только объект, который вы ищете, и он не загружает автоматически связанные сущности, если они еще не находятся в кэше объекта. Если вам нужно получить связанные сущности, можно использовать запрос по ключу с нетерпеливой загрузкой. Для получения дополнительной **информации см. 8.1 Ленивая загрузка против стремятся загрузки**.

#### <a name="312-performance-issues-when-the-object-cache-has-many-entities"></a>3.1.2 Проблемы производительности при кэше объекта имеет много сущностей

Кэш объектов помогает повысить общую реакцию системы Entity. Однако, когда кэш объекта имеет очень большое количество объектов загружены это может повлиять на определенные операции, такие как добавить, удалить, найти, запись, СохранитьИзменения и многое другое. В частности, операции, вызывающие вызов detectChanges, будут негативно затронуты очень большими кэшами объектов. DetectChanges синхронизирует график объекта с диспетчером состояния объекта, и его производительность будет определяться непосредственно размером графика объекта. Для получения дополнительной информации [Tracking Changes in POCO Entities](https://msdn.microsoft.com/library/dd456848.aspx)о DetectChanges см.

При использовании Entity Framework 6 разработчики могут вызывать AddRange и RemoveRange непосредственно на DbSet, вместо того, чтобы итерировать коллекцию и вызывать Add один раз в экземпляр. Преимущество использования методов диапазона заключается в том, что стоимость DetectChanges оплачивается только один раз за весь набор сущностей, а не один раз на каждую добавленную сущность.

### <a name="32-query-plan-caching"></a>3.2 Кэшинг плана запроса

При первом выполнении запроса он проходит через внутренний компилятор плана для перевода концептуального запроса в команду хранилища (например, T-S'L, который выполняется при запуске на против сервера S'L).Если кэширование плана запроса включено, следующий момент выполнения запроса команда хранилища будет извлечена непосредственно из кэша плана запроса для выполнения, минуя компилятор плана.

Кэш плана запросов используется в экземплярах ObjectContext в том же AppDomain. Вам не нужно держаться за экземпляр ObjectContext, чтобы воспользоваться кэшированием плана запроса.

#### <a name="321-some-notes-about-query-plan-caching"></a>3.2.1 Некоторые заметки о кэшинге плана запросов

-   Кэш плана запросов используется для всех типов запросов: Entity S'L, LIN- для организаций и объектов компилированного квиера.
-   По умолчанию кэширование плана запросов включено для запросов Entity S'L, независимо от того, выполняется ли это через EntityCommand или через Object's.. Кроме того, по умолчанию для запросов линз для сущностей в рамках сущностей на .NET 4.5 и в рамках сущности 6
    -   Кэширование плана запроса может быть отключено, установив свойство EnablePlanCaching (на EntityCommand или Object'ery) на ложное. Пример:
``` csharp
                    var query = from customer in context.Customer
                                where customer.CustomerId == id
                                select new
                                {
                                    customer.CustomerId,
                                    customer.Name
                                };
                    ObjectQuery oQuery = query as ObjectQuery;
                    oQuery.EnablePlanCaching = false;
```
-   Для параметризированных запросов изменение значения параметра по-прежнему будет попадание в кэшированный запрос. Но изменение граней параметра (например, размер, точность или масштаб) ударит по другой записи в кэше.
-   При использовании entity S'L строка запроса является частью ключа. Изменение запроса вообще приведет к различным записям кэша, даже если запросы функционально эквивалентны. Это включает в себя изменения в корпусе или белом пространстве.
-   При использовании LIN'а запрос обрабатывается для создания части ключа. Таким образом, изменение выражения LIN'а создаст другой ключ.
-   Могут применяться и другие технические ограничения; для получения более подробной информации см.

#### <a name="322-cache-eviction-algorithm"></a>3.2.2 Алгоритм выселения кэша

Понимание того, как работает внутренний алгоритм, поможет вам выяснить, когда включить или отключить кэширование плана запроса. Алгоритм очистки заключается в следующем:

1.  Как только кэш содержит определенное количество записей (800), мы запускаем таймер, который периодически (раз в минуту) подметает кэш.
2.  Во время зачисток кэша записи удаляются из кэша на основе LFRU (наименее часто используемые в последнее время). Этот алгоритм учитывает как количество хитов, так и возраст при принятии решения о том, какие записи выбрасываются.
3.  В конце каждого развертки кэша кэш снова содержит 800 записей.

Все записи кэша обрабатываются одинаково при определении того, какие записи выселить. Это означает, что команда хранилища для компилированного кверкери имеет те же шансы на выселение, что и команда хранилища для запроса Entity S'L.

Обратите внимание, что таймер выселения кэша выснется, когда в кэше находится 800 сущностей, но кэш заметен только через 60 секунд после запуска этого таймера. Это означает, что в течение 60 секунд ваш кэш может вырасти до довольно большого.

#### <a name="323-test-metrics-demonstrating-query-plan-caching-performance"></a>3.2.3 Метрики тестирования, демонстрирующие производительность кэширования плана запросов

Чтобы продемонстрировать влияние кэширования запроса на производительность приложения, мы выполнили тест, в ходе которого выполнили ряд запросов Entity S'L против модели Navision. Ознакомьтесь с приложением для описания модели Navision и типов запросов, которые были выполнены. В этом тесте мы сначала итерируем список запросов и выполняем каждый раз, чтобы добавить их в кэш (если кэширование включено). Этот шаг не имеет времени. Далее, мы спим основной поток в течение более 60 секунд, чтобы кэш радикальных состоится; наконец, мы итерировать через список второй раз для выполнения кэшированных запросов. Кроме того, кэш плана плана S'L Server смывается перед выполнением каждого набора запросов, чтобы время, которое мы получаем, точно отражало выгоду, полученную кэшем плана запросов.

##### <a name="3231-test-results"></a>3.2.3.1 Результаты испытаний

| Тест                                                                   | EF5 нет кэша | Кэшированный EF5 | EF6 нет кэша | Кэшированный EF6 |
|:-----------------------------------------------------------------------|:-------------|:-----------|:-------------|:-----------|
| Перечисление всех запросов 18723                                          | 124          | 125.4      | 124.3        | 125.3      |
| Как избежать развертки (только первые 800 запросов, независимо от сложности)  | 41.7         | 5.5        | 40,5         | 5.4        |
| Просто aggregatingSubtotals запросы (178 всего - что позволяет избежать развертки) | 39.5         | 4.5.        | 38.1         | 4.6        |

*Все время в секундах.*

Мораль - при выполнения большого количества различных запросов (например, динамически созданных запросов), кэширование не помогает, и в результате промывка кэша может держать запросы, которые выиграют больше всего от кэширования плана от фактического его использования.

Запросы AggregatingSubtotals являются наиболее сложными из запросов, с которых мы тестировали. Как и ожидалось, чем сложнее запрос, тем больше преимуществ вы увидите при кэше плана запроса.

Поскольку компилированный кекери на самом деле является запросом LIN's с кэшированным планом, сравнение компиляционного запроса по сравнению с эквивалентным запросом Entity S'L должно иметь аналогичные результаты. В самом деле, если приложение имеет много динамических запросов Entity S'L, заполнение кэша с запросами также будет эффективно причиной Compiled'запросы "декомпилировать", когда они смыты из кэша. В этом сценарии производительность может быть улучшена путем отключения кэширования динамических запросов для определения приоритетов компиляжных запросов. А еще лучше, конечно, было бы переписать приложение, чтобы использовать параметризированные запросы вместо динамических запросов.

### <a name="33-using-compiledquery-to-improve-performance-with-linq-queries"></a>3.3 Использование компилированных кюкери для повышения производительности с помощью запросов LIN

Наши тесты показывают, что использование компилированного квиера может принести пользу в размере 7% по сравнению с автокомпилированными запросами LIN; это означает, что вы потратите на 7% меньше времени на выполнение кода из стека инфраструктуры сущности; это не означает, что ваше приложение будет на 7% быстрее. Вообще говоря, стоимость написания и обслуживания объектов компиляторы в EF 5.0 не может быть стоит проблемы по сравнению с преимуществами. Ваш пробег может варьироваться, поэтому воспроизвите эту опцию, если ваш проект требует дополнительного толчка. Обратите внимание, что компилированные запросы совместимы только с моделями, полученными из ObjectContext, и не совместимы с моделями, полученными из DbContext.

Для получения дополнительной информации о создании и вызывании компилированного квикери см. [Compiled Queries (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx)

При использовании компилированного кикери необходимо учитывать два соображения, а именно требование использовать статические экземпляры и проблемы, которые они имеют при композициях. Ниже приводится подробное объяснение этих двух соображений.

#### <a name="331-use-static-compiledquery-instances"></a>3.3.1 Использование статических экземпляров компиляций

Поскольку компиляция запроса LIN's занимает много времени, мы не хотим делать это каждый раз, когда нам нужно получать данные из базы данных. Компилированные экземпляры позволяют компилировать один раз и запускать несколько раз, но вы должны быть осторожны и закупать повторно использовать тот же экземпляр Компилекинга каждый раз, вместо того, чтобы компиляции его снова и снова. Использование статических членов для хранения экземпляров Компилеци-Куира становится необходимым; в противном случае вы не увидите никакой пользы.

Например, предположим, что ваша страница имеет следующий корпус метода для обработки отображения продуктов для выбранной категории:

``` csharp
    // Warning: this is the wrong way of using CompiledQuery
    using (NorthwindEntities context = new NorthwindEntities())
    {
        string selectedCategory = this.categoriesList.SelectedValue;

        var productsForCategory = CompiledQuery.Compile<NorthwindEntities, string, IQueryable<Product>>(
            (NorthwindEntities nwnd, string category) =>
                nwnd.Products.Where(p => p.Category.CategoryName == category)
        );

        this.productsGrid.DataSource = productsForCategory.Invoke(context, selectedCategory).ToList();
        this.productsGrid.DataBind();
    }

    this.productsGrid.Visible = true;
```

В этом случае вы будете создавать новый экземпляр Компиледовна на лету каждый раз, когда метод вызывается. Вместо того, чтобы видеть преимущества производительности, извлекая команду хранилища из кэша плана запроса, компилятор компиляции плана будет проходить через компилятор плана каждый раз, когда создается новый экземпляр. На самом деле, каждый раз, когда метод вызывается, вы будете загрязнять кэш плана запросов новой записью Компиляции.

Вместо этого необходимо создать статический экземпляр компилированного запроса, поэтому вы вызываете один и тот же компилированный запрос каждый раз, когда вызывается метод. Одним из способов этого является добавление экземпляра компилированного кекери в качестве члена контекста объекта.Затем вы можете сделать вещи немного чище, обратившись к компилятору с помощью вспомогательного метода:

``` csharp
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IEnumerable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
            );

        public IEnumerable<Product> GetProductsForCategory(string categoryName)
        {
            return productsForCategoryCQ.Invoke(this, categoryName).ToList();
        }
```

Этот метод помощника будет использоваться следующим образом:

``` csharp
    this.productsGrid.DataSource = context.GetProductsForCategory(selectedCategory);
```

#### <a name="332-composing-over-a-compiledquery"></a>3.3.2 Составление по компилированному кемери

Возможность сочинять по любой запросу LIN'а чрезвычайно полезна; для этого вы просто вызываете метод после i'E'E'Eiryable, таких как *Skip()* или *Count()*. Тем не менее, это по существу возвращает новый объект i'squeryable. Несмотря на то, что технически не остановить вас от составления компиляций, это приведет к генерации нового объекта, который требует повторного прохождения через компилятор плана.

Некоторые компоненты будут использовать составные объекты, которые можно использовать для обеспечения расширенной функциональности. Например, ASP. GridView NET может быть привязан к объекту, который можно сделать через свойство SelectMethod. Затем GridView будет составлять над этим объектом, который можно сделать, чтобы сортировать и прокладывать по модели данных. Как вы можете видеть, использование компилированного query для GridView не попадет в компилированный запрос, а создаст новый автоматически скомпилированный запрос.

Одно из мест, где вы можете столкнуться с этим при добавлении прогрессивных фильтров в запрос. Например, предположим, что у вас есть страница Клиентов с несколькими списками выпадающих для дополнительных фильтров (например, Country and OrdersCount). Эти фильтры можно составить по сравнению с результатами компилируемых кекеров, но это приведет к тому, что новый запрос будет проходить через компилятор плана каждый раз, когда вы его выполняете.

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployee();

        if (this.orderCountFilterList.SelectedItem.Value != defaultFilterText)
        {
            int orderCount = int.Parse(orderCountFilterList.SelectedValue);
            myCustomers = myCustomers.Where(c => c.Orders.Count > orderCount);
        }

        if (this.countryFilterList.SelectedItem.Value != defaultFilterText)
        {
            myCustomers = myCustomers.Where(c => c.Address.Country == countryFilterList.SelectedValue);
        }

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 Чтобы избежать этой перекомпимации, можно переписать компиляционный кюкери, чтобы учесть возможные фильтры:

``` csharp
    private static readonly Func<NorthwindEntities, int, int?, string, IQueryable<Customer>> customersForEmployeeWithFiltersCQ = CompiledQuery.Compile(
        (NorthwindEntities context, int empId, int? countFilter, string countryFilter) =>
            context.Customers.Where(c => c.Orders.Any(o => o.EmployeeID == empId))
            .Where(c => countFilter.HasValue == false || c.Orders.Count > countFilter)
            .Where(c => countryFilter == null || c.Address.Country == countryFilter)
        );
```

Что будет ссылаться в uI, как:

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        int? countFilter = (this.orderCountFilterList.SelectedIndex == 0) ?
            (int?)null :
            int.Parse(this.orderCountFilterList.SelectedValue);

        string countryFilter = (this.countryFilterList.SelectedIndex == 0) ?
            null :
            this.countryFilterList.SelectedValue;

        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployeeWithFilters(
                countFilter, countryFilter);

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 Компромиссом здесь является сгенерированная команда магазина всегда будет иметь фильтры с нулевыми проверками, но они должны быть довольно простыми для сервера базы данных для оптимизации:

``` SQL
...
WHERE ((0 = (CASE WHEN (@p__linq__1 IS NOT NULL) THEN cast(1 as bit) WHEN (@p__linq__1 IS NULL) THEN cast(0 as bit) END)) OR ([Project3].[C2] > @p__linq__2)) AND (@p__linq__3 IS NULL OR [Project3].[Country] = @p__linq__4)
```

### <a name="34-metadata-caching"></a>3.4 Кэширование метаданных

Рамочная система сущности также поддерживает кэширование метаданных. По сути, это кэширование информации типа и отображение информации от типа к базе данных в разных соединениях с одной и той же моделью. Кэш Metadata уникален для AppDomain.

#### <a name="341-metadata-caching-algorithm"></a>3.4.1 Алгоритм кэширования метаданных

1.  Информация о метаданных для модели хранится в ItemCollection для каждого EntityConnection.
    -   В качестве примечания следует, что существуют различные объекты ItemCollection для различных частей модели. Например, StoreItemCollections содержит информацию о модели базы данных; ObjectItemCollection содержит информацию о модели данных; EdmItemCollection содержит информацию о концептуальной модели.

2.  Если два соединения используют одну и ту же строку соединения, они будут совместно использовать один и тот же экземпляр ItemCollection.
3.  Функционально эквивалентно, но текстуически разные строки соединения могут привести к различным кэшам метаданных. Мы делаем токенизировать строки соединения, поэтому простое изменение порядка токенов должно привести к общим метаданным. Но две строки соединения, которые кажутся функционально одинаковыми, не могут быть оценены как идентичные после токенизации.
4.  Элементколлекции периодически проверяется на использование. Если установлено, что рабочее пространство не было доступно в последнее время, оно будет помечено для очистки при следующем размахе кэша.
5.  Простое создание EntityConnection приведет к созданию кэша метаданных (хотя коллекции элементов в нем не будут инициализированы до открытия соединения). Это рабочее пространство будет оставаться в памяти до тех пор, пока алгоритм кэширования не определит, что оно не используется.

Консультационная группа по работе с клиентами написала сообщение в блоге, в которой описывается проведение \< https://docs.microsoft.com/archive/blogs/appfabriccat/holding-a-reference-to-the-ef-metadataworkspace-for-wcf-services>ссылки на ItemCollection, чтобы избежать "амортизацию" при использовании больших моделей: .

#### <a name="342-the-relationship-between-metadata-caching-and-query-plan-caching"></a>3.4.2 Взаимосвязь между кэшированием метаданных и кэшингом плана запросов

Экземпляр кэша плана запроса живет в элементозачах типов магазинов MetadataWorkspace. Это означает, что кэшированные команды хранилища будут использоваться для запросов в любом контексте, мгновенно мгновенном использовании данного пространства MetadataWork. Это также означает, что если у вас есть две строки соединений, которые немного отличаются и не совпадают после токенизации, у вас будут разные экземпляры кэша плана запросов.

### <a name="35-results-caching"></a>3.5 Кэширование результатов

При кэше результатов (также известном как «кэширование второго уровня») вы сохраняете результаты запросов в локальном кэше. При выдаче запроса сначала вывидите, доступны ли результаты локально, прежде чем вы будете отвечать за магазин. Хотя кэширование результатов напрямую не поддерживается рамочной системой entity, можно добавить кэш второго уровня с помощью поставщика упаковки. Примером поставщика упаковки с кэшем второго уровня является Кэш второго уровня Alachisoft [Entity Framework Second Level, основанный на NCache.](https://www.alachisoft.com/ncache/entity-framework.html)

Эта реализация кэширования второго уровня является инъекционной функциональностью, которая происходит после оценки (и funcletized выражения) и вычисляется или извлекается план выполнения запроса из кэша первого уровня. Кэш второго уровня будет хранить только необработанные результаты базы данных, поэтому конвейер материализации по-прежнему выполняется после этого.

#### <a name="351-additional-references-for-results-caching-with-the-wrapping-provider"></a>3.5.1 Дополнительные ссылки на кэширование результатов с поставщиком упаковки

-   Джули Лерман написала статью MSDN «Второй уровень кэширования в рамках сущности и Windows Azure», которая включает в себя, как обновить поставщик оберток образца для использования кэширования Windows Server AppFabric:[https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)
-   Если вы работаете с Entity Framework 5, в блоге команды есть публикация, в которой \< https://docs.microsoft.com/archive/blogs/adonet/ef-caching-with-jarek-kowalskis-provider>описывается, как запустить работу с поставщиком кэширования для Entity Framework 5: . Он также включает в себя шаблон T4, чтобы помочь автоматизировать добавление кэширования 2-го уровня в ваш проект.

## <a name="4-autocompiled-queries"></a>4 Автокомпилированные запросы

Когда запрос выдается в отношении базы данных с использованием рамочной базы, он должен пройти через ряд шагов, прежде чем фактически материализовать результаты; одним из таких шагов является компиляция запросов. Было известно, что запросы сущности S'L имеют хорошую производительность, так как они автоматически кэшируются, поэтому во втором или третьем разе выполнения того же запроса он может пропустить компилятор плана и использовать вместо этого кэшированный план.

Система Сущности 5 ввела автоматическое кэширование для запросов линз для организаций. В прошлых выпусках Рамочной системы сущности создание компиляций для ускорения производительности было обычной практикой, так как это сделает ваш кэшируемый запрос на количество запросов для СУЩНОСТи. Поскольку кэширование теперь выполняется автоматически без использования компилированного кикери, мы называем эту функцию "автокомпилированными запросами". Для получения дополнительной информации о кэше плана запроса и его механике см.

Система сущности обнаруживает, когда запрос требует перекомпилироваться, и делает это, когда запрос вызывается, даже если он был компилирован ранее. Общие условия, которые вызывают перекомпилировать запрос:

-   Изменение MergeOption, связанного с вашим запросом. Кэшированный запрос не будет использоваться, вместо этого компилятор плана будет работать снова и вновь созданный план кэшируется.
-   Изменение значения ContextOptions.UseSharpNullComparisonBehavior. Вы получаете тот же эффект, что и изменение MergeOption.

Другие условия могут помешать запросу использовать кэш. Ниже приведены распространенные примеры.

-   Использование&lt;IEnumerable&gt;T . Содержит&lt;&gt;(значение T).
-   Использование функций, которые производят запросы с константами.
-   Использование свойств неотображаемого объекта.
-   Связывание запроса с другим запросом, требующим повторной компиляции.

### <a name="41-using-ienumerablelttgtcontainslttgtt-value"></a>4.1 Использование IEnumerable&lt;T&gt;. Содержит&lt;&gt;T (значение T)

Система сущности не кэширует запросы, которые&lt;вызывают&gt;IEnumerable T. Содержит&lt;&gt;T (значение T) в отношении коллекции в памяти, так как значения коллекции считаются неустойчивыми. Следующий пример запрос не будет кэшироваться, поэтому он всегда будет обрабатываться компилятором плана:

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var query = context.MyEntities
                    .Where(entity => ids.Contains(entity.Id));

    var results = query.ToList();
    ...
}
```

Обратите внимание, что размер IEnumerable, в соответствии с которым выполняется содержится, определяет, насколько быстро или как медленно компилируется ваш запрос. Производительность может значительно пострадать при использовании больших коллекций, таких как тот, показанный в примере выше.

Система Entity Framework 6 содержит оптимизацию способа IEnumerable&lt;T.&gt; Содержит&lt;&gt;T (значение T) работает при выполнении запросов. Сгенерированный код S'L гораздо быстрее в производстве и более читаемый, и в большинстве случаев он также выполняется быстрее на сервере.

### <a name="42-using-functions-that-produce-queries-with-constants"></a>4.2 Использование функций, которые производят запросы с константами

Операторы Скипа(), Take(), Содержит () и DefautIfEmpty() операторы LIN's не производят запросы с параметрами, а вместо этого помещают передаваемые им значения в качестве констант. Из-за этого запросы, которые в противном случае могли бы быть идентичными, в конечном итоге загрязняют кэш плана запросов, как в стеке EF, так и на сервере базы данных, и не используются повторно, если одни и те же константы не используются в последующем выполнении запроса. Пример:

``` csharp
var id = 10;
...
using (var context = new MyContext())
{
    var query = context.MyEntities.Select(entity => entity.Id).Contains(id);

    var results = query.ToList();
    ...
}
```

В этом примере каждый раз, когда этот запрос выполняется с другим значением для идентификатора, запрос будет компилирован в новый план.

В частности, обратите внимание на использование Skip и принять при выполнении paging. В EF6 эти методы имеют перегрузку lambda, которая фактически делает план кэшированного запроса многоразовым, потому что EF может фиксировать переменные, передаваемые этим методам, и переводить их в S'Lparameters. Это также помогает сохранить кэш чище, так как в противном случае каждый запрос с другой константой для Skip и Take получит свою собственную запись кэша плана запросов.

Рассмотрим следующий код, который является неоптимальным, но предназначен только для примера этого класса запросов:

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

Более быстрая версия этого же кода будет включать вызов Skip с лямбдой:

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(() => i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

Второй фрагмент может работать до 11% быстрее, потому что один и тот же план запроса используется каждый раз, когда запрос запущен, что экономит время процессора и позволяет избежать загрязнения кэша запроса. Кроме того, поскольку параметр Skip находится в замыкании, код может также выглядеть следующим образом:

``` csharp
var i = 0;
var skippyCustomers = context.Customers.OrderBy(c => c.LastName).Skip(() => i);
for (; i < count; ++i)
{
    var currentCustomer = skippyCustomers.FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

### <a name="43-using-the-properties-of-a-non-mapped-object"></a>4.3 Использование свойств неотображаемого объекта

Когда запрос использует свойства неотображаемого типа объекта в качестве параметра, то запрос не будет кэширован. Пример:

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();

    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myObject.MyProperty)
                select entity;

   var results = query.ToList();
    ...
}
```

В этом примере предположим, что класс NonMappedType не является частью модели Entity. Этот запрос можно легко изменить, чтобы не использовать некартный тип и вместо этого использовать локальную переменную в качестве параметра для запроса:

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();
    var myValue = myObject.MyProperty;
    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myValue)
                select entity;

    var results = query.ToList();
    ...
}
```

В этом случае запрос сможет получить кэшии и получит выгоду от кэша плана запроса.

### <a name="44-linking-to-queries-that-require-recompiling"></a>4.4 Ссылка на запросы, требующие перекомпиляции

Следуя тому же примеру, что и выше, если у вас есть второй запрос, который опирается на запрос, который необходимо перекомпилировать, весь второй запрос также будет перекомпилирован. Вот пример, иллюстрирующий этот сценарий:

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var firstQuery = from entity in context.MyEntities
                        where ids.Contains(entity.Id)
                        select entity;

    var secondQuery = from entity in context.MyEntities
                        where firstQuery.Any(otherEntity => otherEntity.Id == entity.Id)
                        select entity;

    var results = secondQuery.ToList();
    ...
}
```

Пример общий, но он иллюстрирует, как ссылка на первыйкекери вызывает второй кекери, чтобы быть не в состоянии получить кэшированный. Если бы во-первых, не был запрос, требующий перекомпинера, то второй кекери был бы кэширован.

## <a name="5-notracking-queries"></a>5 Запросы без отслеживания

### <a name="51-disabling-change-tracking-to-reduce-state-management-overhead"></a>5.1 Отключение отслеживания изменений для сокращения накладных расходов на управление государством

Если вы находитесь в сценарии только для чтения и хотите избежать накладных расходов на загрузку объектов в ObjectStateManager, вы можете выдать запросы "Нет отслеживания".Отслеживание изменений может быть отключено на уровне запроса.

Обратите внимание, однако, что, отключив отслеживание изменений, вы эффективно выключаете кэш объекта. При запросе сущности мы не можем пропустить материализацию, потянув результаты ранее материализованного запроса от ObjectStateManager. Если вы неоднократно задавляете запросы для одних и тех же сущностей в одном контексте, можно увидеть выгоду от включения отслеживания изменений в пользу производительности.

При запросе с помощью экземпляров ObjectContext, Object'ryи и ObjectSet будут запоминать MergeOption после его установки, а запросы, которые состоятся на них, унаследуют эффективный MergeOption родительского запроса. При использовании DbContext отслеживание может быть отключено, позвонив в модификатор AsNoTracking () на DbSet.

#### <a name="511-disabling-change-tracking-for-a-query-when-using-dbcontext"></a>5.1.1 Отключение отслеживания изменений для запроса при использовании DbContext

Режим запроса можно переключить на NoTracking, приковав вызов к методу AsNoTracking() в запросе. В отличие от Object''s, классы DbSet и Db''query в API DbContext не имеют изменяемого свойства для MergeOption.

``` csharp
    var productsForCategory = from p in context.Products.AsNoTracking()
                                where p.Category.CategoryName == selectedCategory
                                select p;


```

#### <a name="512-disabling-change-tracking-at-the-query-level-using-objectcontext"></a>5.1.2 Отключение отслеживания изменений на уровне запроса с помощью ObjectContext

``` csharp
    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;

    ((ObjectQuery)productsForCategory).MergeOption = MergeOption.NoTracking;
```

#### <a name="513-disabling-change-tracking-for-an-entire-entity-set-using-objectcontext"></a>5.1.3 Отключение отслеживания изменений для всего набора сущности с помощью ObjectContext

``` csharp
    context.Products.MergeOption = MergeOption.NoTracking;

    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;
```

### <a name="52test-metrics-demonstrating-the-performance-benefit-of-notracking-queries"></a>5.2 Метрики тестирования, демонстрирующие преимущества производительность запросов NoTracking

В этом тесте мы рассмотрим стоимость заполнения ObjectStateManager, сравнивая запросы Отслеживания с Запросами NoTracking для модели Navision. Ознакомьтесь с приложением для описания модели Navision и типов запросов, которые были выполнены. В этом тесте мы итерируем список запросов и выполняем каждый из них один раз. Мы запустили два варианта теста, один раз с запросами NoTracking и один раз с опцией слияния по умолчанию "AppendOnly". Мы побежали каждый вариант 3 раза и принять среднее значение работает. Между тестами мы очищаем кэш запроса на сервере S'L и сокращаем темп, запустив следующие команды:

1.  DBCC DROPCLEANBUFFERS
2.  DBCC FREEPROCCACHE
3.  DBCC SHRINKDATABASE (темп, 0)

Результаты тестирования, медиана в течение 3 трасс:

|                        | НЕТ ОТСЛЕЖИВАНИЯ - РАБОЧИЙ НАБОР | НЕТ ОТСЛЕЖИВАНИЯ - ВРЕМЯ | ТОЛЬКО ПРИДАТКА - РАБОЧИЙ НАБОР | ПРИЛОЖЕНИЕ ТОЛЬКО - ВРЕМЯ |
|:-----------------------|:--------------------------|:-------------------|:--------------------------|:-------------------|
| **Рамки сущности 5** | 460361728                 | 1163536 мс         | 596545536                 | 1273042 мс         |
| **Entity Framework 6** | 647127040                 | 190228 мс          | 832798720                 | 195521 мс          |

Система сущности 5 будет иметь меньший объем памяти в конце выполнения, чем Entity Framework 6. Дополнительная память, потребляемая Entity Framework 6, является результатом дополнительных структур памяти и кода, которые позволяют новым функциям и повышению производительности.

Кроме того, при использовании ObjectStateManager существует явная разница в памяти. Entity Framework 5 увеличила свой след на 30% при отслеживании всех сущностей, которые мы материализовали из базы данных. Система Entity 6 увеличила свой след на 28% при этом.

С точки зрения времени, Entity Framework 6 опережает Entity Framework 5 в этом тесте с большим отрывом. Система сущности 6 завершила тест примерно в 16% времени, заработавам в рамках Entity Framework 5. Кроме того, при использовании ObjectStateManager на 9% больше времени уходит на 9% больше времени. Для сравнения, Entity Framework 6 использует на 3% больше времени при использовании ObjectStateManager.

## <a name="6-query-execution-options"></a>6 Параметры выполнения запросов

Система сущности предлагает несколько различных способов запроса. Мы рассмотрим следующие варианты, сравним плюсы и минусы каждого из них и рассмотрим их характеристики производительности:

-   ЛИНЗ для организаций.
-   Нет отслеживания LIN' для организаций.
-   Сущность СЗЛ над объектом.
-   Сущность S'L над EntityCommand.
-   ExecuteStore's.
-   Кзл-Кусери.
-   СоставителиКери.

### <a name="61-linq-to-entities-queries"></a>6.1 Запросы на запросы для организаций

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

**Плюсы**

-   Подходит для операций CUD.
-   Полностью материализованные объекты.
-   Проще всего писать с помощью синтаксиса, встроенного в язык программирования.
-   Хорошая производительность.

**Минусы**

-   Некоторые технические ограничения, такие как:
    -   Шаблоны, использующие по умолчаниюДля-запросы OUTER JOIN, приводят к более сложным запросам, чем простые операторы OUTER JOIN в Entity S'L.
    -   Вы все еще не можете использовать LIKE с общим соответствием шаблона.

### <a name="62-no-tracking-linq-to-entities-queries"></a>6.2 Нет отслеживания запросов НАИНо-ЕЗ к объектам

Когда контекст выводит ObjectContext:

``` csharp
context.Products.MergeOption = MergeOption.NoTracking;
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

Когда контекст выводит DbContext:

``` csharp
var q = context.Products.AsNoTracking()
                        .Where(p => p.Category.CategoryName == "Beverages");
```

**Плюсы**

-   Улучшенная производительность по сравнению с обычными запросами НАИР.
-   Полностью материализованные объекты.
-   Проще всего писать с помощью синтаксиса, встроенного в язык программирования.

**Минусы**

-   Не подходит для операций CUD.
-   Некоторые технические ограничения, такие как:
    -   Шаблоны, использующие по умолчаниюДля-запросы OUTER JOIN, приводят к более сложным запросам, чем простые операторы OUTER JOIN в Entity S'L.
    -   Вы все еще не можете использовать LIKE с общим соответствием шаблона.

Обратите внимание, что запросы, которые проектные свойства масштабирования не отслеживаются, даже если Нотрекинг не указан. Пример:

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages").Select(p => new { p.ProductName });
```

Данный запрос явно не указывается как NoTracking, но так как он не материализуется в типе, который известен диспетчеру состояния объекта, то материализованный результат не отслеживается.

### <a name="63-entity-sql-over-an-objectquery"></a>6.3 Сущность СЗЛ над объектом«Закери

``` csharp
ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
```

**Плюсы**

-   Подходит для операций CUD.
-   Полностью материализованные объекты.
-   Поддерживает кэширование плана запроса.

**Минусы**

-   Включает строки текстового запроса, которые более подвержены ошибке пользователя, чем конструкции запроса, встроенные в язык.

### <a name="64-entity-sql-over-an-entity-command"></a>6.4 Сущность СЗЛ над Командованием Сущности

``` csharp
EntityCommand cmd = eConn.CreateCommand();
cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
{
    while (reader.Read())
    {
        // manually 'materialize' the product
    }
}
```

**Плюсы**

-   Поддержка кэширования запроса в .NET 4.0 (кэширование плана поддерживается всеми другими типами запросов в .NET 4.5).

**Минусы**

-   Включает строки текстового запроса, которые более подвержены ошибке пользователя, чем конструкции запроса, встроенные в язык.
-   Не подходит для операций CUD.
-   Результаты не материализуются автоматически и должны быть прочитаны с читна данных.

### <a name="65-sqlquery-and-executestorequery"></a>6.5 Sql-Куивери и ExecuteStore'ry

Sql-Кери по базе данных:

``` csharp
// use this to obtain entities and not track them
var q1 = context.Database.SqlQuery<Product>("select * from products");
```

Sql-Кери на DbSet:

``` csharp
// use this to obtain entities and have them tracked
var q2 = context.Products.SqlQuery("select * from products");
```

ExecyteStore'ry:

``` csharp
var beverages = context.ExecuteStoreQuery<Product>(
@"     SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued, P.DiscontinuedDate
       FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
       WHERE        (C.CategoryName = 'Beverages')"
);
```

**Плюсы**

-   Как правило, самая быстрая производительность, так как компилятор плана обойдяется стороной.
-   Полностью материализованные объекты.
-   Подходит для операций CUD при использовании из DbSet.

**Минусы**

-   Запрос является текстовым и подверженным ошибкам.
-   Запрос привязан к определенному бэкэнду с помощью семантики магазина вместо концептуальной семантики.
-   При наследовании запрос ручной работы должен учитывать условия отображения для запрашиваемого типа.

### <a name="66-compiledquery"></a>6.6 КомпилированныйКери

``` csharp
private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
    (NorthwindEntities context, string categoryName) =>
        context.Products.Where(p => p.Category.CategoryName == categoryName)
        );
…
var q = context.InvokeProductsForCategoryCQ("Beverages");
```

**Плюсы**

-   Обеспечивает повышение производительности до 7% по сравнению с обычными запросами НА ИНО.
-   Полностью материализованные объекты.
-   Подходит для операций CUD.

**Минусы**

-   Повышенная сложность и накладные расходы на программирование.
-   Улучшение производительности теряется при составлении поверх компилированного запроса.
-   Некоторые запросы LIN's не могут быть записаны в виде компилированного кекери - например, прогнозы анонимных типов.

### <a name="67-performance-comparison-of-different-query-options"></a>6.7 Сравнение производительности различных параметров запроса

Простые микробенчмарки, где создание контекста не было приурочено, были поставлены на испытания. Мы измерили 5000 раз запросов для набора некэшированных сущностей в контролируемой среде. Эти цифры следует воспринимать с предупреждением: они не отражают фактические числа, производимые приложением, но вместо этого они являются очень точным измерением того, сколько разница в производительности есть, когда различные варианты запроса сравниваются яблоки к яблокам, исключая стоимость создания нового контекста.

| EF  | Тест                                 | Время (ms) | Память   |
|:----|:-------------------------------------|:----------|:---------|
| EF5 | ОбъектКонтекст ЭСЗЛ                   | 2414      | 38801408 |
| EF5 | Объективный контекст Линк Запрос             | 2692      | 38277120 |
| EF5 | DbContext Линк Запрос Нет отслеживания     | 2818      | 41840640 |
| EF5 | DbContext Линк Запрос                 | 2930      | 41771008 |
| EF5 | ObjectContext Linq Запрос Без отслеживания | 3013      | 38412288 |
|     |                                      |           |          |
| EF6 | ОбъектКонтекст ЭСЗЛ                   | 2059      | 46039040 |
| EF6 | Объективный контекст Линк Запрос             | 3074      | 45248512 |
| EF6 | DbContext Линк Запрос Нет отслеживания     | 3125      | 47575040 |
| EF6 | DbContext Линк Запрос                 | 3420      | 47652864 |
| EF6 | ObjectContext Linq Запрос Без отслеживания | 3593      | 45260800 |

![МИКРО-бенчмарки EF5, 5000 теплых итераций](~/ef6/media/ef5micro5000warm.png)

![Микро-бенчмарки EF6, 5000 теплых итераций](~/ef6/media/ef6micro5000warm.png)

Микробенчмарки очень чувствительны к небольшим изменениям в коде. В этом случае разница между затратами на рамки 5 и Рамки Сущности 6 обусловлена добавлением [улучшений перехвата](~/ef6/fundamentals/logging-and-interception.md) и [транзакций.](~/ef6/saving/transactions.md) Эти микробенчмарки номера, однако, являются усиленное видение в очень небольшой фрагмент того, что Entity Framework делает. Реальные сценарии теплых запросов не должны видеть регрессию производительности при обновлении с рамки сущности 5 в рамку сущности 6.

Для сравнения реальной производительности различных вариантов запросов мы создали 5 отдельных вариантов тестирования, где мы используем другой вариант запроса, чтобы выбрать все продукты, название категории которых "Beverages". Каждая итерация включает в себя затраты на создание контекста и затраты на материализацию всех возвращенных сущностей. 10 итераций запускаются без умопомрачения, прежде чем взять сумму в 1000 приуроченных итераций. Показанные результаты - это средний пробег, взятый из 5 запусков каждого теста. Для получения дополнительной информации смотрите приложение B, которое включает код для теста.

| EF  | Тест                                        | Время (ms) | Память   |
|:----|:--------------------------------------------|:----------|:---------|
| EF5 | Командование сущности ObjectContext                | 621       | 39350272 |
| EF5 | DbContext Sql Запрос на базе данных             | 825       | 37519360 |
| EF5 | Запрос магазина ObjectContext                   | 878       | 39460864 |
| EF5 | ObjectContext Linq Запрос Без отслеживания        | 969       | 38293504 |
| EF5 | ОбъектКонтекст Entity Sql с помощью объективного запроса | 1089      | 38981632 |
| EF5 | Компилированный запрос ObjectContext                | 1099      | 38682624 |
| EF5 | Объективный контекст Линк Запрос                    | 1152      | 38178816 |
| EF5 | DbContext Линк Запрос Нет отслеживания            | 1208      | 41803776 |
| EF5 | DbContext Sql Запрос на DbSet                | 1414      | 37982208 |
| EF5 | DbContext Линк Запрос                        | 1574      | 41738240 |
|     |                                             |           |          |
| EF6 | Командование сущности ObjectContext                | 480       | 47247360 |
| EF6 | Запрос магазина ObjectContext                   | 493       | 46739456 |
| EF6 | DbContext Sql Запрос на базе данных             | 614       | 41607168 |
| EF6 | ObjectContext Linq Запрос Без отслеживания        | 684       | 46333952 |
| EF6 | ОбъектКонтекст Entity Sql с помощью объективного запроса | 767       | 48865280 |
| EF6 | Компилированный запрос ObjectContext                | 788       | 48467968 |
| EF6 | DbContext Линк Запрос Нет отслеживания            | 878       | 47554560 |
| EF6 | Объективный контекст Линк Запрос                    | 953       | 47632384 |
| EF6 | DbContext Sql Запрос на DbSet                | 1023      | 41992192 |
| EF6 | DbContext Линк Запрос                        | 1290      | 47529984 |


![EF5 теплый запрос 1000 итераций](~/ef6/media/ef5warmquery1000.png)

![EF6 теплый запрос 1000 итераций](~/ef6/media/ef6warmquery1000.png)

> [!NOTE]
> Для полноты мы включили вариацию, в которой мы выполняем запрос Entity S'L на EntityCommand. Однако, поскольку результаты не материализовались для таких запросов, сравнение не обязательно яблоки к яблокам. Тест включает в себя близкое приближение к материализации, чтобы попытаться сделать сравнение более справедливым.

В этом сквозном случае, Entity Framework 6 превосходит Entity Framework 5 из-за улучшения производительности, сделанных на нескольких частях стека, включая гораздо более легкую инициализацию DbContext и более быстрый поиск MetadataCollection&lt;T.&gt;

## <a name="7-design-time-performance-considerations"></a>7 Соображения производительности времени проектирования

### <a name="71-inheritance-strategies"></a>7.1 Стратегии наследования

Другим соображением производительности при использовании системы Entity — стратегия наследования, используемая вами. Система Entity поддерживает 3 основных типа наследования и их комбинации:

-   Таблица для Иерархии (TPH) - где каждое наследование устанавливает карты в таблицу с столбцом распознавания, чтобы указать, какой конкретный тип в иерархии представлен в строке.
-   Таблица на тип (TPT) - где каждый тип имеет свою собственную таблицу в базе данных; таблицы детей определяют только столбцы, которые не содержат родительская таблица.
-   Таблица на класс (TPC) - где каждый тип имеет свою собственную полную таблицу в базе данных; таблицы детей определяют все их поля, включая те, которые определяются в типах родителей.

Если модель использует наследование TPT, сгенерированные запросы будут более сложными, чем запросы, генерируемые с другими стратегиями наследования, что может привести к более длительному времени выполнения в магазине.Как правило, для генерации запросов по модели TPT и материализации полученных объектов требуется больше времени.

Смотрите сообщение в блоге \< https://docs.microsoft.com/archive/blogs/adonet/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework>MSDN "Рассмотрение производительности при использовании TPT (таблица на тип) Наследования в рамках entity" MSDN: .

#### <a name="711-avoiding-tpt-in-model-first-or-code-first-applications"></a>7.1.1 Избегая TPT в приложениях Model First или Code First

При создании модели над существующей базой данных с схемой TPT не так много вариантов. Но при создании приложения с использованием Model First или Code First следует избегать наследования TPT из-за проблем с производительностью.

Когда вы используете Model First в Entity Designer Wizard, вы получите TPT для любого наследования в вашей модели. Если вы хотите перейти на стратегию наследования TPH с Model First, вы можете использовать \< http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/>)"Entity Designer Database Generation Power Pack" доступны в галерее Visual Studio ( .

При использовании Code First для настройки отображения модели с наследованием EF будет использовать TPH по умолчанию, поэтому все сущности в иерархии наследования будут отображены в одну таблицу. Подробнее о статье «Картирование с помощью API с помощью Свободного» в разделе [http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx)«Код первый в рамках entity4.1» смотрите раздел «Код первый в рамках entity4.1» в журнале MSDN () для получения более подробной информации.

### <a name="72-upgrading-from-ef4-to-improve-model-generation-time"></a>7.2 Обновление от EF4 для улучшения времени генерации модели

Конкретное усовершенствование сервера для алгоритма, генерируемого слоем (SSDL) модели, доступно в рамках Entity Framework 5 и 6, а также в качестве обновления для Entity Framework 4 при установке Visual Studio 2010 SP1. Следующие результаты тестирования демонстрируют улучшение при создании очень большой модели, в данном случае модели Navision. Более подробную информацию об этом можно узнать в приложении C.

Модель содержит 1005 наборов сущностей и 4227 наборов ассоциаций.

| Конфигурация                              | Разбивка времени, потребляемого                                                                                                                                               |
|:-------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Визуальная студия 2010, Entity Framework 4     | Поколение SSDL: 2 часа 27 мин <br/> Поколение карт: 1 секунда <br/> Поколение CSDL: 1 секунда <br/> Поколение объектного слоя: 1 секунда <br/> Поколение: 2 ч 14 мин |
| Визуальная студия 2010 SP1, Entity Framework 4 | Поколение SSDL: 1 секунда <br/> Поколение карт: 1 секунда <br/> Поколение CSDL: 1 секунда <br/> Поколение объектного слоя: 1 секунда <br/> Поколение: 1 час 53 мин   |
| Визуальная студия 2013, Entity Framework 5     | Поколение SSDL: 1 секунда <br/> Поколение карт: 1 секунда <br/> Поколение CSDL: 1 секунда <br/> Поколение объектного слоя: 1 секунда <br/> Поколение просмотра: 65 минут    |
| Визуальная студия 2013, Entity Framework 6     | Поколение SSDL: 1 секунда <br/> Поколение карт: 1 секунда <br/> Поколение CSDL: 1 секунда <br/> Поколение объектного слоя: 1 секунда <br/> Поколение просмотра: 28 секунд.   |


Стоит отметить, что при генерации SSDL нагрузка почти полностью расходуется на сервер S'L Server, в то время как машина разработки клиента ждет простоя, пока результаты будут возвращены с сервера. Освоен этому улучшению должны быть особенно оцениваемы dB. Стоит также отметить, что по существу вся стоимость генерации модели происходит в View Generation сейчас.

### <a name="73-splitting-large-models-with-database-first-and-model-first"></a>7.3 Разделение больших моделей с базой первой и модели first

По мере увеличения размера модели поверхность конструктора становится загроможденной и трудной в использовании. Обычно мы считаем модель с более чем 300 объектами слишком большой, чтобы эффективно использовать конструктор. Следующий блог описывает несколько вариантов \< https://docs.microsoft.com/archive/blogs/adonet/working-with-large-models-in-entity-framework-part-2>для разделения больших моделей: .

Сообщение было написано для первой версии Рамочной организации, но шаги все еще применяются.

### <a name="74-performance-considerations-with-the-entity-data-source-control"></a>7.4 Соображения производительности с помощью управления источниками данных entity

Мы видели случаи в многопоточных производительности и стресс-тестов, где производительность веб-приложения с помощью EntityDataSource Control значительно ухудшается. Основная причина заключается в том, что EntityDataSource неоднократно вызывает MetadataWorkspace.LoadFromAssembly на сборках, на которые ссылается веб-приложение, чтобы обнаружить типы, которые будут использоваться в качестве сущностей.

Решение заключается в том, чтобы установить ContextTypeName EntityDataSource к типу имени вашего производного класса ObjectContext. Это выключает механизм, который сканирует все ссылки на сборки для типов сущностей.

Установка поля ContextTypeName также предотвращает функциональную проблему, когда EntityDataSource в .NET 4.0 бросает ReflectionTypeLoadException, когда он не может загрузить тип из сборки с помощью отражения. Эта проблема была исправлена в .NET 4.5.

### <a name="75-poco-entities-and-change-tracking-proxies"></a>7.5 Сущности POCO и прокси-данные по отслеживанию изменений

Entity Framework позволяет использовать индивидуальные классы данных вместе с моделью данных без внесения каких-либо изменений в сами классы данных. Это означает, что с моделью данных могут быть использованы традиционные объекты среды CLR (POCO), например существующие объекты домена. Эти классы данных POCO (также известные как объекты, не осведомленные о сохранении), которые отображаются на сущностях, которые определяются в модели данных, поддерживают большую часть одного и того же запроса, вставляют, обновляют и удаляют поведения как типы сущностей, генерируемые инструментами модели данных entity.

Система entity может также создавать классы прокси, полученные из типов POCO, которые используются при входной функции, такие как ленивая загрузка и автоматическое отслеживание изменений на объектах POCO. Ваши классы POCO должны соответствовать определенным требованиям, позволяющим системе [http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx)Entity Framework использовать прокси- иподобия, как описано здесь: .

Прокси-менеджеры отслеживания шансов будут уведомлять диспетчера состояния объектов каждый раз, когда любое из свойств ваших сущностей изменяется, поэтому система Entity Это делается путем добавления событий уведомлений в тело методов сеттера ваших свойств и с помощью менеджера состояния объекта обработки таких событий. Обратите внимание, что создание прокси-сущности, как правило, будет более дорогостоящим, чем создание сущности POCO, не являющаяся прокси-сервером, из-за добавленного набора событий, созданных рамочной организацией entity.

Если у сущности POCO нет прокси-сервера отслеживания изменений, изменения обнаруживаются путем сравнения содержимого сущностей с копией предыдущего сохраненного состояния. Это глубокое сравнение станет длительным процессом, когда у вас есть много сущностей в контексте, или когда ваши сущности имеют очень большое количество свойств, даже если ни одно из них не изменилось с момента последнего сравнения.

Резюмируя: при создании прокси-сервера отслеживания изменений вы будете платить за производительность, но отслеживание изменений поможет вам ускорить процесс обнаружения изменений, когда у вас есть много свойств или когда в модели много сущностей. Для сущностей с небольшим количеством свойств, где количество сущностей не растет слишком много, наличие прокси-треков отслеживания изменений не может быть большой пользы.

## <a name="8-loading-related-entities"></a>8 Загрузка связанных лиц

### <a name="81-lazy-loading-vs-eager-loading"></a>8.1 Ленивая загрузка против стремящейся загрузки

Система сущности предлагает несколько различных способов загрузки сущностей, связанных с целевой сущностью. Например, при запросе для продуктов существуют различные способы загрузки соответствующих заказов в диспетчер состояния объектов. С точки зрения производительности, самый большой вопрос, который следует учитывать при загрузке связанных объектов, будет заключаться в том, следует ли использовать Ленивую загрузку или стремяться к загрузке.

При использовании Eager Loading связанные сущности загружаются вместе с набором целевой сущности. В запросе используется выписка включить, чтобы указать, какие связанные сущности вы хотите принести.

При использовании Lazy Loading исходный запрос приводит только набор целевой объект. Но всякий раз, когда вы получаете доступ к свойству навигации, другой запрос выдается в магазин для загрузки соответствующей сущности.

После загрузки объекта любые дополнительные запросы для объекта будут загружаться непосредственно от диспетчера состояния объектов, независимо от того, используете ли вы ленивую загрузку или недальновидную загрузку.

### <a name="82-how-to-choose-between-lazy-loading-and-eager-loading"></a>8.2 Как выбрать между ленивой загрузкой и стремящейся загрузкой

Важно то, что вы понимаете разницу между Ленивый загрузки и стремятся загрузки, так что вы можете сделать правильный выбор для вашего приложения. Это поможет вам оценить компромисс между несколькими запросами по базе данных и одним запросом, который может содержать большую полезную нагрузку. Возможно, целесообразно использовать несбывную загрузку в некоторых частях приложения и ленивую загрузку в других частях.

В качестве примера того, что происходит под капотом, предположим, вы хотите, чтобы запрос для клиентов, которые живут в Великобритании и их количество заказов.

**Использование стремящихся загрузки**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var ukCustomers = context.Customers.Include(c => c.Orders).Where(c => c.Address.Country == "UK");
    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

**Использование ленивой загрузки**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    context.ContextOptions.LazyLoadingEnabled = true;

    //Notice that the Include method call is missing in the query
    var ukCustomers = context.Customers.Where(c => c.Address.Country == "UK");

    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

При использовании нетерпеливой загрузки вы выдаете один запрос, который возвращает всем клиентам и всем заказам. Команда магазина выглядит следующим:

``` SQL
SELECT
[Project1].[C1] AS [C1],
[Project1].[CustomerID] AS [CustomerID],
[Project1].[CompanyName] AS [CompanyName],
[Project1].[ContactName] AS [ContactName],
[Project1].[ContactTitle] AS [ContactTitle],
[Project1].[Address] AS [Address],
[Project1].[City] AS [City],
[Project1].[Region] AS [Region],
[Project1].[PostalCode] AS [PostalCode],
[Project1].[Country] AS [Country],
[Project1].[Phone] AS [Phone],
[Project1].[Fax] AS [Fax],
[Project1].[C2] AS [C2],
[Project1].[OrderID] AS [OrderID],
[Project1].[CustomerID1] AS [CustomerID1],
[Project1].[EmployeeID] AS [EmployeeID],
[Project1].[OrderDate] AS [OrderDate],
[Project1].[RequiredDate] AS [RequiredDate],
[Project1].[ShippedDate] AS [ShippedDate],
[Project1].[ShipVia] AS [ShipVia],
[Project1].[Freight] AS [Freight],
[Project1].[ShipName] AS [ShipName],
[Project1].[ShipAddress] AS [ShipAddress],
[Project1].[ShipCity] AS [ShipCity],
[Project1].[ShipRegion] AS [ShipRegion],
[Project1].[ShipPostalCode] AS [ShipPostalCode],
[Project1].[ShipCountry] AS [ShipCountry]
FROM ( SELECT
      [Extent1].[CustomerID] AS [CustomerID],
       [Extent1].[CompanyName] AS [CompanyName],
       [Extent1].[ContactName] AS [ContactName],
       [Extent1].[ContactTitle] AS [ContactTitle],
       [Extent1].[Address] AS [Address],
       [Extent1].[City] AS [City],
       [Extent1].[Region] AS [Region],
       [Extent1].[PostalCode] AS [PostalCode],
       [Extent1].[Country] AS [Country],
       [Extent1].[Phone] AS [Phone],
       [Extent1].[Fax] AS [Fax],
      1 AS [C1],
       [Extent2].[OrderID] AS [OrderID],
       [Extent2].[CustomerID] AS [CustomerID1],
       [Extent2].[EmployeeID] AS [EmployeeID],
       [Extent2].[OrderDate] AS [OrderDate],
       [Extent2].[RequiredDate] AS [RequiredDate],
       [Extent2].[ShippedDate] AS [ShippedDate],
       [Extent2].[ShipVia] AS [ShipVia],
       [Extent2].[Freight] AS [Freight],
       [Extent2].[ShipName] AS [ShipName],
       [Extent2].[ShipAddress] AS [ShipAddress],
       [Extent2].[ShipCity] AS [ShipCity],
       [Extent2].[ShipRegion] AS [ShipRegion],
       [Extent2].[ShipPostalCode] AS [ShipPostalCode],
       [Extent2].[ShipCountry] AS [ShipCountry],
      CASE WHEN ([Extent2].[OrderID] IS NULL) THEN CAST(NULL AS int) ELSE 1 END AS [C2]
      FROM  [dbo].[Customers] AS [Extent1]
      LEFT OUTER JOIN [dbo].[Orders] AS [Extent2] ON [Extent1].[CustomerID] = [Extent2].[CustomerID]
      WHERE N'UK' = [Extent1].[Country]
)  AS [Project1]
ORDER BY [Project1].[CustomerID] ASC, [Project1].[C2] ASC
```

При использовании ленивой загрузки вы будете выдавать следующий запрос на начальном этапе:

``` SQL
SELECT
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[CompanyName] AS [CompanyName],
[Extent1].[ContactName] AS [ContactName],
[Extent1].[ContactTitle] AS [ContactTitle],
[Extent1].[Address] AS [Address],
[Extent1].[City] AS [City],
[Extent1].[Region] AS [Region],
[Extent1].[PostalCode] AS [PostalCode],
[Extent1].[Country] AS [Country],
[Extent1].[Phone] AS [Phone],
[Extent1].[Fax] AS [Fax]
FROM [dbo].[Customers] AS [Extent1]
WHERE N'UK' = [Extent1].[Country]
```

И каждый раз, когда вы получаете доступ к навигационному свойству Заказов клиента, в отношении магазина выдается другой запрос, подобный следующему:

``` SQL
exec sp_executesql N'SELECT
[Extent1].[OrderID] AS [OrderID],
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[EmployeeID] AS [EmployeeID],
[Extent1].[OrderDate] AS [OrderDate],
[Extent1].[RequiredDate] AS [RequiredDate],
[Extent1].[ShippedDate] AS [ShippedDate],
[Extent1].[ShipVia] AS [ShipVia],
[Extent1].[Freight] AS [Freight],
[Extent1].[ShipName] AS [ShipName],
[Extent1].[ShipAddress] AS [ShipAddress],
[Extent1].[ShipCity] AS [ShipCity],
[Extent1].[ShipRegion] AS [ShipRegion],
[Extent1].[ShipPostalCode] AS [ShipPostalCode],
[Extent1].[ShipCountry] AS [ShipCountry]
FROM [dbo].[Orders] AS [Extent1]
WHERE [Extent1].[CustomerID] = @EntityKeyValue1',N'@EntityKeyValue1 nchar(5)',@EntityKeyValue1=N'AROUT'
```

Для получения дополнительной информации [см.](https://msdn.microsoft.com/library/bb896272.aspx)

#### <a name="821-lazy-loading-versus-eager-loading-cheat-sheet"></a>8.2.1 Ленивая загрузка против стремящегося загрузки шпаргалки

Там нет такого понятия, как один-размер-подходит для выбора стремятся загрузки по сравнению с ленивыми загрузки. Сначала поймите различия между обеими стратегиями, чтобы вы могли принять взвешенное решение; также, рассмотрим, если ваш код подходит к любому из следующих сценариев:

| Сценарий                                                                    | Наше предложение                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|:----------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Вам необходимо получить доступ ко многим навигационным свойствам из извлеченных сущностей? | **Нет** - Оба варианта, вероятно, делать. Однако, если полезная нагрузка, которую приносит ваш запрос, не слишком велика, вы можете столкнуться с преимуществами производительности, используя загрузку Eager, поскольку для материализации объектов потребуется меньше сетевых поездок. <br/> <br/> **Да** - Если вам необходимо получить доступ ко многим навигационным свойствам от сущностей, вы бы сделали это, используя несколько включающих операторы в запросе с загрузкой Eager. Чем больше объектов вы включите, тем больше полезная нагрузка будет возвращаться в запрос. После включения трех или более объектов в свой запрос рассмотрите возможность переключения на ленивую загрузку. |
| Вы точно знаете, какие данные понадобятся во время выполнения?                   | **Нет** - Ленивая загрузка будет лучше для вас. В противном случае вы можете в конечном итоге запросить данные, которые вам не понадобятся. <br/> <br/> **Да** - Стремясь загрузки, вероятно, ваш лучший выбор; это поможет быстрее загрузить целые наборы. Если ваш запрос требует получения очень большого объема данных, и это становится слишком медленным, попробуйте ленивую загрузку вместо этого.                                                                                                                                                                                                                                                       |
| Ваш код используется далеко от вашей базы данных? (увеличение задержки сети)  | **Нет** - Когда задержка сети не является проблемой, использование Ленивая загрузка может упростить код. Помните, что топология приложения может измениться, поэтому не принимайте близость базы данных как должное. <br/> <br/> **Да** - Когда сеть является проблемой, только вы можете решить, что лучше подходит для вашего сценария. Как правило, eager загрузка будет лучше, потому что она требует меньше поездок в облаву.                                                                                                                                                                                                      |


#### <a name="822-performance-concerns-with-multiple-includes"></a>8.2.2 Проблемы производительности с несколькими включает

Когда мы слышим вопросы производительности, связанные с проблемами времени отклика сервера, источником проблемы часто являются запросы с несколькими операторами Включить. Хотя включение связанных сущностей в запрос является мощным, важно понимать, что происходит под крышкой.

Запрос с несколькими операторами Включить в нем занимает относительно много времени, чтобы просмотреть наш внутренний компилятор плана для создания команды магазина. Большая часть этого времени уходит на попытки оптимизировать полученный запрос. Команда сгенерированного хранилища будет содержать внешнее соединение или союз для каждого включения, в зависимости от от вашего отображения. Запросы, подобные этому, приведут к тому, что большие подключенные графики из вашей базы данных будут использоваться в одной полезной нагрузке, что приведет к acerbate любых проблем с пропускной способностью, особенно при большом увеличении полезной нагрузки (например, когда несколько уровней Включения используются для обхода ассоциаций в направлении от одного до многих).

Вы можете проверить случаи, когда ваши запросы возвращают слишком большие полезные нагрузки, обратившись к базовому запросу TS'L, используя ToTraceString и выполнив команду магазина в студии управления серверами S'L, чтобы увидеть размер полезной нагрузки. В таких случаях можно попытаться уменьшить количество инструкций Включить в запрос, чтобы просто принести данные, которые вам нужны. Или вы можете разбить запрос на меньшую последовательность субзапросов, например:

**Перед нарушением запроса:**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var customers = from c in context.Customers.Include(c => c.Orders)
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

**После взлома запроса:**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var orders = from o in context.Orders
                 where o.Customer.LastName.StartsWith(lastNameParameter)
                 select o;

    orders.Load();

    var customers = from c in context.Customers
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

Это будет работать только на отслеживаемых запросах, так как мы используем возможность контекста для выполнения разрешения идентификации и исправления ассоциации автоматически.

Как и в том, что с ленивой загрузкой, компромисс будет больше запросов для меньших полезных нагрузок. Вы также можете использовать проекции отдельных свойств, чтобы явно выбрать только данные, необходимые от каждой сущности, но в этом случае вы не будете загружать объекты, и обновления не будут поддерживаться.

#### <a name="823-workaround-to-get-lazy-loading-of-properties"></a>8.2.3 Обход, чтобы получить ленивый загрузки свойств

В настоящее время система Entity Framework не поддерживает ленивую загрузку масштабных или сложных свойств. Однако в тех случаях, когда есть таблица, включающая большой объект, такой как BLOB, можно использовать разделение таблицы, чтобы разделить большие свойства на отдельную сущность. Например, предположим, что у вас есть таблица продуктов, которая включает в себя варбинарную колонку фотографий. Если вам не часто требуется доступ к этому свойству в запросах, можно использовать разделение таблицы, чтобы привести только те части сущности, которые обычно необходимы. Сущность, представляющая фотографию продукта, будет загружена только тогда, когда она явно необходима.

Хороший ресурс, который показывает, как включить разделение таблицы является Гил Финк \< http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx>в "Таблица разделения в рамках entity" блоге: .

## <a name="9-other-considerations"></a>9 Другие соображения

### <a name="91-server-garbage-collection"></a>9.1 Сбор мусора сервера

Некоторые пользователи могут испытывать споры ресурсов, которые ограничивают параллелизм, который они ожидают, когда сборщик мусора не настроен должным образом. Всякий раз, когда EF используется в многопоточном сценарии или в любом приложении, напоминающее серверную систему, убедитесь, что включите сбор мусора сервера. Это делается с помощью простой настройки в файле конфигурации приложения:

``` xml
<?xmlversion="1.0" encoding="utf-8" ?>
<configuration>
        <runtime>
               <gcServer enabled="true" />
        </runtime>
</configuration>
```

Это должно уменьшить спор потока и увеличить пропускную состав до 30% в сценариях насыщения процессора. В общих чертах, вы всегда должны проверить, как ваше приложение ведет себя с помощью классической коллекции мусора (которая лучше настроить для сценариев uI и клиентской стороны), а также сбор мусора сервера.

### <a name="92-autodetectchanges"></a>9.2 АвтоОбнаруживизменения

Как упоминалось ранее, система entity Может отображать проблемы с производительностью, когда кэш объектов имеет много сущностей. Некоторые операции, такие как Добавить, Удалить, Найти, Входе и СохранитьИзменения, вызывают вызовы для DetectChanges, которые могут потреблять большое количество процессора в зависимости от размера кэша объектов. Причина этого заключается в том, что кэш объекта и диспетчер состояния объекта пытаются оставаться как можно более синхронизированными на каждой выполняемой операции в контексте, чтобы полученные данные были гарантированно корректны в широком спектре сценариев.

Как правило, это хорошая практика, чтобы оставить автоматическое обнаружение изменений Entity Framework включенным на весь срок службы вашего приложения. Если на сценарий негативно влияет высокое использование процессора, а профили указывают на то, что виновником является вызов DetectChanges, подумайте о временном отключении AutoDetectChanges в чувствительной части кода:

``` csharp
try
{
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    ...
}
finally
{
    context.Configuration.AutoDetectChangesEnabled = true;
}
```

Прежде чем отключить AutoDetectChanges, хорошо понять, что это может привести к потере возможности создавать возможности для отслеживания определенной информации об изменениях, происходящих на объектах. Если обработка обрабатывается неправильно, это может привести к несогласованности данных в приложении. Для получения дополнительной информации о \< http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/>выключении AutoDetectChanges, читайте .

### <a name="93-context-per-request"></a>9.3 Контекст за запрос

Контексты Entity Framework предназначены для использования в качестве недолговечных экземпляров для обеспечения наиболее оптимального опыта работы. Контексты, как ожидается, будут недолговечными и отбрасываются, и как таковые были реализованы, чтобы быть очень легкими и повторно использовать метаданные, когда это возможно. В веб-сценариях важно иметь это в виду и не иметь контекста больше, чем продолжительность одного запроса. Аналогичным образом, в невеб-сценариях контекст должен быть отброшен на основе вашего понимания различных уровней кэширования в рамочной системе сущности. Вообще говоря, следует избегать наличия контекста экземпляра на протяжении всего срока службы приложения, а также контекстов на поток и статические контексты.

### <a name="94-database-null-semantics"></a>9.4 Семантика базы данных нулевая

Система сущности по умолчанию будет\# генерировать код S'L, который имеет семантику сравнения C. Рассмотрим следующий запрос:

``` csharp
            int? categoryId = 7;
            int? supplierId = 8;
            decimal? unitPrice = 0;
            short? unitsInStock = 100;
            short? unitsOnOrder = 20;
            short? reorderLevel = null;

            var q = from p incontext.Products
                    wherep.Category.CategoryName == "Beverages"
                          || (p.CategoryID == categoryId
                                || p.SupplierID == supplierId
                                || p.UnitPrice == unitPrice
                                || p.UnitsInStock == unitsInStock
                                || p.UnitsOnOrder == unitsOnOrder
                                || p.ReorderLevel == reorderLevel)
                    select p;

            var r = q.ToList();
```

В этом примере мы сравниваем ряд недействительных переменных с необысданными свойствами на объекте, такими как SupplierID и UnitPrice. Сгенерированный СЗЛ для этого запроса спросит, является ли значение параметра таким же, как значение столбца, или если значение параметра и столбца являются нулевыми. Это скроет способ обработки сервера базы данных\# на нулевую информацию и обеспечит согласованный опыт C null для различных поставщиков баз данных. С другой стороны, сгенерированный код немного запутан и может не работать хорошо, когда количество сравнений в том, где выписка запроса увеличивается до большого числа.

Одним из способов решения этой ситуации является использование семантики нулевой базы данных. Обратите внимание, что это потенциально может\# вести себя по-другому ссемантики C null, так как теперь система Entity Framework будет генерировать более простые S'L, что предоставляет способ обработки движка базы данных нулевыми значениями. Семантика нулевой базы данных может быть активирована в контексте с одной строкой конфигурации в соответствии с конфигурацией контекста:

``` csharp
                context.Configuration.UseDatabaseNullSemantics = true;
```

Малые и средние запросы не будут отображать заметное улучшение производительности при использовании нулевой семантики базы данных, но разница станет более заметной по запросам с большим количеством потенциальных сравнений нуля.

В приведенном выше запросе разница в производительности составила менее 2% в микробенчмарке, работаемом в контролируемой среде.

### <a name="95-async"></a>9.5 Асин

Система сущности 6 ввела поддержку операций async при работе на .NET 4.5 или позже. По большей части приложения, имеющие спор, связанный с IO, получат наибольшую выгоду от использования асинхронного запроса и сохранения операций. Если ваша заявка не страдает от спора с IO, использование async в лучшем случае будет работать синхронно и возвращает результат в такое же количество времени, как синхронный вызов, или в худшем случае, просто отложить выполнение к асинхронной задаче и добавить дополнительное время к завершению вашего сценария.

Для получения информации о том, как работает асинхронное программирование, [http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx)которое поможет вам решить, улучшит ли async производительность вашего посещения приложения. Для получения дополнительной информации об использовании операций async в рамках entity, [см.](~/ef6/fundamentals/async.md
)

### <a name="96-ngen"></a>9.6 NGEN

Система Сущности 6 не приходит в установку по умолчанию фреза .NET. Таким образом, сборки рамок сущности не являются NGEN'd по умолчанию, что означает, что весь фреймворк entity подлежит той же стоимости JIT'ing, что и любая другая сборка MSIL. Это может ухудшить опыт F5 при разработке, а также холодный запуск вашего приложения в производственных средах. Для того, чтобы уменьшить стоимость процессора и памяти JIT'ing, рекомендуется NGEN Изображения Entity Framework по мере необходимости. Для получения дополнительной информации о том, как улучшить производительность запуска Entity Framework 6 с NGEN, [см.](~/ef6/fundamentals/performance/ngen.md)

### <a name="97-code-first-versus-edmx"></a>9.7 Код первый против EDMX

Рамки сущности причины о проблеме несоответствия impedance между объектно-ориентированным программированием и реляционными базами данных, имея в памяти представление концептуальной модели (объектов), схему хранения (база данных) и отображение между ними. Эти метаданные называются моделью данных сущности, или EDM для краткости. Из этого EDM, Entity Framework будет получать представления для данных туда и обратно от объектов в памяти в базу данных и обратно.

Когда система Entity Framework используется с файлом EDMX, который формально определяет концептуальную модель, схему хранения и отображение, то этап загрузки модели должен только подтвердить, что EDM является правильным (например, убедитесь, что нет отображения отсутствуют), затем генерировать представления, а затем проверить представления и иметь эти метаданные готовы к использованию. Только после этого можно выполнить запрос или сохранить новые данные в хранилище данных.

Подход Code First по своей сути является сложным генератором модели данных Entity. Рамочная система должна производить EDM из предоставленного кода; он делает это путем анализа классов, участвующих в модели, применения конвенций и настройки модели через Fluent API. После построения EDM структура entity по существу ведет себя так же, как и файл EDMX в проекте. Таким образом, построение модели с Code First добавляет дополнительную сложность, что приводит к более медленному времени запуска для Рамочной системы сущности по сравнению с EDMX. Стоимость полностью зависит от размера и сложности модели, которая строится.

При выборе использования EDMX против Code First важно знать, что гибкость, введенная Code First, увеличивает стоимость создания модели впервые. Если ваше приложение может выдержать стоимость этой первой нагрузки, то обычно Code First будет предпочтительным способом.

## <a name="10-investigating-performance"></a>10 Исследование производительности

### <a name="101-using-the-visual-studio-profiler"></a>10.1 Использование визуальной студии Профилер

Если у вас возникли проблемы с производительностью с рамочным образованием, вы можете использовать профайлер, как тот, который встроен в Visual Studio, чтобы увидеть, где ваше приложение тратит свое время. Это инструмент, который мы использовали для создания круговых диаграмм в "Изучение производительности ADO.NET \< https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1>) Entity Framework - Часть 1" блога (которые показывают, где Entity Framework проводит свое время во время холодных и теплых запросов.

В блоге "Профилирование entity Framework с использованием Visual Studio 2010 Profiler", написанном Консультативной группой по обработке данных и моделированию, показан реальный пример того, как они использовали профайлер для расследования проблемы производительности.\<https://docs.microsoft.com/archive/blogs/dmcat/profiling-entity-framework-using-the-visual-studio-2010-profiler>. Этот пост был написан для приложения окна. Если вам нужно профиль веб-приложения Windows Performance Recorder (WPR) и Windows Performance Analyzer (WPA) инструменты могут работать лучше, чем работа с Visual Studio. WPR и WPA являются частью инструментария производительности Windows, который [http://www.microsoft.com/download/details.aspx?id=39982](https://www.microsoft.com/download/details.aspx?id=39982)включен в комплект для оценки и развертывания Windows ().

### <a name="102-applicationdatabase-profiling"></a>10.2 Профилирование приложений/базы данных

Такие инструменты, как профайлер, встроенный в Visual Studio, говорят вам, где ваше приложение проводит время.Доступен другой тип профилировщика, который выполняет динамический анализ вашего запущенного приложения, как в производстве, так и в предсерийном производстве в зависимости от потребностей, и ищет общие подводные камни и антишаблоны доступа к базе данных.

Два коммерчески доступных профайлера являются \< http://efprof.com>) Entity Framework Profiler ( и ORMProfiler ( \< http://ormprofiler.com>).

Если приложение является приложением MVC с использованием Code First, вы можете использовать MiniProfiler StackExchange. Скотт Hanselman описывает этот инструмент \< http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx>в своем блоге на: .

Для получения дополнительной информации о профилировании деятельности базы данных вашего приложения, см. [Profiling Database Activity in the Entity Framework](https://msdn.microsoft.com/magazine/gg490349.aspx)

### <a name="103-database-logger"></a>10.3 Регистратор баз данных

Если вы используете Entity Framework 6, также рассмотрите возможность использования встроенной функциональности ведения журнала. Свойство контекста базы данных может быть проинструктировано регистрировать свою деятельность с помощью простой одностроковой конфигурации:

``` csharp
    using (var context = newQueryComparison.DbC.NorthwindEntities())
    {
        context.Database.Log = Console.WriteLine;
        var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
        q.ToList();
    }
```

В этом примере действие базы данных будет зарегистрировано на консоль, но&lt;&gt; свойство журнала может быть настроено для вызова любого делегата строки действий.

Если вы хотите включить журнал данных без перекомпиляции, и вы используете Entity Framework 6.1 или позже, вы можете сделать это, добавив перехватчик в web.config или файл app.config вашего приложения.

``` xml
  <interceptors>
    <interceptor type="System.Data.Entity.Infrastructure.Interception.DatabaseLogger, EntityFramework">
      <parameters>
        <parameter value="C:\Path\To\My\LogOutput.txt"/>
      </parameters>
    </interceptor>
  </interceptors>
```

Для получения дополнительной информации о том, \< http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/>как добавить журнал без перекомпиляции перейдите на .

## <a name="11-appendix"></a>11 Приложение

### <a name="111-a-test-environment"></a>11.1 A. Тестовая среда

Эта среда использует 2-автоматную настройку с базой данных на отдельной машине от клиентского приложения. Машины находятся в одной стойке, поэтому задержка сети относительно низка, но более реалистична, чем одномашинная среда.

#### <a name="1111-app-server"></a>11.1.1 App Server

##### <a name="11111-software-environment"></a>11.1.1.1 Программное обеспечение

-   Сущность Рамочная 4 Среда программного обеспечения
    -   Название ОС: Windows Server 2008 R2 Enterprise SP1.
    -   Визуальная студия 2010 - Ultimate.
    -   Visual Studio 2010 SP1 (только для некоторых сравнений).
-   Система сущности 5 и 6 Программная среда
    -   Имя ОС: Windows 8.1 Предприятие
    -   Визуальная студия 2013 - Ultimate.

##### <a name="11112-hardware-environment"></a>11.1.1.2 Аппаратная среда

-   Двойной процессор: Intel (R) Xeon (R) процессор L5520 W3530 2,27 ГГц, 2261 ГГц, 4 Core (ы), 84 Логический процессор (ы).
-   2412 ГБ RamRAM.
-   136 ГБ SCSI250 ГБ SATA 7200 об/мин 3 ГБ/с привода разделены на 4 перегородки.

#### <a name="1112-db-server"></a>11.1.2 DB-сервер

##### <a name="11121-software-environment"></a>11.1.2.1 Программная среда

-   Имя ОС: Windows Server 2008 R28.1 Предприятие SP1.
-   Сервер S'L 2008 R22012.

##### <a name="11122-hardware-environment"></a>11.1.2.2 Аппаратная среда

-   Единый процессор: Intel (R) Xeon (R) процессор L5520 2,27 ГГц, 2261 МГц-1620 0 - 3,60 ГГц, 4 Ядра (ы), 8 Логический процессор (ы).
-   824 ГБ RamRAM.
-   465 ГБ ATA500GB SATA 7200 об/мин 6 ГБ/с диска разделены на 4 перегородки.

### <a name="112-b-query-performance-comparison-tests"></a>11.2 B. Сравнительные тесты на производительность запросов

Для выполнения этих тестов использовалась модель Northwind. Она была создана из базы данных с помощью конструктора Entity Framework. Затем для сравнения производительности вариантов выполнения запроса был использован следующий код:

``` csharp
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.Entity.Infrastructure;
using System.Data.EntityClient;
using System.Data.Objects;
using System.Linq;

namespace QueryComparison
{
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
                );

        public IQueryable<Product> InvokeProductsForCategoryCQ(string categoryName)
        {
            return productsForCategoryCQ(this, categoryName);
        }
    }

    public class QueryTypePerfComparison
    {
        private static string entityConnectionStr = @"metadata=res://*/Northwind.csdl|res://*/Northwind.ssdl|res://*/Northwind.msl;provider=System.Data.SqlClient;provider connection string='data source=.;initial catalog=Northwind;integrated security=True;multipleactiveresultsets=True;App=EntityFramework'";

        public void LINQIncludingContextCreation()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTracking()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                context.Products.MergeOption = MergeOption.NoTracking;

                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void CompiledQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                var q = context.InvokeProductsForCategoryCQ("Beverages");
                q.ToList();
            }
        }

        public void ObjectQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
                products.ToList();
            }
        }

        public void EntityCommand()
        {
            using (EntityConnection eConn = new EntityConnection(entityConnectionStr))
            {
                eConn.Open();
                EntityCommand cmd = eConn.CreateCommand();
                cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

                using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
                {
                    List<Product> productsList = new List<Product>();
                    while (reader.Read())
                    {
                        DbDataRecord record = (DbDataRecord)reader.GetValue(0);

                        // 'materialize' the product by accessing each field and value. Because we are materializing products, we won't have any nested data readers or records.
                        int fieldCount = record.FieldCount;

                        // Treat all products as Product, even if they are the subtype DiscontinuedProduct.
                        Product product = new Product();  

                        product.ProductID = record.GetInt32(0);
                        product.ProductName = record.GetString(1);
                        product.SupplierID = record.GetInt32(2);
                        product.CategoryID = record.GetInt32(3);
                        product.QuantityPerUnit = record.GetString(4);
                        product.UnitPrice = record.GetDecimal(5);
                        product.UnitsInStock = record.GetInt16(6);
                        product.UnitsOnOrder = record.GetInt16(7);
                        product.ReorderLevel = record.GetInt16(8);
                        product.Discontinued = record.GetBoolean(9);

                        productsList.Add(product);
                    }
                }
            }
        }

        public void ExecuteStoreQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectResult<Product> beverages = context.ExecuteStoreQuery<Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Database.SqlQuery\<QueryComparison.DbC.Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbSet()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Products.SqlQuery(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void LINQIncludingContextCreationDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTrackingDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var q = context.Products.AsNoTracking().Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }
    }
}
```

### <a name="113-c-navision-model"></a>11.3 C. Модель Navision

База данных Navision — это большая база данных, используемая для демонстрации Microsoft Dynamics - NAV. Генерируемая концептуальная модель содержит 1005 наборов сущностей и 4227 наборов ассоциаций. Модель, используемая в тесте, является "плоской" - к ней не добавлено наследование.

#### <a name="1131-queries-used-for-navision-tests"></a>11.3.1 Запросы, используемые для тестов Navision

Список запросов, используемый в модели Navision, содержит 3 категории запросов Entity S'L:

##### <a name="11311-lookup"></a>11.3.1.1 Поиск

Простой запрос поиска без агрегаций

-   Количество голосов: 16232
-   Пример

``` xml
  <Query complexity="Lookup">
    <CommandText>Select value distinct top(4) e.Idle_Time From NavisionFKContext.Session as e</CommandText>
  </Query>
```

##### <a name="11312singleaggregating"></a>11.3.1.2 Одноразовие

Обычный запрос BI с несколькими агрегатами, но без субтоталов (один запрос)

-   Количество голосов: 2313
-   Пример

``` xml
  <Query complexity="SingleAggregating">
    <CommandText>NavisionFK.MDF_SessionLogin_Time_Max()</CommandText>
  </Query>
```

Где MDF\_SessionLogin\_Время\_Макс () определяется в модели как:

``` xml
  <Function Name="MDF_SessionLogin_Time_Max" ReturnType="Collection(DateTime)">
    <DefiningExpression>SELECT VALUE Edm.Min(E.Login_Time) FROM NavisionFKContext.Session as E</DefiningExpression>
  </Function>
```

##### <a name="11313aggregatingsubtotals"></a>11.3.1.3 Агрегатора

Запрос BI с агрегатами и субтоталами (через союз все)

-   Количество голосов: 178
-   Пример

``` xml
  <Query complexity="AggregatingSubtotals">
    <CommandText>
using NavisionFK;
function AmountConsumed(entities Collection([CRONUS_International_Ltd__Zone])) as
(
    Edm.Sum(select value N.Block_Movement FROM entities as E, E.CRONUS_International_Ltd__Bin as N)
)
function AmountConsumed(P1 Edm.Int32) as
(
    AmountConsumed(select value e from NavisionFKContext.CRONUS_International_Ltd__Zone as e where e.Zone_Ranking = P1)
)
----------------------------------------------------------------------------------------------------------------------
(
    select top(10) Zone_Ranking, Cross_Dock_Bin_Zone, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking, E.Cross_Dock_Bin_Zone
)
union all
(
    select top(10) Zone_Ranking, Cast(null as Edm.Byte) as P2, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking
)
union all
{
    Row(Cast(null as Edm.Int32) as P1, Cast(null as Edm.Byte) as P2, AmountConsumed(select value E
                                                                         from NavisionFKContext.CRONUS_International_Ltd__Zone as E
                                                                         where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed))
}</CommandText>
    <Parameters>
      <Parameter Name="MinAmountConsumed" DbType="Int32" Value="10000" />
    </Parameters>
  </Query>
```
