---
title: Отношения, навигационные свойства и иностранные ключи - EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 8a21ae73-6d9b-4b50-838a-ec1fddffcf37
ms.openlocfilehash: 76169f25d01bed81ad0748c9e85a67bd112a6e65
ms.sourcegitcommit: 144edccf9b29a7ffad119c235ac9808ec1a46193
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2020
ms.locfileid: "81434330"
---
# <a name="relationships-navigation-properties-and-foreign-keys"></a>Отношения, навигационные свойства и иностранные ключи

В этой статье приводится обзор того, как система Entity Framework управляет отношениями между сущностями. Он также дает некоторые рекомендации о том, как составить карту и манипулировать отношениями.

## <a name="relationships-in-ef"></a>Отношения в EF

В реляционных базах данных отношения (также называемые ассоциациями) между таблицами определяются через иностранные ключи. Внешний ключ (FK) — это столбец или сочетание столбцов, которое применяется для принудительного установления связи между данными в двух таблицах. Есть, как правило, три типа отношений: один-к-одному, один-к-многим, и многие-к-многим. В отношениях между собой один к многим, иностранный ключ определяется на столе, который представляет собой много конца отношений. Взаимоотношения между многими и многими включают определение третьей таблицы (называемой соединением или таблицей соединения), основной ключ которой состоит из иностранных ключей из обеих связанных таблиц. В отношениях один на один основной ключ действует дополнительно как иностранный ключ, и для любой из таблиц нет отдельной колонки иностранного ключа.

На следующем изображении показаны две таблицы, которые участвуют в отношениях между двумя другими. Таблица **Курса** является зависимой таблицей, поскольку она содержит столбец **DepartmentID,** который связывает ее с таблицей **Департамента.**

![Таблицы департамента и курса](~/ef6/media/database2.png)

В рамках сущности сущность может быть связана с другими сущностями через ассоциацию или отношения. Каждое отношение содержит два конца, описывающих тип сущности и многообразие типа (один, ноль или один, или много) для двух сущностей в этом отношении. Отношение может управляться справочным ограничением, описывающим, какой из конечных элементов отношения относится к основной роли, а какой к зависимой роли.

Свойства навигации обеспечивают способ навигации между двумя типами сущностей. Каждый объект может обладать свойством навигации для каждого отношения, в котором участвует. Свойства навигации позволяют перемещаться и управлять отношениями в обоих направлениях, возвращая либо эталонный объект (если разносторонность либо один или ноль или один) или коллекции (если многообразие много). Вы также можете иметь одностороннюю навигацию, и в этом случае вы определяете свойство навигации только по одному из типов, которые участвуют в отношениях, а не на обоих.

Рекомендуется включить свойства в модель, которая отображает сявречки в иностранные ключи в базе данных. Включение свойств внешних ключей позволяет создавать или изменять отношение, изменяя значение внешнего ключа для зависимого объекта. Сопоставление такого типа называется сопоставлением на основе внешнего ключа. Использование иностранных ключей является еще более важным при работе с отключенными объектами. Обратите внимание, что при работе с 1-к-1 или 1-к-0.. 1 отношения, нет отдельной иностранной ключевой колонки, основной ключ собственности выступает в качестве иностранного ключа и всегда входит в модель.

Когда иностранные ключевые столбцы не включены в модель, информация об ассоциации управляется как независимый объект. Отношения отслеживаются с помощью ссылок на объекты, а не с иностранными ключевыми свойствами. Этот тип ассоциации называется *независимой ассоциацией.* Наиболее распространенным способом изменения *независимой ассоциации* является изменение свойств навигации, которые генерируются для каждой организации, участвуют в ассоциации.

В модели можно использовать один или оба типа сопоставлений. Однако, если у вас есть чистые отношения между многими и многими, которые связаны таблицей соединения, содержащей только иностранные ключи, EF будет использовать независимую ассоциацию для управления такими отношениями, которые так много-к-многим.   

Следующее изображение показывает концептуальную модель, которая была создана с помощью конструктора рамок Entity. Модель содержит два сущности, которые участвуют в отношениях от одного к многим. Оба объекта имеют навигационные свойства. **Курс** является зависимым лицом и имеет **DepartmentID** иностранной ключевой собственности определяется.

![Таблицы отдела и курса с навигационными свойствами](~/ef6/media/relationshipefdesigner.png)

На следующем фрагменте кода показана та же модель, которая была создана с помощью Code First.

``` csharp
public class Course
{
  public int CourseID { get; set; }
  public string Title { get; set; }
  public int Credits { get; set; }
  public int DepartmentID { get; set; }
  public virtual Department Department { get; set; }
}

public class Department
{
   public Department()
   {
     this.Courses = new HashSet<Course>();
   }  
   public int DepartmentID { get; set; }
   public string Name { get; set; }
   public decimal Budget { get; set; }
   public DateTime StartDate { get; set; }
   public int? Administrator {get ; set; }
   public virtual ICollection<Course> Courses { get; set; }
}
```

## <a name="configuring-or-mapping-relationships"></a>Настройка или отображение отношений

Остальная часть этой страницы охватывает, как получить доступ и манипулировать данными с помощью отношений. Для получения информации о настройке отношений в модели см.

-   Для настройки отношений в Код есначала см. [Аннотации данных](~/ef6/modeling/code-first/data-annotations.md) и [API Fluent API - Отношения.](~/ef6/modeling/code-first/fluent/relationships.md)
-   Для настройки отношений с помощью конструктора рамок Entity [см.](~/ef6/modeling/designer/relationships.md)

## <a name="creating-and-modifying-relationships"></a>Создание и изменение отношений

В *иностранной ключевой ассоциации,* когда вы меняете отношения, состояние зависимого объекта с состоянием `EntityState.Unchanged` меняется на `EntityState.Modified`. В независимом отношении изменение отношения не обновляет состояние зависимого объекта.

Ниже приведены приведения примеров использования чужих ключевых свойств и навигационных свойств для ассоциации связанных объектов. С иностранными ключевыми ассоциациями можно использовать любой метод для изменения, создания или изменения отношений. Для независимых сопоставлений нельзя использовать свойство внешнего ключа.

- Присваивая новую стоимость иностранной ключевой собственности, как в следующем примере.  
  ``` csharp
  course.DepartmentID = newCourse.DepartmentID;
  ```

- Следующий код удаляет связь, установив иностранный ключ **на нуле.** Обратите внимание, что иностранное ключевое свойство должно быть аннулировано.  
  ``` csharp
  course.DepartmentID = null;
  ```

  >[!NOTE]
  > Если ссылка находится в добавленном состоянии (в этом примере объект курса), свойство ориентировочного навигационного свойства не будет синхронизировано с ключевыми значениями нового объекта до вызова SaveChanges. Синхронизация не выполняется, поскольку контекст объекта не содержит постоянных ключей для добавленных объектов, пока они не будут сохранены. Если необходимо полностью синхронизировать новые объекты, как только вы установите связь, используйте один из следующих методов».

- С помощью присваивания нового объекта свойству навигации. Следующий код создает связь между `department`курсом и . Если объекты присоединены к `course` контексту, то `department.Courses` также добавляется в коллекцию, а соответствующее свойство иностранного ключа на `course` объекте устанавливается к ключевой стоимости свойства отдела.  
  ``` csharp
  course.Department = department;
  ```

- Чтобы удалить связь, установите `null`свойство навигации. Если вы работаете с системой Entity Framework, основанной на .NET 4.0, то связанный конец должен быть загружен, прежде чем установить его на нулевую. Пример:   
  ``` csharp
  context.Entry(course).Reference(c => c.Department).Load();
  course.Department = null;
  ```

  Начиная с entity Framework 5.0, которая основана на .NET 4.5, можно установить связь с нуля без загрузки связанного конца. Можно также установить текущее значение, чтобы свести к нулю, используя следующий метод.   
  ``` csharp
  context.Entry(course).Reference(c => c.Department).CurrentValue = null;
  ```

- Путем удаления или добавления объекта в коллекцию сущностей. Например, можно добавить объект `Course` типа `department.Courses` в коллекцию. Эта операция создает связь между определенным `department` **курсом** и конкретным. Если объекты присоединены к контексту, ссылка отдела **course** и иностранное ключевое `department`свойство на объекте курса будут настроены на соответствующий .  
  ``` csharp
  department.Courses.Add(newCourse);
  ```

- Используя `ChangeRelationshipState` метод для изменения состояния заданного отношения между двумя объектами сущности. Этот метод чаще всего используется при работе с приложениями N-Tier и *независимой ассоциацией* (он не может быть использован с иностранной ключевой ассоциацией). Кроме того, чтобы использовать этот `ObjectContext`метод вы должны упасть до , как показано в примере ниже.  
В следующем примере существует много-к-много отношений между инструкторами и курсами. Вызов `ChangeRelationshipState` метода и `EntityState.Added` прохождение `SchoolContext` параметра позволяет узнать, что связь была добавлена между двумя объектами:
  ``` csharp

  ((IObjectContextAdapter)context).ObjectContext.
    ObjectStateManager.
    ChangeRelationshipState(course, instructor, c => c.Instructor, EntityState.Added);
  ```

  Обратите внимание, что если вы обновляете (а не просто добавляете) отношения, необходимо удалить старые отношения после добавления нового:

  ``` csharp
  ((IObjectContextAdapter)context).ObjectContext.
    ObjectStateManager.
    ChangeRelationshipState(course, oldInstructor, c => c.Instructor, EntityState.Deleted);
  ```

## <a name="synchronizing-the-changes-between-the-foreign-keys-and-navigation-properties"></a>Синхронизация изменений между иностранными ключами и навигационными свойствами

При изменении отношения объектов, прикрепленных к контексту, с помощью одного из описанных выше методов, системе entity необходимо синхронизировать иностранные ключи, ссылки и коллекции. Система сущности автоматически управляет этой синхронизацией (также известной как исправление отношений) для сущностей POCO с прокси-клиентами. Для получения дополнительной информации [см.](~/ef6/fundamentals/proxies.md)

Если вы используете сущности POCO без прокси-технологий, необходимо убедиться, что метод **DetectChanges** вызывается для синхронизации связанных объектов в контексте. Обратите внимание, что следующие AIS автоматически выпускают вызов **DetectChanges.**

-   `DbSet.Add`
-   `DbSet.AddRange`
-   `DbSet.Remove`
-   `DbSet.RemoveRange`
-   `DbSet.Find`
-   `DbSet.Local`
-   `DbContext.SaveChanges`
-   `DbSet.Attach`
-   `DbContext.GetValidationErrors`
-   `DbContext.Entry`
-   `DbChangeTracker.Entries`
-   Выполнение запроса LIN'а против`DbSet`

## <a name="loading-related-objects"></a>Загрузка связанных объектов

В рамках сущности обычно используются навигационные свойства для загрузки сущностей, связанных с возвращенной сущностью определенной ассоциацией. Для получения дополнительной информации [см.](~/ef6/querying/related-data.md)

> [!NOTE]
> В сопоставлении на основе внешнего ключа при загрузке связанного конечного элемента зависимого объекта связанный объект загружается на основе значения внешнего ключа зависимого объекта, находящегося на момент загрузки в памяти:

``` csharp
    // Get the course where currently DepartmentID = 2.
    Course course2 = context.Courses.First(c => c.DepartmentID == 2);

    // Use DepartmentID foreign key property
    // to change the association.
    course2.DepartmentID = 3;

    // Load the related Department where DepartmentID = 3
    context.Entry(course).Reference(c => c.Department).Load();
```

В независимом сопоставлении связанный конечный элемент зависимого объекта запрашивается на основе значения внешнего ключа зависимого объекта, находящегося на момент загрузки в базе данных. Однако, если связь была изменена, а свойство ссылки на зависимом объекте указывает на другой основной объект, загруженный в контексте объекта, рамочная сущность попытается создать связь так, как она определена на клиенте.

## <a name="managing-concurrency"></a>Управление параллелизмом

Как в иностранных ключевых, так и в независимых ассоциациях проверки параллелизма основаны на ключах сущности и других свойствах сущности, определенных в модели. При использовании EF Designer для создания `ConcurrencyMode` модели установите **атрибут, фиксированный,** чтобы указать, что свойство должно быть проверено на наличие параллелизма. При использовании Code First для `ConcurrencyCheck` определения модели используйте аннотацию на свойствах, которые вы хотите проверить на наличие параллелизма. При работе с Code First `TimeStamp` вы также можете использовать аннотацию, чтобы указать, что свойство должно быть проверено на наличие параллелизма. Вы можете иметь только одно свойство метки времени в данном типе. Code First отображает это свойство в поле, не являваещееся недействительной в базе данных.

Мы рекомендуем вам всегда использовать иностранную ключевую ассоциацию при работе с организациями, которые участвуют в проверке параллелизма и разрешении.

Для получения дополнительной информации [см.](~/ef6/saving/concurrency.md)

## <a name="working-with-overlapping-keys"></a>Работа с перекрывающимися ключами

Перекрывающиеся ключи представляют собой составные ключи, некоторые из свойств в которых также являются частью другого ключа в сущности. Для независимых сопоставлений использовать перекрывающиеся ключи нельзя. Для изменения сопоставления на основе внешнего ключа, содержащей перекрывающиеся ключи, рекомендуется изменять значения внешнего ключа вместо использования ссылок на объекты.
