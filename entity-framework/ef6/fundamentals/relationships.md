---
title: Связи, свойства навигации и внешние ключи — EF6
description: Связи, свойства навигации и внешние ключи в Entity Framework 6
author: divega
ms.date: 10/23/2016
ms.assetid: 8a21ae73-6d9b-4b50-838a-ec1fddffcf37
uid: ef6/fundamentals/relationships
ms.openlocfilehash: 63349d9a81065ea4e15a5f97ef5298cb3dc67339
ms.sourcegitcommit: 7c3939504bb9da3f46bea3443638b808c04227c2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/09/2020
ms.locfileid: "89618391"
---
# <a name="relationships-navigation-properties-and-foreign-keys"></a>Связи, свойства навигации и внешние ключи

В этой статье приводятся общие сведения о том, как Entity Framework управляет связями между сущностями. Кроме того, здесь приводятся некоторые рекомендации по сопоставлению и управлению связями.

## <a name="relationships-in-ef"></a>Связи в EF

В реляционных базах данных связи (также называемые связями) между таблицами определяются через внешние ключи. Внешний ключ (FK) — это столбец или сочетание столбцов, которое применяется для принудительного установления связи между данными в двух таблицах. Обычно существует три типа связей: один к одному, один ко многим и многие ко многим. В связи «один ко многим» внешний ключ определяется в таблице, которая представляет собой множество элементов связи. Связь «многие ко многим» включает определение третьей таблицы (которая называется соединением или связующей таблицей), первичный ключ которых состоит из внешних ключей из обеих связанных таблиц. В связи «один к одному» первичный ключ действует в качестве внешнего ключа и не имеет отдельного внешнего ключевого столбца для любой таблицы.

На следующем рисунке показаны две таблицы, участвующие в связи «один ко многим». Таблица **Course** является зависимой таблицей, так как она содержит столбец **DepartmentID** , связывающий его с таблицей **отдела** .

![Таблицы отделов и курсов](~/ef6/media/database2.png)

В Entity Framework сущность может быть связана с другими сущностями через ассоциацию или связь. Каждая связь содержит две конечные точки, описывающие тип сущности и кратность типа (один, ноль или один или несколько) для двух сущностей в этой связи. Отношение может управляться справочным ограничением, описывающим, какой из конечных элементов отношения относится к основной роли, а какой к зависимой роли.

Свойства навигации обеспечивают способ навигации по ассоциации между двумя типами сущностей. Каждый объект может обладать свойством навигации для каждого отношения, в котором участвует. Свойства навигации позволяют перемещать связи и управлять ими в обоих направлениях, возвращая либо ссылочный объект (если кратность — либо одна, либо нулевая или-одна), либо коллекция (если количество элементов равно многим). Вы также можете выбрать односторонний переход. в этом случае вы определяете свойство навигации только для одного из типов, участвующих в связи, а не для обеих.

Рекомендуется включать в модель свойства, которые сопоставляются с внешними ключами в базе данных. Включение свойств внешних ключей позволяет создавать или изменять отношение, изменяя значение внешнего ключа для зависимого объекта. Сопоставление такого типа называется сопоставлением на основе внешнего ключа. Использование внешних ключей еще более важно при работе с отключенными сущностями. Обратите внимание, что при работе с 1-1 или 1 на-0. 1 связи нет отдельного внешнего ключевого столбца, свойство первичного ключа выступает в качестве внешнего ключа и всегда включается в модель.

Если внешние ключевые столбцы не включены в модель, сведения о взаимосвязих управляются как независимый объект. Отношения отправляются через ссылки на объекты, а не на внешние ключевые свойства. Этот тип связи называется *независимой ассоциацией*. Наиболее распространенным способом изменения *независимой ассоциации* является изменение свойств навигации, создаваемых для каждой сущности, участвующей в ассоциации.

В модели можно использовать один или оба типа сопоставлений. Однако если у вас есть отношение "многие ко многим", которое соединено таблицей соединения, содержащей только внешние ключи, EF будет использовать независимую ассоциацию для управления связью "многие ко многим".   

На следующем рисунке показана концептуальная модель, созданная с помощью Entity Framework Designer. Модель содержит две сущности, участвующие в связи "один ко многим". Обе сущности имеют свойства навигации. **Курс** является зависимой сущностью и имеет определенное свойство внешнего ключа **DepartmentID** .

![Таблицы отделов и курсов со свойствами навигации](~/ef6/media/relationshipefdesigner.png)

В следующем фрагменте кода показана та же модель, которая была создана с помощью Code First.

``` csharp
public class Course
{
  public int CourseID { get; set; }
  public string Title { get; set; }
  public int Credits { get; set; }
  public int DepartmentID { get; set; }
  public virtual Department Department { get; set; }
}

public class Department
{
   public Department()
   {
     this.Courses = new HashSet<Course>();
   }  
   public int DepartmentID { get; set; }
   public string Name { get; set; }
   public decimal Budget { get; set; }
   public DateTime StartDate { get; set; }
   public int? Administrator {get ; set; }
   public virtual ICollection<Course> Courses { get; set; }
}
```

## <a name="configuring-or-mapping-relationships"></a>Настройка или сопоставление связей

В оставшейся части этой страницы описывается, как получить доступ к данным и управлять ими с помощью связей. Сведения о настройке связей в модели см. на следующих страницах.

-   Сведения о настройке связей в Code First см. в разделе [заметки к данным](xref:ef6/modeling/code-first/data-annotations) и [API Fluent — связи](xref:ef6/modeling/code-first/fluent/relationships).
-   Сведения о настройке связей с помощью Entity Framework Designer см. в разделе [связи с конструктором EF](xref:ef6/modeling/designer/relationships).

## <a name="creating-and-modifying-relationships"></a>Создание и изменение связей

При взаимосвязи с *внешним ключом*состояние зависимого объекта с `EntityState.Unchanged` состоянием изменяется на `EntityState.Modified` . В независимых отношениях изменение связи не приводит к обновлению состояния зависимого объекта.

В следующих примерах показано, как использовать свойства внешнего ключа и свойства навигации для связывания связанных объектов. С помощью ассоциаций внешнего ключа можно использовать любой из методов для изменения, создания или изменения связей. Для независимых сопоставлений нельзя использовать свойство внешнего ключа.

- Путем присвоения нового значения свойству внешнего ключа, как показано в следующем примере.  
  ``` csharp
  course.DepartmentID = newCourse.DepartmentID;
  ```

- Следующий код удаляет связь, присвоив внешнему ключу **значение NULL**. Обратите внимание, что свойство внешнего ключа должно допускать значение null.  
  ``` csharp
  course.DepartmentID = null;
  ```

  >[!NOTE]
  > Если ссылка находится в добавленном состоянии (в данном примере это объект Course), свойство навигации ссылки не будет синхронизировано с ключевыми значениями нового объекта до тех пор, пока не будет вызван метод SaveChanges. Синхронизация не выполняется, поскольку контекст объекта не содержит постоянных ключей для добавленных объектов, пока они не будут сохранены. Если необходимо полностью синхронизировать новые объекты, как только вы настроили связь, используйте один из следующих методов. *

- С помощью присваивания нового объекта свойству навигации. Следующий код создает связь между курсом и `department` . Если объекты присоединены к контексту, то объект `course` также добавляется в `department.Courses` коллекцию, а соответствующее свойство внешнего ключа `course` объекта задается значением свойства ключа отдела.  
  ``` csharp
  course.Department = department;
  ```

- Чтобы удалить связь, задайте для свойства навигации значение `null` . При работе с Entity Framework, основанной на .NET 4,0, необходимо загрузить связанный элемент, прежде чем присвоить ему значение null. Пример:   
  ``` csharp
  context.Entry(course).Reference(c => c.Department).Load();
  course.Department = null;
  ```

  Начиная с Entity Framework 5,0, основанного на .NET 4,5, можно установить связь со значением NULL без загрузки связанного элемента. Можно также задать для текущего значения значение NULL с помощью следующего метода.   
  ``` csharp
  context.Entry(course).Reference(c => c.Department).CurrentValue = null;
  ```

- Путем удаления или добавления объекта в коллекцию сущностей. Например, можно добавить объект типа `Course` в `department.Courses` коллекцию. Эта операция создает связь между определенным **курсом** и конкретным `department` . Если объекты присоединены к контексту, ссылка на отдел и свойство внешнего ключа в объекте **Course** будут установлены соответствующим образом `department` .  
  ``` csharp
  department.Courses.Add(newCourse);
  ```

- С помощью `ChangeRelationshipState` метода можно изменить состояние указанной связи между двумя объектами сущностей. Этот метод чаще всего используется при работе с N-уровневых приложениями и *независимой ассоциацией* (его нельзя использовать с Ассоциацией внешнего ключа). Кроме того, чтобы использовать этот метод, необходимо раскрывающийся список `ObjectContext` , как показано в примере ниже.  
В следующем примере существует связь «многие ко многим» между преподавателями и курсами. При вызове `ChangeRelationshipState` метода и передаче `EntityState.Added` параметра сообщается `SchoolContext` о том, что между двумя объектами была добавлена связь.
  ``` csharp

  ((IObjectContextAdapter)context).ObjectContext.
    ObjectStateManager.
    ChangeRelationshipState(course, instructor, c => c.Instructor, EntityState.Added);
  ```

  Обратите внимание, что при обновлении (не просто добавлении) связи необходимо удалить старую связь после добавления новой.

  ``` csharp
  ((IObjectContextAdapter)context).ObjectContext.
    ObjectStateManager.
    ChangeRelationshipState(course, oldInstructor, c => c.Instructor, EntityState.Deleted);
  ```

## <a name="synchronizing-the-changes-between-the-foreign-keys-and-navigation-properties"></a>Синхронизация изменений между внешними ключами и свойствами навигации

При изменении связи объектов, присоединенных к контексту с помощью одного из описанных выше методов, Entity Framework необходимо синхронизировать внешние ключи, ссылки и коллекции. Entity Framework автоматически управляет этой синхронизацией (также называется исправлением связи) для сущностей POCO с прокси-серверами. Дополнительные сведения см. в разделе [Работа с учетными записями-посредниками](xref:ef6/fundamentals/proxies).

При использовании сущностей POCO без прокси-серверов необходимо убедиться в том, что метод **DetectChanges** вызывается для синхронизации связанных объектов в контексте. Обратите внимание, что следующие интерфейсы API автоматически активируют вызов **DetectChanges** .

-   `DbSet.Add`
-   `DbSet.AddRange`
-   `DbSet.Remove`
-   `DbSet.RemoveRange`
-   `DbSet.Find`
-   `DbSet.Local`
-   `DbContext.SaveChanges`
-   `DbSet.Attach`
-   `DbContext.GetValidationErrors`
-   `DbContext.Entry`
-   `DbChangeTracker.Entries`
-   Выполнение запроса LINQ к элементу `DbSet`

## <a name="loading-related-objects"></a>Загрузка связанных объектов

В Entity Framework свойства навигации обычно используются для загрузки сущностей, связанных с возвращаемой сущностью, с помощью заданной ассоциации. Дополнительные сведения см. в разделе [Загрузка связанных объектов](xref:ef6/querying/related-data).

> [!NOTE]
> В сопоставлении на основе внешнего ключа при загрузке связанного конечного элемента зависимого объекта связанный объект загружается на основе значения внешнего ключа зависимого объекта, находящегося на момент загрузки в памяти:

``` csharp
    // Get the course where currently DepartmentID = 2.
    Course course = context.Courses.First(c => c.DepartmentID == 2);

    // Use DepartmentID foreign key property
    // to change the association.
    course.DepartmentID = 3;

    // Load the related Department where DepartmentID = 3
    context.Entry(course).Reference(c => c.Department).Load();
```

В независимом сопоставлении связанный конечный элемент зависимого объекта запрашивается на основе значения внешнего ключа зависимого объекта, находящегося на момент загрузки в базе данных. Однако если связь была изменена, а ссылочное свойство зависимого объекта указывает на другой объект Principal, загруженный в контекст объекта, Entity Framework попытается создать связь, как определено на клиенте.

## <a name="managing-concurrency"></a>Управление параллелизмом

Как в внешних, так и в независимых ассоциациях проверки параллелизма основываются на ключах сущностей и других свойствах сущности, определенных в модели. При использовании конструктора EF для создания модели присвойте `ConcurrencyMode` атрибуту значение **fixed** , чтобы указать, что свойство должно быть проверено на наличие параллелизма. При использовании Code First для определения модели используйте `ConcurrencyCheck` заметку для свойств, которые необходимо проверить на наличие параллелизма. При работе с Code First можно также использовать `TimeStamp` заметку, чтобы указать, что свойство должно проверяться на параллелизм. В данном классе может быть только одно свойство timestamp. Code First сопоставляет это свойство с полем базы данных, не допускающим значения NULL.

При работе с сущностями, участвующими в проверке и разрешении параллелизма, рекомендуется всегда использовать связь по внешнему ключу.

Дополнительные сведения см. в разделе [Обработка конфликтов параллелизма](xref:ef6/saving/concurrency).

## <a name="working-with-overlapping-keys"></a>Работа с перекрывающимися ключами

Перекрывающиеся ключи представляют собой составные ключи, некоторые из свойств в которых также являются частью другого ключа в сущности. Для независимых сопоставлений использовать перекрывающиеся ключи нельзя. Для изменения сопоставления на основе внешнего ключа, содержащей перекрывающиеся ключи, рекомендуется изменять значения внешнего ключа вместо использования ссылок на объекты.
