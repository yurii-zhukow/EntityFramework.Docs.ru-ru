---
title: Связи, свойства навигации и внешние ключи — EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 8a21ae73-6d9b-4b50-838a-ec1fddffcf37
ms.openlocfilehash: cc7160f2d0ab7ac0c6009f820441c88590cacfaf
ms.sourcegitcommit: 18ab4c349473d94b15b4ca977df12147db07b77f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/06/2019
ms.locfileid: "73655867"
---
# <a name="relationships-navigation-properties-and-foreign-keys"></a>Связи, свойства навигации и внешние ключи
В этом разделе приводятся общие сведения о том, как Entity Framework управляет связями между сущностями. Кроме того, здесь приводятся некоторые рекомендации по сопоставлению и управлению связями.

## <a name="relationships-in-ef"></a>Связи в EF

В реляционных базах данных связи (также называемые связями) между таблицами определяются через внешние ключи. Внешний ключ (FK) — это столбец или сочетание столбцов, используемых для установления и принудительного связывания данных в двух таблицах. Обычно существует три типа связей: один к одному, один ко многим и многие ко многим. В связи «один ко многим» внешний ключ определяется в таблице, которая представляет собой множество элементов связи. Связь «многие ко многим» включает определение третьей таблицы (которая называется соединением или связующей таблицей), первичный ключ которых состоит из внешних ключей из обеих связанных таблиц. В связи «один к одному» первичный ключ действует в качестве внешнего ключа и не имеет отдельного внешнего ключевого столбца для любой таблицы.

На следующем рисунке показаны две таблицы, участвующие в связи «один ко многим». Таблица **Course** является зависимой таблицей, так как она содержит столбец **DepartmentID** , связывающий его с таблицей **отдела** .

![Таблицы отделов и курсов](~/ef6/media/database2.png)

В Entity Framework сущность может быть связана с другими сущностями через ассоциацию или связь. Каждая связь содержит две конечные точки, описывающие тип сущности и кратность типа (один, ноль или один или несколько) для двух сущностей в этой связи. Связь может управляться ссылочным ограничением, которое описывает, какой элемент связи является основной ролью и является зависимой ролью.

Свойства навигации обеспечивают способ навигации по ассоциации между двумя типами сущностей. Каждый объект может обладать свойством навигации для каждого отношения, в котором участвует. Свойства навигации позволяют перемещать связи и управлять ими в обоих направлениях, возвращая либо ссылочный объект (если кратность — либо одна, либо нулевая или-одна), либо коллекция (если количество элементов равно многим). Вы также можете выбрать односторонний переход. в этом случае вы определяете свойство навигации только для одного из типов, участвующих в связи, а не для обеих.

Рекомендуется включать в модель свойства, которые сопоставляются с внешними ключами в базе данных. Включение свойств внешних ключей позволяет создавать или изменять отношение, изменяя значение внешнего ключа для зависимого объекта. Сопоставление такого типа называется сопоставлением на основе внешнего ключа. Использование внешних ключей еще более важно при работе с отключенными сущностями. Обратите внимание, что при работе с 1-1 или 1 на-0. 1 связи нет отдельного внешнего ключевого столбца, свойство первичного ключа выступает в качестве внешнего ключа и всегда включается в модель.

Если внешние ключевые столбцы не включены в модель, сведения о взаимосвязих управляются как независимый объект. Отношения отправляются через ссылки на объекты, а не на внешние ключевые свойства. Этот тип связи называется *независимой ассоциацией*. Наиболее распространенным способом изменения *независимой ассоциации* является изменение свойств навигации, создаваемых для каждой сущности, участвующей в ассоциации.

В модели можно использовать один или оба типа сопоставлений. Однако если у вас есть отношение "многие ко многим", которое соединено таблицей соединения, содержащей только внешние ключи, EF будет использовать независимую ассоциацию для управления связью "многие ко многим".   

На следующем рисунке показана концептуальная модель, созданная с помощью Entity Framework Designer. Модель содержит две сущности, участвующие в связи "один ко многим". Обе сущности имеют свойства навигации. **Курс** является зависимой сущностью и имеет определенное свойство внешнего ключа **DepartmentID** .

![Таблицы отделов и курсов со свойствами навигации](~/ef6/media/relationshipefdesigner.png)

В следующем фрагменте кода показана та же модель, которая была создана с помощью Code First.

``` csharp
public class Course
{
  public int CourseID { get; set; }
  public string Title { get; set; }
  public int Credits { get; set; }
  public int DepartmentID { get; set; }
  public virtual Department Department { get; set; }
}

public class Department
{
   public Department()
   {
     this.Courses = new HashSet<Course>();
   }  
   public int DepartmentID { get; set; }
   public string Name { get; set; }
   public decimal Budget { get; set; }
   public DateTime StartDate { get; set; }
   public int? Administrator {get ; set; }
   public virtual ICollection<Course> Courses { get; set; }
}
```

## <a name="configuring-or-mapping-relationships"></a>Настройка или сопоставление связей

В оставшейся части этой страницы описывается, как получить доступ к данным и управлять ими с помощью связей. Сведения о настройке связей в модели см. на следующих страницах.

-   Сведения о настройке связей в Code First см. в разделе [заметки к данным](~/ef6/modeling/code-first/data-annotations.md) и [API Fluent — связи](~/ef6/modeling/code-first/fluent/relationships.md).
-   Сведения о настройке связей с помощью Entity Framework Designer см. в разделе [связи с конструктором EF](~/ef6/modeling/designer/relationships.md).

## <a name="creating-and-modifying-relationships"></a>Создание и изменение связей

В *связи с внешним ключом*при изменении связи состояние зависимого объекта с состоянием `EntityState.Unchanged` меняется на `EntityState.Modified`. В независимых отношениях изменение связи не приводит к обновлению состояния зависимого объекта.

В следующих примерах показано, как использовать свойства внешнего ключа и свойства навигации для связывания связанных объектов. С помощью ассоциаций внешнего ключа можно использовать любой из методов для изменения, создания или изменения связей. Для независимых сопоставлений нельзя использовать свойство внешнего ключа.

- Путем присвоения нового значения свойству внешнего ключа, как показано в следующем примере.  
  ``` csharp
  course.DepartmentID = newCourse.DepartmentID;
  ```

- Следующий код удаляет связь, присвоив внешнему ключу **значение NULL**. Обратите внимание, что свойство внешнего ключа должно допускать значение null.  
  ``` csharp
  course.DepartmentID = null;
  ```

  >[!NOTE]
  > Если ссылка находится в добавленном состоянии (в данном примере это объект Course), свойство навигации ссылки не будет синхронизировано с ключевыми значениями нового объекта до тех пор, пока не будет вызван метод SaveChanges. Синхронизация не выполняется, поскольку контекст объекта не содержит постоянных ключей для добавленных объектов, пока они не будут сохранены. Если необходимо полностью синхронизировать новые объекты, как только вы настроили связь, используйте один из следующих методов. *

- С помощью присваивания нового объекта свойству навигации. Следующий код создает связь между курсом и `department`. Если объекты присоединены к контексту, `course` также добавляется в коллекцию `department.Courses`, а соответствующее свойство внешнего ключа в объекте `course` задается значением свойства ключа отдела.  
  ``` csharp
  course.Department = department;
  ```

- Чтобы удалить связь, задайте для свойства навигации значение `null`. При работе с Entity Framework, основанной на .NET 4,0, необходимо загрузить связанный элемент, прежде чем присвоить ему значение null. Пример:   
  ``` csharp
  context.Entry(course).Reference(c => c.Department).Load();
  course.Department = null;
  ```

  Начиная с Entity Framework 5,0, основанного на .NET 4,5, можно установить связь со значением NULL без загрузки связанного элемента. Можно также задать для текущего значения значение NULL с помощью следующего метода.   
  ``` csharp
  context.Entry(course).Reference(c => c.Department).CurrentValue = null;
  ```

- Путем удаления или добавления объекта в коллекцию сущностей. Например, можно добавить объект типа `Course` в коллекцию `department.Courses`. Эта операция создает связь между определенным **курсом** и определенным `department`. Если объекты присоединены к контексту, для ссылки на отдел и свойства внешнего ключа в объекте **Course** будет задан соответствующий `department`.  
  ``` csharp
  department.Courses.Add(newCourse);
  ```

- С помощью метода `ChangeRelationshipState` для изменения состояния указанной связи между двумя объектами сущностей. Этот метод чаще всего используется при работе с N-уровневых приложениями и *независимой ассоциацией* (его нельзя использовать с Ассоциацией внешнего ключа). Кроме того, чтобы использовать этот метод, необходимо раскрывающийся список `ObjectContext`, как показано в примере ниже.  
В следующем примере существует связь «многие ко многим» между преподавателями и курсами. Вызов метода `ChangeRelationshipState` и передача параметра `EntityState.Added` позволяет `SchoolContext`у понять, что между двумя объектами добавлена связь.
  ``` csharp

  ((IObjectContextAdapter)context).ObjectContext.
    ObjectStateManager.
    ChangeRelationshipState(course, instructor, c => c.Instructor, EntityState.Added);
  ```

  Обратите внимание, что при обновлении (не просто добавлении) связи необходимо удалить старую связь после добавления новой.

  ``` csharp
  ((IObjectContextAdapter)context).ObjectContext.
    ObjectStateManager.
    ChangeRelationshipState(course, oldInstructor, c => c.Instructor, EntityState.Deleted);
  ```

## <a name="synchronizing-the-changes-between-the-foreign-keys-and-navigation-properties"></a>Синхронизация изменений между внешними ключами и свойствами навигации

При изменении связи объектов, присоединенных к контексту с помощью одного из описанных выше методов, Entity Framework необходимо синхронизировать внешние ключи, ссылки и коллекции. Entity Framework автоматически управляет этой синхронизацией (также называется исправлением связи) для сущностей POCO с прокси-серверами. Дополнительные сведения см. в разделе [Работа с учетными записями-посредниками](~/ef6/fundamentals/proxies.md).

При использовании сущностей POCO без прокси-серверов необходимо убедиться в том, что метод **DetectChanges** вызывается для синхронизации связанных объектов в контексте. Обратите внимание, что следующие интерфейсы API автоматически активируют вызов **DetectChanges** .

-   `DbSet.Add`
-   `DbSet.AddRange`
-   `DbSet.Remove`
-   `DbSet.RemoveRange`
-   `DbSet.Find`
-   `DbSet.Local`
-   `DbContext.SaveChanges`
-   `DbSet.Attach`
-   `DbContext.GetValidationErrors`
-   `DbContext.Entry`
-   `DbChangeTracker.Entries`
-   Выполнение запроса LINQ к `DbSet`

## <a name="loading-related-objects"></a>Загрузка связанных объектов

В Entity Framework свойства навигации обычно используются для загрузки сущностей, связанных с возвращаемой сущностью, с помощью заданной ассоциации. Дополнительные сведения см. в разделе [Загрузка связанных объектов](~/ef6/querying/related-data.md).

> [!NOTE]
> В сопоставлении на основе внешнего ключа при загрузке связанного конечного элемента зависимого объекта связанный объект загружается на основе значения внешнего ключа зависимого объекта, находящегося на момент загрузки в памяти:

``` csharp
    // Get the course where currently DepartmentID = 2.
    Course course2 = context.Courses.First(c=>c.DepartmentID == 2);

    // Use DepartmentID foreign key property
    // to change the association.
    course2.DepartmentID = 3;

    // Load the related Department where DepartmentID = 3
    context.Entry(course).Reference(c => c.Department).Load();
```

В независимом сопоставлении связанный конечный элемент зависимого объекта запрашивается на основе значения внешнего ключа зависимого объекта, находящегося на момент загрузки в базе данных. Однако если связь была изменена, а ссылочное свойство зависимого объекта указывает на другой объект Principal, загруженный в контекст объекта, Entity Framework попытается создать связь, как определено на клиенте.

## <a name="managing-concurrency"></a>Управление параллелизмом

Как в внешних, так и в независимых ассоциациях проверки параллелизма основываются на ключах сущностей и других свойствах сущности, определенных в модели. При использовании конструктора EF для создания модели установите атрибут `ConcurrencyMode` в значение **fixed** , чтобы указать, что свойство должно проверяться на параллелизм. При использовании Code First для определения модели используйте `ConcurrencyCheck`ную аннотацию для свойств, которые необходимо проверить на наличие параллелизма. При работе с Code First можно также использовать аннотацию `TimeStamp`, чтобы указать, что свойство должно проверяться на параллелизм. В данном классе может быть только одно свойство timestamp. Code First сопоставляет это свойство с полем базы данных, не допускающим значения NULL.

При работе с сущностями, участвующими в проверке и разрешении параллелизма, рекомендуется всегда использовать связь по внешнему ключу.

Дополнительные сведения см. в разделе [Обработка конфликтов параллелизма](~/ef6/saving/concurrency.md).

## <a name="working-with-overlapping-keys"></a>Работа с перекрывающимися ключами

Перекрывающиеся ключи представляют собой составные ключи, некоторые из свойств в которых также являются частью другого ключа в сущности. Для независимых сопоставлений использовать перекрывающиеся ключи нельзя. Для изменения сопоставления на основе внешнего ключа, содержащей перекрывающиеся ключи, рекомендуется изменять значения внешнего ключа вместо использования ссылок на объекты.
