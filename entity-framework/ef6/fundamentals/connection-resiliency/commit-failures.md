---
title: Обработка сбоев транзакций - EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 5b1f7a7d-1b24-4645-95ec-5608a31ef577
ms.openlocfilehash: cf2722496e207a8ecaa9cfaa4ca61e7248e5e58f
ms.sourcegitcommit: 144edccf9b29a7ffad119c235ac9808ec1a46193
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2020
ms.locfileid: "81434140"
---
# <a name="handling-transaction-commit-failures"></a>Обработка сбоев транзакций
> [!NOTE]
> **EF6.1 Только вперед** - функции, AA и т.д., обсуждаемые на этой странице, были введены в рамках entity 6.1. При использовании более ранней версии могут быть неприменимы некоторые или все сведения.  

В рамках 6.1 мы вводим новую функцию устойчивости соединения для EF: возможность обнаруживать и восстанавливаться автоматически, когда переходные сбои соединения влияют на подтверждение коммитов транзакции. Полная информация о сценарии лучше всего описана в блоге [S'L Database Connectivity и вопрос о идемпотенции](https://docs.microsoft.com/archive/blogs/adonet/sql-database-connectivity-and-the-idempotency-issue).  Таким образом, сценарий заключается в том, что при поднятии исключения во время коммита транзакции существует две возможные причины:  

1. Сбой транзакции на сервере
2. Транзакционный коммит удалось на сервере, но проблема подключения помешала уведомлению об успехе достичь клиента  

Когда первая ситуация происходит приложение или пользователь может повторить операцию, но когда вторая ситуация происходит retries следует избегать, и приложение может восстановить автоматически. Проблема заключается в том, что без возможности определить, что было фактической причиной исключения было сообщено во время комминажа, приложение не может выбрать правильный курс действий. Новая функция ef 6.1 позволяет EF перепроверить с базой данных, если транзакция прошла успешно, и прозрачно принять правильный курс действий.  

## <a name="using-the-feature"></a>Использование компонента  

Для включения функции, необходимой включить вызов [SetTransactionHandler](https://msdn.microsoft.com/library/system.data.entity.dbconfiguration.setdefaulttransactionhandler.aspx) в конструкторе **вашего DbConfiguration.** Если вы не знакомы с **DbConfiguration,** [см.](~/ef6/fundamentals/configuring/code-based.md) Эта функция может быть использована в сочетании с автоматическими повторами, которые мы ввели в EF6, которые помогают в ситуации, в которой транзакция фактически не удалось совершить на сервере из-за переходного сбоя:  

``` csharp
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.SqlServer;

public class MyConfiguration : DbConfiguration  
{
  public MyConfiguration()  
  {  
    SetTransactionHandler(SqlProviderServices.ProviderInvariantName, () => new CommitFailureHandler());  
    SetExecutionStrategy(SqlProviderServices.ProviderInvariantName, () => new SqlAzureExecutionStrategy());  
  }  
}
```  

## <a name="how-transactions-are-tracked"></a>Как отслеживаются транзакции  

Когда функция включена, EF автоматически добавит новую таблицу в базу данных под названием **__Transactions**. Новая строка вставляется в эту таблицу каждый раз, когда транзакция создается EF, и эта строка проверяется на наличие, если происходит сбой транзакции во время коммита.  

Хотя EF прилагает все усилия, чтобы подчеркнить строки из таблицы, когда они больше не нужны, таблица может вырасти, если приложение выйдет преждевременно, и по этой причине в некоторых случаях может потребоваться очистка таблицы вручную.  

## <a name="how-to-handle-commit-failures-with-previous-versions"></a>Как обрабатывать сбои в сбоях с предыдущими версиями

До EF 6.1 не существовало механизма обработки сбоев в работе сбоев в продукте EF. Существует несколько способов решения этой ситуации, которые могут быть применены к предыдущим версиям EF6:  

* Вариант 1 - Ничего не делать  

  Вероятность сбоя соединения во время совершения транзакции низка, поэтому может быть приемлемым для приложения просто сбой, если это условие действительно происходит.  

* Вариант 2 - Используйте базу данных для сбросить состояние  

  1. Отбросить текущий DbContext  
  2. Создание нового DbContext и восстановление состояния приложения из базы данных  
  3. Сообщите пользователю, что последняя операция, возможно, не была успешно завершена  

* Вариант 3 - Ручной отслеживание транзакции  

  1. Добавьте в базу данных неотслеживаемую таблицу, используемую для отслеживания состояния транзакций.  
  2. Вставьте строку в таблицу в начале каждой транзакции.  
  3. Если соединение выходит из строя во время коммина, проверьте наличие соответствующей строки в базе данных.  
     - Если строка присутствует, продолжайте нормально, так как транзакция была успешно совершена  
     - Если строка отсутствует, используйте стратегию выполнения для повторной попытки текущей операции.  
  4. Если коммит удален, удалите соответствующий ряд, чтобы избежать роста таблицы.  

[Этот блог содержит](https://docs.microsoft.com/archive/blogs/adonet/sql-database-connectivity-and-the-idempotency-issue) пример кода для выполнения этого на S'L Azure.  
