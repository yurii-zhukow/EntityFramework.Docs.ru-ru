---
title: Работа с прокси-серверами — EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 869ee4dc-06f1-471d-8e0e-0a1a2bc59c30
ms.openlocfilehash: 8f7d2e8b41ece28efe8d1df3b0679e6e4510d64a
ms.sourcegitcommit: cc0ff36e46e9ed3527638f7208000e8521faef2e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78415991"
---
# <a name="working-with-proxies"></a>Работа с учетными записями-посредниками
При создании экземпляров типов сущностей POCO Entity Framework часто создает экземпляры динамически создаваемого производного типа, который выступает в качестве прокси-сервера для сущности. Этот прокси-сервер переопределяет некоторые виртуальные свойства сущности, чтобы вставлять обработчики для выполнения действий автоматически при обращении к свойству. Например, этот механизм используется для поддержки отложенной загрузки связей. Методы, представленные в этом разделе, также применимы к моделям, созданным с помощью Code First и конструктора EF.  

## <a name="disabling-proxy-creation"></a>Отключение создания прокси-сервера  

Иногда бывает полезно предотвратить создание экземпляров прокси-сервера Entity Framework. Например, сериализация экземпляров, не являющихся прокси, значительно упрощается, чем сериализация экземпляров прокси-сервера. Создание прокси-сервера может быть отключено путем снятия флага Проксикреатионенаблед. В одном месте это можно сделать в конструкторе контекста. Пример:  

``` csharp
public class BloggingContext : DbContext
{
    public BloggingContext()
    {
        this.Configuration.ProxyCreationEnabled = false;
    }  

    public DbSet<Blog> Blogs { get; set; }
    public DbSet<Post> Posts { get; set; }
}
```  

Обратите внимание, что EF не будет создавать прокси для типов, где нет никаких действий для прокси-сервера. Это означает, что вы также можете избежать прокси-серверов, применяя типы, которые являются запечатанными и/или не имеют виртуальных свойств.  

## <a name="explicitly-creating-an-instance-of-a-proxy"></a>Явное создание экземпляра прокси-сервера  

Экземпляр прокси-сервера не будет создан при создании экземпляра сущности с помощью оператора New. Это может не быть проблемой, но если вам нужно создать экземпляр прокси-сервера (например, чтобы можно было работать с отложенной загрузкой или отслеживанием изменений прокси-сервера), вы можете сделать это с помощью метода Create объекта DbSet. Пример:  

``` csharp
using (var context = new BloggingContext())
{
    var blog = context.Blogs.Create();
}
```  

Универсальная версия Create может использоваться, если требуется создать экземпляр производного типа сущности. Пример:  

``` csharp
using (var context = new BloggingContext())
{
    var admin = context.Users.Create<Administrator>();
}
```  

Обратите внимание, что метод Create не добавляет или не прикрепляет созданную сущность к контексту.  

Обратите внимание, что метод Create просто создает экземпляр самого типа сущности, если создание прокси-типа для сущности не будет иметь значения, так как это не будет делать ничего. Например, если тип сущности — sealed и (или) не имеет виртуальных свойств, то при создании будет просто создан экземпляр типа сущности.  

## <a name="getting-the-actual-entity-type-from-a-proxy-type"></a>Получение фактического типа сущности из прокси-типа  

Имена типов прокси-сервера выглядят примерно так:  

System. Data. Entity. Динамикпроксиес. Blog_5E43C6C196972BF0754973E48C9C941092D86818CD94005E9A759B70BF6E48E6  

Тип сущности для этого типа прокси можно найти с помощью метода Жетобжекттипе из ObjectContext. Пример:  

``` csharp
using (var context = new BloggingContext())
{
    var blog = context.Blogs.Find(1);
    var entityType = ObjectContext.GetObjectType(blog.GetType());
}
```  

Обратите внимание, что, если тип, переданный в Жетобжекттипе, является экземпляром типа сущности, который не является прокси-типом, то возвращается тип сущности. Это означает, что этот метод всегда можно использовать для получения фактического типа сущности без какой-либо другой проверки на наличие типа прокси.  
