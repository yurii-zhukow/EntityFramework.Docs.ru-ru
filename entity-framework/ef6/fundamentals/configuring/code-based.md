---
title: Конфигурация на основе кода — EF6
description: Конфигурация на основе кода в Entity Framework 6
author: divega
ms.date: 10/23/2016
uid: ef6/fundamentals/configuring/code-based
ms.openlocfilehash: 67bb7ebd620c90ebe80983cc5baa6cab032907f8
ms.sourcegitcommit: abda0872f86eefeca191a9a11bfca976bc14468b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/14/2020
ms.locfileid: "90070735"
---
# <a name="code-based-configuration"></a>Конфигурация на основе кода
> [!NOTE]
> **Только в EF6 и более поздних версиях**. Функции, API и другие возможности, описанные на этой странице, появились в Entity Framework 6. При использовании более ранней версии могут быть неприменимы некоторые или все сведения.  

Конфигурацию Entity Frameworkного приложения можно указать в файле конфигурации (app.config/web.config) или с помощью кода. Последнее называется конфигурацией на основе кода.  

Конфигурация в файле конфигурации описывается в [отдельной статье](xref:ef6/fundamentals/configuring/config-file). Файл конфигурации имеет приоритет над конфигурацией на основе кода. Иными словами, если параметр конфигурации задан как в коде, так и в файле конфигурации, используется параметр в файле конфигурации.  

## <a name="using-dbconfiguration"></a>Использование DbConfiguration  

Конфигурация на основе кода в EF6 и более поздних версиях достигается путем создания подкласса System.Data.Entity.Config. DbConfiguration. При создании подкласса DbConfiguration следует следовать приведенным ниже рекомендациям.  

- Создайте только один класс DbConfiguration для приложения. Этот класс задает параметры уровня приложения для домена.  
- Поместите класс DbConfiguration в ту же сборку, что и класс DbContext. (Если вы хотите изменить этот параметр, см. раздел " *Перемещение DbConfiguration* ".)  
- Предоставьте классу DbConfiguration открытый конструктор без параметров.  
- Задайте параметры конфигурации, вызвав защищенные методы DbConfiguration в этом конструкторе.  

Следуя этим рекомендациям, платформа EF будет автоматически обнаруживать и использовать конфигурацию с помощью средств, которым требуется доступ к вашей модели и при запуске приложения.  

## <a name="example"></a>Пример  

Класс, производный от DbConfiguration, может выглядеть следующим образом:  

``` csharp
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.SqlServer;

namespace MyNamespace
{
    public class MyConfiguration : DbConfiguration
    {
        public MyConfiguration()
        {
            SetExecutionStrategy("System.Data.SqlClient", () => new SqlAzureExecutionStrategy());
            SetDefaultConnectionFactory(new LocalDbConnectionFactory("mssqllocaldb"));
        }
    }
}
```  

Этот класс настраивает EF для использования стратегии выполнения SQL Azure — для автоматической повторной попытки неудачных операций с базой данных, а также для использования локальной базы данных в целях создания по соглашению из Code First.  

## <a name="moving-dbconfiguration"></a>Перемещение DbConfiguration  

Бывают случаи, когда класс DbConfiguration не может быть размещен в той же сборке, что и класс DbContext. Например, у вас может быть два класса DbContext в разных сборках. Существует два способа обработки этого.  

Первый вариант — использовать файл конфигурации, чтобы указать используемый экземпляр DbConfiguration. Для этого задайте атрибут Кодеконфигуратионтипе раздела entityFramework. Пример:  

``` xml
<entityFramework codeConfigurationType="MyNamespace.MyDbConfiguration, MyAssembly">
    ...Your EF config...
</entityFramework>
```  

Значение Кодеконфигуратионтипе должно быть именем сборки и пространством имен класса DbConfiguration.  

Второй вариант — поместить Дбконфигуратионтипеаттрибуте в класс контекста. Пример:  

``` csharp  
[DbConfigurationType(typeof(MyDbConfiguration))]
public class MyContextContext : DbContext
{
}
```  

Значение, передаваемое в атрибут, может быть либо типом DbConfiguration, как показано выше, либо строкой с полным именем типа сборки и пространства имен. Пример:  

``` csharp
[DbConfigurationType("MyNamespace.MyDbConfiguration, MyAssembly")]
public class MyContextContext : DbContext
{
}
```  

## <a name="setting-dbconfiguration-explicitly"></a>Явное задание DbConfiguration  

Существуют ситуации, в которых может потребоваться настройка до использования любого типа DbContext. К таким примерам относятся:  

- Использование Дбмоделбуилдер для построения модели без контекста  
- Использование другого кода платформы или программы, использующего DbContext, где используется контекст, прежде чем будет использоваться контекст приложения  

В таких ситуациях EF не может автоматически обнаружить конфигурацию, и вместо этого необходимо выполнить одно из следующих действий.  

- Задайте тип DbConfiguration в файле конфигурации, как описано в разделе *Перемещение DbConfiguration* выше.
- Вызов статического метода DbConfiguration. Сетконфигуратион во время запуска приложения  

## <a name="overriding-dbconfiguration"></a>Переопределение DbConfiguration  

В некоторых ситуациях необходимо переопределить набор конфигураций в DbConfiguration. Обычно это не делается разработчиками приложений, а сторонними поставщиками и подключаемыми модулями, которые не могут использовать производный класс DbConfiguration.  

Для этого EntityFramework позволяет зарегистрировать обработчик событий, который может изменить существующую конфигурацию непосредственно перед тем, как он будет заблокирован.  Он также предоставляет метод SugarCRM, специально предназначенный для замены любой службы, возвращенной локатором службы EF. Вот как он предназначен для использования:  

- При запуске приложения (перед использованием EF) подключаемый модуль или поставщик должен зарегистрировать метод обработчика событий для этого события. (Обратите внимание, что это должно произойти до того, как приложение использует EF.)  
- Обработчик событий вызывает Реплацесервице для каждой службы, которую необходимо заменить.  

Например, чтобы заменить Идбконнектионфактори и Дбпровидерсервице, необходимо зарегистрировать обработчик примерно следующего вида:  

``` csharp
DbConfiguration.Loaded += (_, a) =>
   {
       a.ReplaceService<DbProviderServices>((s, k) => new MyProviderServices(s));
       a.ReplaceService<IDbConnectionFactory>((s, k) => new MyConnectionFactory(s));
   };
```  

В приведенном выше коде Мипровидерсервицес и Миконнектионфактори представляют свои реализации службы.  

Можно также добавить дополнительные обработчики зависимостей, чтобы получить тот же результат.  

Обратите внимание, что можно также переносить DbProviderFactory таким образом, но это повлияет только на EF и не использует DbProviderFactory, находящиеся за пределами EF. По этой причине вы, вероятно, захотите продолжить переносить DbProviderFactory, как было раньше.  

Следует также помнить о службах, которые вы запускаете в приложении извне, например при выполнении миграций из консоли диспетчера пакетов. При выполнении миграции из консоли будет предпринята попытка найти DbConfiguration. Тем не менее, независимо от того, получится ли служба в оболочке, зависит от того, где зарегистрирован обработчик событий. Если оно зарегистрировано как часть создания DbConfiguration, код должен выполняться и служба должна быть упакована. Обычно это не так, и это означает, что средства не будут получать упакованную службу.  
