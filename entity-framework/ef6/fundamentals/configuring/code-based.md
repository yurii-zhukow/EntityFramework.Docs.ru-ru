---
title: Конфигурация на основе кода — EF6
description: Конфигурация на основе кода в Entity Framework 6
author: ajcvickers
ms.date: 10/23/2016
uid: ef6/fundamentals/configuring/code-based
ms.openlocfilehash: b16cbcef85708730dcc6b82a38635cc60cb2206a
ms.sourcegitcommit: 704240349e18b6404e5a809f5b7c9d365b152e2e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/16/2021
ms.locfileid: "100543176"
---
# <a name="code-based-configuration"></a>Конфигурация на основе кода
> [!NOTE]
> **Только в EF6 и более поздних версиях**. Функции, API и другие возможности, описанные на этой странице, появились в Entity Framework 6. При использовании более ранней версии могут быть неприменимы некоторые или все сведения.  

Конфигурацию Entity Frameworkного приложения можно указать в файле конфигурации (app.config/web.config) или с помощью кода. Последнее называется конфигурацией на основе кода.  

Конфигурация в файле конфигурации описывается в [отдельной статье](xref:ef6/fundamentals/configuring/config-file). Файл конфигурации имеет приоритет над конфигурацией на основе кода. Иными словами, если параметр конфигурации задан как в коде, так и в файле конфигурации, используется параметр в файле конфигурации.  

## <a name="using-dbconfiguration"></a>Использование `DbConfiguration`

Конфигурация на основе кода в EF6 и более поздних версиях достигается путем создания подкласса `System.Data.Entity.Config.DbConfiguration` . При создании подклассов следует следовать приведенным ниже рекомендациям `DbConfiguration` .  

- Создайте только один `DbConfiguration` класс для приложения. Этот класс задает параметры уровня приложения для домена.  
- Поместите свой `DbConfiguration` класс в ту же сборку, что и `DbContext` класс. (Если вы хотите изменить этот параметр, см. раздел " *Перемещение `DbConfiguration`* ".)  
- Присвойте `DbConfiguration` классу открытый конструктор без параметров.  
- Задайте параметры конфигурации, вызвав защищенные `DbConfiguration` методы в этом конструкторе.  

Следуя этим рекомендациям, платформа EF будет автоматически обнаруживать и использовать конфигурацию с помощью средств, которым требуется доступ к вашей модели и при запуске приложения.  

## <a name="example"></a>Пример  

Класс, производный от, `DbConfiguration` может выглядеть следующим образом:  

``` csharp
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.SqlServer;

namespace MyNamespace
{
    public class MyConfiguration : DbConfiguration
    {
        public MyConfiguration()
        {
            SetExecutionStrategy("System.Data.SqlClient", () => new SqlAzureExecutionStrategy());
            SetDefaultConnectionFactory(new LocalDbConnectionFactory("mssqllocaldb"));
        }
    }
}
```  

Этот класс настраивает EF для использования стратегии выполнения SQL Azure — для автоматической повторной попытки неудачных операций с базой данных, а также для использования локальной базы данных в целях создания по соглашению из Code First.  

## <a name="moving-dbconfiguration"></a>Изменения `DbConfiguration`  

Бывают случаи, когда ваш класс невозможно разместить `DbConfiguration` в той же сборке, что и `DbContext` класс. Например, у вас может быть два `DbContext` класса, каждый в разных сборках. Существует два способа обработки этого.  

Первый вариант — использовать файл конфигурации, чтобы указать используемый `DbConfiguration` экземпляр. Для этого задайте атрибут Кодеконфигуратионтипе раздела entityFramework. Например:  

``` xml
<entityFramework codeConfigurationType="MyNamespace.MyDbConfiguration, MyAssembly">
    ...Your EF config...
</entityFramework>
```  

Значение Кодеконфигуратионтипе должно быть именем сборки и пространством имен `DbConfiguration` класса.  

Второй вариант — поместить `DbConfigurationTypeAttribute` в класс контекста. Например:  

``` csharp  
[DbConfigurationType(typeof(MyDbConfiguration))]
public class MyContextContext : DbContext
{
}
```  

Значение, передаваемое в атрибут, может быть либо `DbConfiguration` типом, как показано выше, либо строкой с полным именем типа сборки и пространства имен. Например:  

``` csharp
[DbConfigurationType("MyNamespace.MyDbConfiguration, MyAssembly")]
public class MyContextContext : DbContext
{
}
```  

## <a name="setting-dbconfiguration-explicitly"></a>`DbConfiguration`Явное задание  

Существуют ситуации, в которых может потребоваться настройка до использования любого `DbContext` типа. К таким примерам относятся:  

- Использование `DbModelBuilder` для построения модели без контекста  
- Использование другого кода платформы или программы, использующего, `DbContext` где используется контекст, до использования контекста приложения  

В таких ситуациях EF не может автоматически обнаружить конфигурацию, и вместо этого необходимо выполнить одно из следующих действий.  

- Задайте `DbConfiguration` тип в файле конфигурации, как описано в разделе " *Перемещение `DbConfiguration`* выше".
- Вызовите статический метод `DbConfiguration` . Метод Сетконфигуратион во время запуска приложения  

## <a name="overriding-dbconfiguration"></a>Переопределение `DbConfiguration`  

В некоторых ситуациях необходимо переопределить набор конфигураций в `DbConfiguration` . Обычно это не делается разработчиками приложений, а сторонними поставщиками и подключаемыми модулями, которые не могут использовать производный `DbConfiguration` класс.  

Для этого EntityFramework позволяет зарегистрировать обработчик событий, который может изменить существующую конфигурацию непосредственно перед тем, как он будет заблокирован.  Он также предоставляет метод SugarCRM, специально предназначенный для замены любой службы, возвращенной локатором службы EF. Вот как он предназначен для использования:  

- При запуске приложения (перед использованием EF) подключаемый модуль или поставщик должен зарегистрировать метод обработчика событий для этого события. (Обратите внимание, что это должно произойти до того, как приложение использует EF.)  
- Обработчик событий вызывает Реплацесервице для каждой службы, которую необходимо заменить.  

Например, для замены `IDbConnectionFactory` и `DbProviderService` регистрации обработчика примерно следующего вида:  

``` csharp
DbConfiguration.Loaded += (_, a) =>
   {
       a.ReplaceService<DbProviderServices>((s, k) => new MyProviderServices(s));
       a.ReplaceService<IDbConnectionFactory>((s, k) => new MyConnectionFactory(s));
   };
```  

В приведенном выше коде `MyProviderServices` и `MyConnectionFactory` представляет свои реализации службы.  

Можно также добавить дополнительные обработчики зависимостей, чтобы получить тот же результат.  

Обратите внимание, что можно также выполнить перенос таким `DbProviderFactory` образом, но это повлияет только на EF и не использует `DbProviderFactory` Внешние из EF. По этой причине вы, вероятно, захотите продолжить перенос `DbProviderFactory` , как и раньше.  

Следует также помнить о службах, которые вы запускаете в приложении извне, например при выполнении миграций из консоли диспетчера пакетов. При выполнении миграции из консоли будет предпринята попытка найти `DbConfiguration` . Тем не менее, независимо от того, получится ли служба в оболочке, зависит от того, где зарегистрирован обработчик событий. Если он зарегистрирован как часть конструкции, то `DbConfiguration` код должен выполняться, а служба должна быть заключена в оболочку. Обычно это не так, и это означает, что средства не будут получать упакованную службу.  
