---
title: Пригодность для тестирования и Entity Framework 4,0-EF6
description: Пригодность для тестирования и Entity Framework 4,0
author: ajcvickers
ms.date: 10/23/2016
ms.openlocfilehash: 8a9c8fbf7d6131498bd9b37567fdb90010b808cc
ms.sourcegitcommit: 0a25c03fa65ae6e0e0e3f66bac48d59eceb96a5a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/14/2020
ms.locfileid: "92062988"
---
# <a name="testability-and-entity-framework-40"></a>Пригодность для тестирования и Entity Framework 4,0
Скотт Аллен

Опубликовано: Май 2010

## <a name="introduction"></a>Введение

В этом техническом документе описывается и демонстрируется написание тестируемого кода с помощью ADO.NET Entity Framework 4,0 и Visual Studio 2010. Этот документ не пытается сосредоточиться на конкретной методологии тестирования, такой как проектирование на основе тестирования (TDD) или проектирование на основе поведения (BDD). В этом документе основное внимание уделяется тому, как писать код, использующий ADO.NET Entity Framework, но легко изолировать и протестировать в автоматическом режиме. Мы рассмотрим общие шаблоны разработки, которые облегчают тестирование в сценариях доступа к данным, и посмотрим, как применять эти шаблоны при использовании платформы. Мы также рассмотрим определенные функции платформы, чтобы увидеть, как эти функции могут работать в тестируемом коде.

## <a name="what-is-testable-code"></a>Что такое тестируемый код?

Возможность проверки части программного обеспечения с помощью автоматизированных модульных тестов предоставляет множество преимуществ. Все знают, что хорошие тесты уменьшают количество дефектов программного обеспечения в приложении и увеличивают качество приложения, но наличие модульных тестов далеко не просто найдет ошибки.

Хороший набор модульных тестов позволяет команде разработчиков экономить время и сохранять контроль над создаваемым им программным обеспечением. Команда может вносить изменения в существующий код, выполнять рефакторинг, реконструировать и изменять структуру программного обеспечения для удовлетворения новых требований и добавлять новые компоненты в приложение, в то время как знание набора тестов может проверить поведение приложения. Модульные тесты являются частью цикла быстрого отзыва, чтобы упростить изменение и сохранить сопровождение программного обеспечения по мере роста сложности.

Однако модульное тестирование имеет цену. Команда должна вкладывать время в создание и обслуживание модульных тестов. Объем усилий, необходимых для создания этих тестов, напрямую связан с **тестированием** базового программного обеспечения. Насколько легко тестировать программное обеспечение? Группа разработки программного обеспечения с учетом пригодности для тестирования создаст эффективные тесты быстрее, чем команда, работающая с нетестируемым программным обеспечением.

Корпорация Майкрософт разработала ADO.NET Entity Framework 4,0 (EF4) с учетом пригодности для тестирования. Это не означает, что разработчики будут писать модульные тесты для самого кода платформы. Вместо этого цели тестирования для EF4 упрощают создание тестируемого кода, который строится на основе платформы. Прежде чем приступать к рассмотрению конкретных примеров, важно понимать качество тестируемого кода.

### <a name="the-qualities-of-testable-code"></a>Качество тестируемого кода

Код, который легко протестировать, всегда будет иметь по крайней мере две особенности. Во-первых, можно легко **наблюдать**за тестируемым кодом. При наличии некоторого набора входных данных должно быть легко наблюдать за выходом кода. Например, проверка следующего метода проста, поскольку метод непосредственно возвращает результат вычисления.

``` csharp
    public int Add(int x, int y) {
        return x + y;
    }
```

Тестирование метода сложно, если метод записывает вычисленное значение в сетевой сокет, таблицу базы данных или файл, как в приведенном ниже коде. Тест должен выполнить дополнительную работу, чтобы получить значение.

``` csharp
    public void AddAndSaveToFile(int x, int y) {
         var results = string.Format("The answer is {0}", x + y);
         File.WriteAllText("results.txt", results);
    }
```

Во-вторых, легко **изолировать**тестируемый код. Давайте воспользуемся следующим псевдокодом в качестве неправильного примера тестируемого кода.

``` csharp
    public int ComputePolicyValue(InsurancePolicy policy) {
        using (var connection = new SqlConnection("dbConnection"))
        using (var command = new SqlCommand(query, connection)) {

            // business calculations omitted ...               

            if (totalValue > notificationThreshold) {
                var message = new MailMessage();
                message.Subject = "Warning!";
                var client = new SmtpClient();
                client.Send(message);
            }
        }
        return totalValue;
    }
```

Этот метод прост в наблюдении — можно передать страховую полис и проверить, что возвращаемое значение соответствует ожидаемому результату. Однако для тестирования метода необходимо установить базу данных с правильной схемой и настроить SMTP-сервер на случай, если метод попытается отправить сообщение электронной почты.

Модульный тест хочет проверить логику вычисления внутри метода, но тест может завершиться ошибкой из-за того, что сервер электронной почты находится в автономном режиме или если сервер базы данных был перемещен. Обе эти ошибки не связаны с поведением, которое тест желает проверить. Такое поведение сложно изолировать.

Разработчики программного обеспечения, стремящиеся написать тестируемый код, часто стремятся поддерживать разделение проблем в написанном им коде. Приведенный выше метод должен сосредоточиться на бизнес-вычислениях и делегировать сведения о реализации базы данных и электронной почты другим компонентам. Роберт C. Мартен вызывает этот принцип единой ответственности. Объект должен инкапсулировать одну, более узкую ответственность, например вычисление значения политики. Все остальные работы с базами данных и уведомлениями должны быть ответственными за другой объект. Код, написанный таким способом, проще изолировать, поскольку он сосредоточен на одной задаче.

В .NET есть абстракции, которые необходимо соблюдать принципу единой ответственности и достичь изоляции. Мы можем использовать определения интерфейсов и заставить код использовать абстракцию интерфейса вместо конкретного типа. Далее в этом документе мы посмотрим, как метод, похожий на приведенный выше, может работать с интерфейсами, которые *выглядят* так, как они будут взаимодействовать с базой данных. Однако во время тестирования можно заменить фиктивную реализацию, которая не будет обращаться к базе данных, а хранить данные в памяти. Эта фиктивная реализация будет изолировать код от несвязанных проблем в коде доступа к данным или конфигурации базы данных.

Существуют дополнительные преимущества изоляции. Вычисление бизнеса в последнем методе должно выполняться всего несколько миллисекунд, но сам тест может выполняться в течение нескольких секунд, так как код переключается по сети и обращается к различным серверам. Модульные тесты должны выполняться быстро, чтобы упростить небольшие изменения. Модульные тесты также должны быть повторяемыми и не завершатся, так как в компоненте, не связанном с тестом, возникла проблема. Написание кода, который легко наблюдать и изолировать, означает, что разработчики будут более простым написанием тестов для кода, тратить меньше времени на ожидание выполнения тестов и, что более важно, тратить меньше времени на отслеживание ошибок, которые не существуют.

Надеюсь, что вы можете оценить преимущества тестирования и понять, какие качества проверяются в коде. Мы будем обращаться к написанию кода, который работает с EF4, чтобы сохранить данные в базе данных, оставаясь видимой и легко изолированной, но сначала мы будем ограничивать наши усилия, чтобы обсудить тестируемые схемы для доступа к данным.

## <a name="design-patterns-for-data-persistence"></a>Шаблоны проектирования для сохраняемости данных

В обоих неверных примерах, приведенных выше, имелось слишком много обязанностей. Первому неверному примеру пришлось выполнить вычисление *и* записать в файл. Во втором неверном примере пришлось считывать данные из базы данных *и* выполнять бизнес-расчет *и* отправлять электронную почту. Разрабатывая небольшие методы, которые разделяют проблемы и делегируют ответственность другим компонентам, вы сделаете отличный шаг для написания тестируемого кода. Целью является создание функциональных возможностей путем составления действий из небольших и специализированных абстракций.

Когда дело доходит до сохранения данных, немалые и незначительные абстракции, которые мы будем искать, настолько распространены, что они были описаны как конструктивные шаблоны. Для описания этих шаблонов в выпуске использовалась первая работа с книгами по архитектуре корпоративных приложений Фаулер. Мы предоставим краткое описание этих шаблонов в следующих разделах, прежде чем мы покажем, как эти ADO.NET Entity Framework реализованы и работают с этими шаблонами.

### <a name="the-repository-pattern"></a>Шаблон репозитория

Фаулер говорит о том, что между уровнями домена и сопоставления данных в репозитории используется интерфейс, подобный коллекции, для доступа к объектам домена. Цель шаблона репозитория — изолировать код от минутиае доступа к данным, и как мы видели более раннюю изоляцию, является обязательной характеристикой для тестирования.

Ключом к изоляции является то, как репозиторий предоставляет объекты, используя интерфейс, подобный коллекции. Логика, которую вы пишете для использования в репозитории, не имеет представления о том, как репозиторий будет материализовать запрашиваемые объекты. Репозиторий может взаимодействовать с базой данных или просто возвращать объекты из коллекции в памяти. Весь код должен быть уверен в том, что репозиторий поддерживает коллекцию, и вы можете получать, добавлять и удалять объекты из коллекции.

В существующих приложениях .NET конкретный репозиторий часто наследуется от универсального интерфейса, подобного следующему:

``` csharp
    public interface IRepository<T> {       
        IEnumerable<T> FindAll();
        IEnumerable<T> FindBy(Expression<Func\<T, bool>> predicate);
        T FindById(int id);
        void Add(T newEntity);
        void Remove(T entity);
    }
```

Мы сделаем несколько изменений в определении интерфейса, когда мы предоставляем реализацию для EF4, но основная концепция остается неизменной. Код может использовать конкретный репозиторий, реализующий этот интерфейс, чтобы получить сущность по значению первичного ключа, получить коллекцию сущностей на основе вычисления предиката или просто получить все доступные сущности. Код также может добавлять и удалять сущности через интерфейс репозитория.

Учитывая IRepository объектов Employee, код может выполнять следующие операции.

``` csharp
    var employeesNamedScott =
        repository
            .FindBy(e => e.Name == "Scott")
            .OrderBy(e => e.HireDate);
    var firstEmployee = repository.FindById(1);
    var newEmployee = new Employee() {/*... */};
    repository.Add(newEmployee);
```

Поскольку код использует интерфейс (IRepository для Employee), мы можем предоставить код с различными реализациями интерфейса. Одна из реализаций может быть реализацией, поддерживаемой EF4, и сохранять объекты в базе данных Microsoft SQL Server. Другая реализация (используемая во время тестирования) может быть создана в виде списка объектов Employee в памяти. Интерфейс позволяет достичь изоляции в коде.

Обратите внимание, что &lt; интерфейс IRepository T &gt; не предоставляет операции сохранения. Как обновить существующие объекты? Вы можете использовать определения IRepository, которые включают операцию сохранения, и реализации этих репозиториев должны немедленно сохранить объект в базе данных. Однако во многих приложениях не нужно сохранять объекты по отдельности. Вместо этого мы хотим перенести объекты в жизнь, возможно, из разных репозиториев, изменить эти объекты как часть бизнес-деятельности, а затем сохранить все объекты в рамках одной атомарной операции. К счастью, существует шаблон, позволяющий использовать этот тип поведения.

### <a name="the-unit-of-work-pattern"></a>Шаблон единицы работы

Фаулер говорит, что единица работы будет поддерживать список объектов, затронутых бизнес-транзакцией, и координирует запись изменений и разрешение проблем параллелизма. Ответственность за отработку изменений объектов, переносимых в жизнь из репозитория, и сохранение изменений, внесенных в объекты при указании единицы работы для фиксации изменений, лежит за единицу работы. Кроме того, эта единица отвечает за то, чтобы новые объекты, добавленные во все репозитории, были вставлены в базу данных, а также операции удаления.

Если вы когда-либо работали с наборами данных ADO.NET, вы уже знакомы с шаблоном единицы работы. Наборы данных ADO.NET имели возможность отслеживании обновлений, удалений и вставки объектов DataRow и могли бы (с помощью TableAdapter) согласовать все наши изменения с базой. Однако объекты DataSet моделируют отключенное подмножество базовой базы данных. Шаблон единицы работы имеет такое же поведение, но работает с бизнес-объектами и объектами предметной области, изолированными от кода доступа к данным и не осведомленных о базе данных.

Абстракция для моделирования единицы работы в коде .NET может выглядеть следующим образом:

``` csharp
    public interface IUnitOfWork {
        IRepository<Employee> Employees { get; }
        IRepository<Order> Orders { get; }
        IRepository<Customer> Customers { get; }
        void Commit();
    }
```

Предоставляя ссылки на репозитории из единицы работы, можно гарантировать, что один объект единицы работы может следить за всеми сущностями, материализованными во время бизнес-транзакции. Реализация метода Commit для реальной единицы работы заключается в том, что все волшебные ситуации позволяют согласовать изменения в памяти с базой данных. 

При наличии ссылки на IUnitOfWork код может вносить изменения в бизнес-объекты, полученные из одного или нескольких репозиториев, и сохранять все изменения с помощью операции атомарной фиксации.

``` csharp
    var firstEmployee = unitofWork.Employees.FindById(1);
    var firstCustomer = unitofWork.Customers.FindById(1);
    firstEmployee.Name = "Alex";
    firstCustomer.Name = "Christopher";
    unitofWork.Commit();
```

### <a name="the-lazy-load-pattern"></a>Шаблон отложенной загрузки

Фаулер использует имя "Lazy Load" для описания "объекта, который не содержит все необходимые данные, но знает, как его получить". Прозрачная отложенная загрузка является важной функцией при написании тестируемого бизнес-кода и работе с реляционной базой данных. В качестве примера рассмотрим следующий код.

``` csharp
    var employee = repository.FindById(id);
    // ... and later ...
    foreach(var timeCard in employee.TimeCards) {
        // .. manipulate the timeCard
    }
```

Как заполняется коллекция Тимекардс? Есть два возможных ответа. Один из ответов заключается в том, что при запросе на получение сотрудника в репозитории сотрудников отправляется запрос для получения сотрудника вместе со сведениями о карте времени, связанными с сотрудниками. В реляционных базах данных это обычно требует запроса с предложением JOIN и может привести к извлечению дополнительных сведений, чем требуется приложению. Что делать, если приложению не нужно касаться свойства Тимекардс?

Вторым ответом является загрузка свойства Тимекардс "по требованию". Эта отложенная загрузка является неявной и прозрачной для бизнес-логики, так как код не вызывает специальные интерфейсы API для получения сведений о карте времени. В коде предполагается, что сведения о карте времени имеются при необходимости. Существует несколько волшебных усилий, связанных с отложенной загрузкой, которая обычно включает Перехват вызовов методов в среде выполнения. Перехват кода отвечает за общение с базой данных и получение сведений о карте времени, при этом бизнес-логика может быть бизнес-логикой. Этот инструмент «ленивая» загрузка позволяет бизнес-коду изолировать себя от операций извлечения данных и приводить к более тестируемому коду.

Недостатком отложенной нагрузки является то, что если приложению *требуется информация* о карте времени, код будет выполнять дополнительный запрос. Это не имеет значения для многих приложений, но для приложений с учетом производительности или приложений, выполняющих циклическое выполнение нескольких объектов Employee, и выполнения запроса для получения карт времени во время каждой итерации цикла (проблема, часто называемая проблемой запроса N + 1), отложенная загрузка — это перетаскивание. В этих сценариях приложение может захотеть заранее загрузить сведения о карте времени с максимально эффективным способом.

К счастью, мы увидим, как EF4 поддерживает неявные отложенные и эффективные загрузки, так как мы перейдем к следующему разделу и реализуем эти закономерности.

## <a name="implementing-patterns-with-the-entity-framework"></a>Реализация шаблонов с помощью Entity Framework

Хорошая новость состоит в том, что все шаблоны проектирования, описанные в последнем разделе, легко реализовать с помощью EF4. Чтобы продемонстрировать, что мы будем использовать простое ASP.NET приложение MVC для редактирования и показа сотрудников и связанных с ними сведений о времени. Начнем с использования следующих "простых старых объектов CLR" (POCO). 

``` csharp
    public class Employee {
        public int Id { get; set; }
        public string Name { get; set; }
        public DateTime HireDate { get; set; }
        public ICollection<TimeCard> TimeCards { get; set; }
    }

    public class TimeCard {
        public int Id { get; set; }
        public int Hours { get; set; }
        public DateTime EffectiveDate { get; set; }
    }
```

Эти определения классов немного изменяются, так как мы рассмотрим различные подходы и функции EF4, но цель заключается в том, чтобы эти классы всегда были как можно устойчивыми игнорирующих (PI). Объект PI не знает, *как*или даже *Если*состояние, которое он хранит, находится внутри базы данных. Устройства PI и POCO переходят в руки с тестируемым программным обеспечением. Объекты, использующие алгоритм POCO, менее ограничены, более гибкы и проще в тестировании, так как они могут работать без базы данных.

С помощью POCO можно создать EDM (EDM) в Visual Studio (см. рис. 1). Мы не будем использовать EDM для создания кода для наших сущностей. Вместо этого мы хотим использовать сущности, которые мы ловингли вручную. Мы будем использовать EDM только для создания нашей схемы базы данных и предоставления метаданных EF4, необходимых для отображения объектов в базе данных.

![EF test_01](~/ef6/media/eftest-01.jpg)

**Рис. 1**

Примечание. Если вы хотите сначала разработать модель EDM, можно создать чистый код POCO из EDM. Это можно сделать с помощью расширения Visual Studio 2010, предоставленного группой программирования данных. Чтобы скачать расширение, запустите Диспетчер расширений из меню "Сервис" в Visual Studio и выполните поиск в интерактивной коллекции шаблонов для "POCO" (см. рис. 2). Существует несколько шаблонов POCO, доступных для EF. Дополнительные сведения об использовании шаблона см. в разделе " [Пошаговое руководство. Шаблон POCO для Entity Framework](/archive/blogs/adonet/walkthrough-poco-template-for-the-entity-framework)".

![EF test_02](~/ef6/media/eftest-02.png)

**Рис. 2**

Начиная с этой начальной точки POCO мы рассмотрим два разных подхода к тестируемому коду. Первый подход вызывает подход EF, так как он использует абстракции из API Entity Framework для реализации единиц работы и репозиториев. Во втором подходе мы создадим собственные абстракции пользовательского репозитория, а затем увидим преимущества и недостатки каждого подхода. Начнем с изучения подхода EF.  

### <a name="an-ef-centric-implementation"></a>Реализация, ориентированная на EF

Рассмотрим следующее действие контроллера из проекта MVC ASP.NET. Действие извлекает объект Employee и возвращает результат для отображения подробного представления сотрудника.

``` csharp
    public ViewResult Details(int id) {
        var employee = _unitOfWork.Employees
                                  .Single(e => e.Id == id);
        return View(employee);
    }
```

Тестируется ли код? Существует по крайней мере два теста, которые необходимо проверить на поведении действия. Во-первых, мы хотим убедиться, что действие возвращает правильное представление — простой тест. Мы также хотим написать тест для проверки того, что действие получает правильного сотрудника, и нам бы хотелось сделать это без выполнения кода для запроса к базе данных. Помните, что мы хотим изолировать тестируемый код. Изоляция обеспечит сбой теста из-за ошибки в коде доступа к данным или конфигурации базы данных. Если тест завершается неудачно, мы будем осведомлены об ошибке в логике контроллера, а не на каком-либо системном компоненте более низкого уровня.

Для достижения изоляции нам потребуются некоторые абстракции, такие как интерфейсы, представленные ранее для репозиториев и единиц работы. Помните, что шаблон репозитория предназначен для исправлять между объектами домена и уровнем сопоставления данных. В этом сценарии EF4 *является* слоем сопоставления данных и уже предоставляет абстракцию, похожую на репозиторий с именем иобжектсет &lt; T &gt; (из пространства имен System. Data. Objects). Определение интерфейса выглядит следующим образом.

``` csharp
    public interface IObjectSet<TEntity> :
                     IQueryable<TEntity>,
                     IEnumerable<TEntity>,
                     IQueryable,
                     IEnumerable
                     where TEntity : class
    {
        void AddObject(TEntity entity);
        void Attach(TEntity entity);
        void DeleteObject(TEntity entity);
        void Detach(TEntity entity);
    }
```

Иобжектсет &lt; T &gt; соответствует требованиям к репозиторию, так как он напоминает коллекцию объектов (через IEnumerable &lt; T &gt; ) и предоставляет методы для добавления и удаления объектов из имитации коллекции. Методы Attach и Detach предоставляют дополнительные возможности API EF4. Чтобы использовать Иобжектсет &lt; T в &gt; качестве интерфейса для репозиториев, нам нужна абстракция единиц работы для привязки репозиториев вместе.

``` csharp
    public interface IUnitOfWork {
        IObjectSet<Employee> Employees { get; }
        IObjectSet<TimeCard> TimeCards { get; }
        void Commit();
    }
```

Одна конкретная реализация этого интерфейса будет обсуждаться с SQL Server и проста в создании с помощью класса ObjectContext из EF4. Класс ObjectContext — это реальная единица работы в API EF4.

``` csharp
    public class SqlUnitOfWork : IUnitOfWork {
        public SqlUnitOfWork() {
            var connectionString =
                ConfigurationManager
                    .ConnectionStrings[ConnectionStringName]
                    .ConnectionString;
            _context = new ObjectContext(connectionString);
        }

        public IObjectSet<Employee> Employees {
            get { return _context.CreateObjectSet<Employee>(); }
        }

        public IObjectSet<TimeCard> TimeCards {
            get { return _context.CreateObjectSet<TimeCard>(); }
        }

        public void Commit() {
            _context.SaveChanges();
        }

        readonly ObjectContext _context;
        const string ConnectionStringName = "EmployeeDataModelContainer";
    }
```

Перевод Иобжектсет &lt; T &gt; в жизнь — это так же просто, как вызов метода CreateObject объекта ObjectContext. В фоновом режиме платформа будет использовать метаданные, предоставленные в EDM, для создания конкретного объекта &lt; T &gt; . Мы будем возвращать &lt; интерфейс иобжектсет T, &gt; так как он поможет сохранить пригодность для тестирования в клиентском коде.

Эта конкретная реализация полезна в рабочей среде, но нам нужно сосредоточиться на том, как мы будем использовать нашу абстракцию IUnitOfWork для упрощения тестирования.

### <a name="the-test-doubles"></a>Двойная проверка

Чтобы изолировать действие контроллера, потребуется возможность переключения между реальными единицами работы (с помощью ObjectContext) и тестовой двойной или «фиктивной» единицей работы (выполнение операций в памяти). Распространенный подход к выполнению этого типа переключения заключается в том, чтобы не допустить создания экземпляром блока работы контроллером MVC, а передать единицу работы в контроллер в качестве параметра конструктора.

``` csharp
    class EmployeeController : Controller {
      publicEmployeeController(IUnitOfWork unitOfWork)  {
          _unitOfWork = unitOfWork;
      }
      ...
    }
```

Приведенный выше код является примером внедрения зависимостей. Мы не разрешают контроллеру создать зависимость (единицу работы), а затем внедрить зависимость в контроллер. В проекте MVC обычно используется настраиваемая фабрика контроллеров в сочетании с контейнером инверсии управления (IoC) для автоматизации внедрения зависимостей. Эти разделы выходят за рамки этой статьи, но дополнительные сведения можно получить, выполнив ссылки в конце этой статьи.

Поддельная реализация блока работы, которую можно использовать для тестирования, может выглядеть следующим образом.

``` csharp
    public class InMemoryUnitOfWork : IUnitOfWork {
        public InMemoryUnitOfWork() {
            Committed = false;
        }
        public IObjectSet<Employee> Employees {
            get;
            set;
        }

        public IObjectSet<TimeCard> TimeCards {
            get;
            set;
        }

        public bool Committed { get; set; }
        public void Commit() {
            Committed = true;
        }
    }
```

Обратите внимание, что поддельная единица работы предоставляет зафиксированное свойство. Иногда бывает полезно добавить компоненты в имитацию класса, который упрощает тестирование. В этом случае можно легко определить, фиксирует ли код единицу работы, проверив зафиксированное свойство.

Также потребуется имитировать Иобжектсет &lt; T &gt; для хранения объектов Employee и табели в памяти. Мы можем предоставить единую реализацию, используя универсальные шаблоны.

``` csharp
    public class InMemoryObjectSet<T> : IObjectSet<T> where T : class
        public InMemoryObjectSet()
            : this(Enumerable.Empty<T>()) {
        }
        public InMemoryObjectSet(IEnumerable<T> entities) {
            _set = new HashSet<T>();
            foreach (var entity in entities) {
                _set.Add(entity);
            }
            _queryableSet = _set.AsQueryable();
        }
        public void AddObject(T entity) {
            _set.Add(entity);
        }
        public void Attach(T entity) {
            _set.Add(entity);
        }
        public void DeleteObject(T entity) {
            _set.Remove(entity);
        }
        public void Detach(T entity) {
            _set.Remove(entity);
        }
        public Type ElementType {
            get { return _queryableSet.ElementType; }
        }
        public Expression Expression {
            get { return _queryableSet.Expression; }
        }
        public IQueryProvider Provider {
            get { return _queryableSet.Provider; }
        }
        public IEnumerator<T> GetEnumerator() {
            return _set.GetEnumerator();
        }
        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        readonly HashSet<T> _set;
        readonly IQueryable<T> _queryableSet;
    }
```

Этот тест дважды делегирует большую часть своей работы базовому объекту-набору hash &lt; T &gt; . Обратите внимание, что для Иобжектсет &lt; t &gt; требуется универсальное ограничение, обеспечивающее применение t в качестве класса (ссылочный тип), а также заставляет нас реализовать IQueryable &lt; T &gt; . Можно легко создать в памяти коллекцию IQueryable &lt; T &gt; с помощью стандартного оператора LINQ аскуерябле.

### <a name="the-tests"></a>Тесты

Традиционные модульные тесты будут использовать один тестовый класс для хранения всех тестов для всех действий в одном контроллере MVC. Можно написать эти тесты или любой тип модульного теста с помощью поддельных подразделений памяти, которые мы создали. Тем не менее, в этой статье мы будем избегать подхода монолитного тестового класса, а вместо этого сгруппировать наши тесты, чтобы сосредоточиться на определенной части функциональности.Например, «создание нового сотрудника» — это функция, которую мы хотим протестировать, поэтому мы будем использовать один тестовый класс для проверки действия одного контроллера, ответственного за создание нового сотрудника.

Для всех этих детализированных тестовых классов необходимо выполнить некоторые распространенные коды настройки. Например, нам всегда нужно создавать репозитории в памяти и поддельную единицу работы. Кроме того, необходим экземпляр контроллера сотрудника с поддельной единицей работы. Мы будем использовать этот распространенный код настройки в тестовых классах с помощью базового класса.

``` csharp
    public class EmployeeControllerTestBase {
        public EmployeeControllerTestBase() {
            _employeeData = EmployeeObjectMother.CreateEmployees()
                                                .ToList();
            _repository = new InMemoryObjectSet<Employee>(_employeeData);
            _unitOfWork = new InMemoryUnitOfWork();
            _unitOfWork.Employees = _repository;
            _controller = new EmployeeController(_unitOfWork);
        }

        protected IList<Employee> _employeeData;
        protected EmployeeController _controller;
        protected InMemoryObjectSet<Employee> _repository;
        protected InMemoryUnitOfWork _unitOfWork;
    }
```

Объект «мама», используемый в базовом классе, является одним из распространенных шаблонов для создания тестовых данных. Объект матери содержит заводские методы для создания экземпляров тестовых сущностей для использования в нескольких тестовых средствах тестирования.

``` csharp
    public static class EmployeeObjectMother {
        public static IEnumerable<Employee> CreateEmployees() {
            yield return new Employee() {
                Id = 1, Name = "Scott", HireDate=new DateTime(2002, 1, 1)
            };
            yield return new Employee() {
                Id = 2, Name = "Poonam", HireDate=new DateTime(2001, 1, 1)
            };
            yield return new Employee() {
                Id = 3, Name = "Simon", HireDate=new DateTime(2008, 1, 1)
            };
        }
        // ... more fake data for different scenarios
    }
```

Мы можем использовать Емплойиконтроллертестбасе в качестве базового класса для ряда тестовой основы (см. рис. 3). Каждый тестовый набор будет проверять конкретное действие контроллера. Например, одно средство тестирования будет сосредоточиться на тестировании действия Create, используемого во время запроса HTTP GET (для отображения представления для создания сотрудника), а другое средство будет сосредоточиться на действии Create, используемом в запросе HTTP POST (чтобы получить сведения, отправленные пользователем для создания сотрудника). Каждый производный класс несет ответственность за установку, необходимую в конкретном контексте, и на предоставление утверждений, необходимых для проверки результатов для конкретного контекста теста.

![EF test_03](~/ef6/media/eftest-03.png)

**Рис. 3**

Соглашение об именовании и стиль теста, представленные здесь, не требуются для тестируемого кода — это лишь один из подходов. На рис. 4 показаны тесты, выполняемые в подключаемом модуле средства выполнения тестов нервной для Visual Studio 2010.

![EF test_04](~/ef6/media/eftest-04.png)

**Рис. 4**

При использовании базового класса для работы с общим кодом настройки модульные тесты для каждого действия контроллера являются небольшими и легко написанными. Тесты будут выполняться быстро (так как мы выполняем операции в памяти) и не должны завершаться сбоем из-за несвязанных инфраструктур или проблем с окружающей средой (так как мы разработали тестируемую единицу).

``` csharp
    [TestClass]
    public class EmployeeControllerCreateActionPostTests
               : EmployeeControllerTestBase {
        [TestMethod]
        public void ShouldAddNewEmployeeToRepository() {
            _controller.Create(_newEmployee);
            Assert.IsTrue(_repository.Contains(_newEmployee));
        }
        [TestMethod]
        public void ShouldCommitUnitOfWork() {
            _controller.Create(_newEmployee);
            Assert.IsTrue(_unitOfWork.Committed);
        }
        // ... more tests

        Employee _newEmployee = new Employee() {
            Name = "NEW EMPLOYEE",
            HireDate = new System.DateTime(2010, 1, 1)
        };
    }
```

В этих тестах базовый класс выполняет большую часть работы по установке. Помните, что конструктор базового класса создает репозиторий в памяти, поддельную единицу работы и экземпляр класса Емплойиконтроллер. Тестовый класс является производным от этого базового класса и посвящен конкретным методам тестирования метода Create. В этом случае особенности сводится к этапам "организовать", "действовать" и "утверждение", которые вы увидите в любой процедуре модульного тестирования:

-   Создайте объект newEmployee для имитации входящих данных.
-   Вызовите действие Create объекта Емплойиконтроллер и передайте newEmployee.
-   Убедитесь, что действие Create выдает ожидаемые результаты (сотрудник отображается в репозитории).

Созданная нами возможность протестировать любые действия Емплойиконтроллер. Например, при написании тестов для действия индекса контроллера сотрудника можно наследовать от базового класса Test, чтобы установить ту же основную настройку для наших тестов. В этом случае базовый класс создаст репозиторий в памяти, поддельную единицу работы и экземпляр Емплойиконтроллер. Тесты для действия с индексом должны сосредоточиться только на вызове действия индекса и проверке качеств модели, возвращаемой действием.

``` csharp
    [TestClass]
    public class EmployeeControllerIndexActionTests
               : EmployeeControllerTestBase {
        [TestMethod]
        public void ShouldBuildModelWithAllEmployees() {
            var result = _controller.Index();
            var model = result.ViewData.Model
                          as IEnumerable<Employee>;
            Assert.IsTrue(model.Count() == _employeeData.Count);
        }
        [TestMethod]
        public void ShouldOrderModelByHiredateAscending() {
            var result = _controller.Index();
            var model = result.ViewData.Model
                         as IEnumerable<Employee>;
            Assert.IsTrue(model.SequenceEqual(
                           _employeeData.OrderBy(e => e.HireDate)));
        }
        // ...
    }
```

Тесты, создаваемые с помощью имитаций в памяти, ориентированы на тестирование *состояния* программного обеспечения. Например, при тестировании действия Create, которое мы хотим проверить состояние репозитория после выполнения действия Create, — сохраняет ли репозиторий новый сотрудник?

``` csharp
    [TestMethod]
    public void ShouldAddNewEmployeeToRepository() {
        _controller.Create(_newEmployee);
        Assert.IsTrue(_repository.Contains(_newEmployee));
    }
```

Далее мы рассмотрим тестирование на основе взаимодействия. Тестирование на основе взаимодействия попросит вас, если тестируемый код вызвал правильные методы наших объектов и передал правильные параметры. Сейчас мы будем переноситься на обложку другого шаблона разработки — отложенная загрузка.

## <a name="eager-loading-and-lazy-loading"></a>Упреждающая загрузка и отложенная загрузка

В некоторый момент в веб-приложении ASP.NET MVC может потребоваться отобразить сведения о сотруднике и включить связанные с ним карты времени. Например, у нас может быть отображение сводки по времени, в котором отображается имя сотрудника и общее количество карт времени в системе. Для реализации этой функции можно применить несколько подходов.

### <a name="projection"></a>Проекция

Одним из простых подходов к созданию сводки является создание модели, выделенной для информации, которую нужно отобразить в представлении. В этом сценарии модель может выглядеть следующим образом.

``` csharp
    public class EmployeeSummaryViewModel {
        public string Name { get; set; }
        public int TotalTimeCards { get; set; }
    }
```

Обратите внимание, что Емплойисуммаривиевмодел не является сущностью, иными словами, это не то, что мы хотим сохранить в базе данных. Мы будем использовать этот класс для случайного перебора данных в представление строго типизированным способом. Модель представления похожа на объект передачи данных (DTO), так как он не содержит методов поведения (нет) — только свойств. Эти свойства будут содержать данные, которые необходимо переместить. Создать эту модель представления легко с помощью стандартного оператора проекции LINQ — оператора SELECT.

``` csharp
    public ViewResult Summary(int id) {
        var model = _unitOfWork.Employees
                               .Where(e => e.Id == id)
                               .Select(e => new EmployeeSummaryViewModel
                                  {
                                    Name = e.Name,
                                    TotalTimeCards = e.TimeCards.Count()
                                  })
                               .Single();
        return View(model);
    }
```

Приведенный выше код имеет две важные функции. Во-первых, код легко тестировать, так как его легко наблюдать и изолировать. Оператор SELECT работает так же, как и для поддельных в памяти подразделений, как и для реальной единицы работы.

``` csharp
    [TestClass]
    public class EmployeeControllerSummaryActionTests
               : EmployeeControllerTestBase {
        [TestMethod]
        public void ShouldBuildModelWithCorrectEmployeeSummary() {
            var id = 1;
            var result = _controller.Summary(id);
            var model = result.ViewData.Model as EmployeeSummaryViewModel;
            Assert.IsTrue(model.TotalTimeCards == 3);
        }
        // ...
    }
```

Вторая существенная особенность заключается в том, как код позволяет EF4 создавать единый, эффективный запрос для совместного сбора информации о сотрудниках и карточках времени. Мы загрузили сведения о сотрудниках и сведения о карте времени в один объект без использования каких-либо специальных API. Код просто выражает информацию, которую он требует, с помощью стандартных операторов LINQ, работающих с источниками данных в памяти, а также с удаленными источниками данных. EF4 удалось преобразовать деревья выражений, созданные запросом LINQ и компилятором C, \# в единый и эффективный запрос T-SQL.

``` SQL
    SELECT
    [Limit1].[Id] AS [Id],
    [Limit1].[Name] AS [Name],
    [Limit1].[C1] AS [C1]
    FROM (SELECT TOP (2)
      [Project1].[Id] AS [Id],
      [Project1].[Name] AS [Name],
      [Project1].[C1] AS [C1]
      FROM (SELECT
        [Extent1].[Id] AS [Id],
        [Extent1].[Name] AS [Name],
        (SELECT COUNT(1) AS [A1]
         FROM [dbo].[TimeCards] AS [Extent2]
         WHERE [Extent1].[Id] =
               [Extent2].[EmployeeTimeCard_TimeCard_Id]) AS [C1]
              FROM [dbo].[Employees] AS [Extent1]
               WHERE [Extent1].[Id] = @p__linq__0
         )  AS [Project1]
    )  AS [Limit1]
```

Существуют и другие случаи, когда нам не нужно работать с моделью представления или объектом DTO, но с реальными сущностями. Когда нам известно, что нам нужен сотрудник *и* карты времени сотрудника, мы можем заранее загрузить связанные данные с помощью ненавязчивого и эффективного способа.

### <a name="explicit-eager-loading"></a>Явная упреждающая загрузка

Когда мы хотим заранее загрузить связанные сведения о сущности, требуется некоторый механизм для бизнес-логики (или в этом сценарии — логика действия контроллера), чтобы выразить свое желание в репозитории. Класс EF4 ObjectQuery &lt; T &gt; определяет метод Include, указывающий связанные объекты для извлечения во время выполнения запроса. Помните, что EF4 ObjectContext предоставляет сущности через конкретный класс объекта Objecting &lt; t &gt; , который наследует от ObjectQuery &lt; T &gt; .Если мы использовали ссылки Objects &lt; T &gt; в нашем действии контроллера, можно написать следующий код, чтобы указать безотлагательную загрузку сведений о карте времени для каждого сотрудника.

``` csharp
    _employees.Include("TimeCards")
              .Where(e => e.HireDate.Year > 2009);
```

Однако, поскольку мы пытаемся протестировать наш код, мы не предоставляем доступ к набору объектов &lt; T &gt; извне класса реальных единиц работы. Вместо этого мы полагаетесь на &lt; интерфейс иобжектсет T &gt; , который проще имитировать, но иобжектсет &lt; T не &gt; определяет метод Include. Прелесть LINQ заключается в том, что мы можем создать собственный оператор include.

``` csharp
    public static class QueryableExtensions {
        public static IQueryable<T> Include<T>
                (this IQueryable<T> sequence, string path) {
            var objectQuery = sequence as ObjectQuery<T>;
            if(objectQuery != null)
            {
                return objectQuery.Include(path);
            }
            return sequence;
        }
    }
```

Обратите внимание, что этот оператор include определен как метод расширения для IQueryable &lt; t &gt; вместо иобжектсет &lt; t &gt; . Это дает нам возможность использовать метод с более широким диапазоном возможных типов, включая IQueryable &lt; t &gt; , иобжектсет &lt; t &gt; , ObjectQuery &lt; t &gt; и набор объектов &lt; t &gt; . В случае, если базовая последовательность не является подлинной EF4 ObjectQuery &lt; T &gt; , то нет никаких вредов, а оператор include — это No-Op. Если базовая последовательность *является* ObjectQuery &lt; T &gt; (или производной от ObjectQuery &lt; T &gt; ), то EF4 будет видеть наше требование для дополнительных данных и сформулировать правильный SQL-запрос.

С помощью этого нового оператора можно явным образом запросить неподготовленную загрузку сведений о карте времени из репозитория.

``` csharp
    public ViewResult Index() {
        var model = _unitOfWork.Employees
                               .Include("TimeCards")
                               .OrderBy(e => e.HireDate);
        return View(model);
    }
```

При выполнении с реальным контекстом ObjectContext код создает следующий отдельный запрос. Запрос собирает достаточно информации из базы данных за один проход для материализации объектов Employee и полностью заполняет их свойство Тимекардс.

``` SQL
    SELECT
    [Project1].[Id] AS [Id],
    [Project1].[Name] AS [Name],
    [Project1].[HireDate] AS [HireDate],
    [Project1].[C1] AS [C1],
    [Project1].[Id1] AS [Id1],
    [Project1].[Hours] AS [Hours],
    [Project1].[EffectiveDate] AS [EffectiveDate],
    [Project1].[EmployeeTimeCard_TimeCard_Id] AS [EmployeeTimeCard_TimeCard_Id]
    FROM ( SELECT
         [Extent1].[Id] AS [Id],
         [Extent1].[Name] AS [Name],
         [Extent1].[HireDate] AS [HireDate],
         [Extent2].[Id] AS [Id1],
         [Extent2].[Hours] AS [Hours],
         [Extent2].[EffectiveDate] AS [EffectiveDate],
         [Extent2].[EmployeeTimeCard_TimeCard_Id] AS
                    [EmployeeTimeCard_TimeCard_Id],
         CASE WHEN ([Extent2].[Id] IS NULL) THEN CAST(NULL AS int)
         ELSE 1 END AS [C1]
         FROM  [dbo].[Employees] AS [Extent1]
         LEFT OUTER JOIN [dbo].[TimeCards] AS [Extent2] ON [Extent1].[Id] = [Extent2].[EmployeeTimeCard_TimeCard_Id]
    )  AS [Project1]
    ORDER BY [Project1].[HireDate] ASC,
             [Project1].[Id] ASC, [Project1].[C1] ASC
```

Отличная новость — код внутри метода действия остается полностью тестируемым. Для поддержки оператора include не нужно предоставлять дополнительные функции для наших имитаций. Неплохая новость заключается в том, чтобы использовать оператор include внутри кода, который нам нужен для сохранения игнорирующих. Это простой пример типа компромиссов, которые необходимо оценить при создании тестируемого кода. Бывают случаи, когда необходимо разрешить устойчивую утечку данных вне абстракции репозитория, чтобы удовлетворить цели производительности.

Альтернативой безотлагательной загрузке является отложенная загрузка. Отложенная загрузка означает, что наш бизнес-код *не* должен явно объявлять требование для связанных данных. Вместо этого мы используем наши сущности в приложении и, если требуются дополнительные данные, Entity Framework загрузит данные по запросу.

### <a name="lazy-loading"></a>Отложенная загрузка

Вы можете легко представить себе ситуацию, когда нам неизвестно, какие данные потребуются для части бизнес-логики. Нам может быть известно, что логике требуется объект Employee, но мы можем выполнить ветвление по разным путям выполнения, в которых некоторые из этих путей требуют от сотрудника сведения о карте времени, а некоторые — нет. Такие сценарии идеально подходят для неявной отложенной загрузки, так как данные прекрасно отображаются по мере необходимости.

Отложенная загрузка, также известная как отложенная загрузка, замещает некоторые требования к объектам сущности. POCO с истинным игнорированияом сохраняемости не повлияет ни на какие требования с уровня сохраняемости, но истинность игнорирования сохранения практически невозможна.Вместо этого мы измеряем игнорирования сохраняемости в относительном градусах. Это было бы неудачно, если бы нам пришлось наследовать от базового класса, ориентированного на сохраняемость, или использовать специализированную коллекцию для реализации отложенной загрузки в POCO. К счастью, EF4 имеет менее агрессивное решение.

### <a name="virtually-undetectable"></a>Практически необнаруживаемые

При использовании объектов POCO EF4 может динамически создавать прокси-серверы среды выполнения для сущностей. Эти прокси незаметно для упаковки материализованных POCO и предоставляют дополнительные службы путем перехвата каждой операции получения и установки свойства для выполнения дополнительной работы. Одна из таких услуг — это функция отложенной загрузки, которую мы ищем. Другая служба является эффективным механизмом отслеживания изменений, который может записывать, когда программа изменяет значения свойств сущности. Список изменений используется контекстом ObjectContext во время метода SaveChanges для сохранения измененных сущностей с помощью команд UPDATE.

Однако для работы этих прокси-серверов требуется способ подключения к операциям get и Set в отношении сущности, а прокси для достижения этой цели — переопределения виртуальных членов. Таким образом, если требуется неявная отложенная загрузка и эффективное отслеживание изменений, нам нужно вернуться к нашим определениям классов POCO и пометить свойства как виртуальные.

``` csharp
    public class Employee {
        public virtual int Id { get; set; }
        public virtual string Name { get; set; }
        public virtual DateTime HireDate { get; set; }
        public virtual ICollection<TimeCard> TimeCards { get; set; }
    }
```

Мы по-прежнему можем сказать, что сущность сотрудника в основном является сохраняемостью игнорирующих. Единственным требованием является использование виртуальных членов, и это не влияет на тестируемость кода. Не нужно создавать производный от какого-либо специального базового класса или даже использовать специальную коллекцию, выделенную для отложенной загрузки. Как показано в коде, любой класс, реализующий ICollection &lt; T, &gt; доступен для хранения связанных сущностей.

Существует также одно небольшое изменение, которое необходимо сделать в нашей единице работы. Отложенная загрузка *отключена* по умолчанию при работе непосредственно с объектом ObjectContext. Существует свойство, которое можно задать для свойства Контекстоптионс, чтобы включить отложенную загрузку, и мы можем установить это свойство в реальной единице работы, если мы хотим включить отложенную загрузку везде.

``` csharp
    public class SqlUnitOfWork : IUnitOfWork {
         public SqlUnitOfWork() {
             // ...
             _context = new ObjectContext(connectionString);
             _context.ContextOptions.LazyLoadingEnabled = true;
         }    
         // ...
     }
```

Если включена неявная отложенная загрузка, код приложения может использовать сотрудника и связанные с ним карты времени, в то время как оставшиеся счастливом неведении не знают о работе, необходимой EF для загрузки дополнительных данных.

``` csharp
    var employee = _unitOfWork.Employees
                              .Single(e => e.Id == id);
    foreach (var card in employee.TimeCards) {
        // ...
    }
```

Отложенная загрузка упрощает написание кода приложения, а с помощью прокси-сервера код остается полностью тестируемым. Поддельные единицы работы в памяти позволяют просто предварительно загружать фиктивные сущности со связанными данными при необходимости во время тестирования.

На этом этапе мы сделаем наш контроль над созданием репозиториев с помощью Иобжектсет &lt; T &gt; и взглянем на абстракции, чтобы скрыть все знаки инфраструктуры сохраняемости.

## <a name="custom-repositories"></a>Пользовательские репозитории

Когда мы впервые предоставили шаблон проектирования единиц работы в этой статье, мы предоставляли пример кода для того, как может выглядеть единица работы. Восстановите эту исходную идею с помощью сценария рабочего времени сотрудника и сотрудника, с которым мы работаем.

``` csharp
    public interface IUnitOfWork {
        IRepository<Employee> Employees { get; }
        IRepository<TimeCard> TimeCards { get;  }
        void Commit();
    }
```

Основное различие между этой единицей работы и единицей работы, созданным в последнем разделе, заключается в том, как эта единица работы не использует абстракции из EF4 Framework (нет Иобжектсет &lt; T &gt; ). Иобжектсет &lt; T &gt; хорошо работает как интерфейс репозитория, но предоставляемый им API может быть не вполне согласован с потребностями нашего приложения. В этом предстоящем подходе мы будем представлять репозитории с помощью пользовательской &lt; &gt; абстракции IRepository T.

Многие разработчики, которые следуют проектированию на основе тестирования, проектированию на основе поведения и методологии, ориентированные на работу с доменами, предпочитают &lt; подход IRepository T &gt; по нескольким причинам. Во-первых, &lt; интерфейс IRepository T &gt; представляет уровень защиты от повреждений. Как описано в руководстве по созданию и Эванс в своей книге разработки, основанной на домене, уровень защиты от вредоносных программ удерживает ваш код домена от API-интерфейсов инфраструктуры, таких как API сохраняемости. Во-вторых, разработчики могут создавать в репозитории методы, соответствующие точным потребностям приложения (как было обнаружено при написании тестов). Например, нам часто приходится искать одну сущность, используя значение идентификатора, поэтому мы можем добавить метод Финдбид в интерфейс репозитория.Определение нашего IRepository &lt; T &gt; будет выглядеть следующим образом.

``` csharp
    public interface IRepository<T>
                    where T : class, IEntity {
        IQueryable<T> FindAll();
        IQueryable<T> FindWhere(Expression<Func\<T, bool>> predicate);
        T FindById(int id);       
        void Add(T newEntity);
        void Remove(T entity);
    }
```

Обратите внимание, что мы вернемся к использованию &lt; интерфейса IQueryable T &gt; для предоставления коллекций сущностей. IQueryable &lt; T &gt; позволяет деревьям выражений LINQ передаваться поставщику EF4 и предоставлять поставщику целостное представление запроса. Второй вариант — возврат IEnumerable &lt; T &gt; , что означает, что поставщик EF4 LINQ будет видеть только выражения, встроенные в репозиторий. Группирование, упорядочивание и проекция, выполненные за пределами репозитория, не будут содержаться в команде SQL, отправленной в базу данных, что может понизить производительность. С другой стороны, репозиторий, возвращающий только &lt; результаты IEnumerable T, &gt; никогда не поудивит вас с новой командой SQL. Оба подхода будут работать, и оба подхода останутся тестируемыми.

Очень просто предоставить единую реализацию &lt; интерфейса IRepository T, &gt; используя универсальные шаблоны и интерфейс API EF4 ObjectContext.

``` csharp
    public class SqlRepository<T> : IRepository<T>
                                    where T : class, IEntity {
        public SqlRepository(ObjectContext context) {
            _objectSet = context.CreateObjectSet<T>();
        }
        public IQueryable<T> FindAll() {
            return _objectSet;
        }
        public IQueryable<T> FindWhere(
                               Expression<Func\<T, bool>> predicate) {
            return _objectSet.Where(predicate);
        }
        public T FindById(int id) {
            return _objectSet.Single(o => o.Id == id);
        }
        public void Add(T newEntity) {
            _objectSet.AddObject(newEntity);
        }
        public void Remove(T entity) {
            _objectSet.DeleteObject(entity);
        }
        protected ObjectSet<T> _objectSet;
    }
```

Подход IRepository &lt; T &gt; предоставляет нам дополнительный контроль над нашими запросами, так как клиент должен вызвать метод для получения сущности. Внутри метода можно предоставить дополнительные проверки и операторы LINQ для применения ограничений приложения. Обратите внимание, что интерфейс имеет два ограничения для параметра универсального типа. Первое ограничение — это класс таинт &lt; , необходимый для объекта T &gt; , а второе ограничение заставляет наши сущности реализовать иентити — абстракцию, созданную для приложения. Интерфейс Иентити заставляет сущности иметь доступное для чтения свойство идентификатора, а затем это свойство можно использовать в методе Финдбид. Иентити определяется с помощью следующего кода.

``` csharp
    public interface IEntity {
        int Id { get; }
    }
```

Иентити можно считать небольшим нарушением игнорирования сохраняемости, так как наши сущности должны реализовать этот интерфейс. Помните, что игнорирования сохраняемости имеет отношение к компромиссам, а многие функции Финдбид перевешивают ограничение, наложенное интерфейсом. Интерфейс не влияет на пригодность для тестирования.

Для создания экземпляра Live IRepository &lt; T &gt; требуется EF4 ObjectContext, поэтому конкретная реализация единиц работы должна управлять созданием экземпляра.

``` csharp
    public class SqlUnitOfWork : IUnitOfWork {
        public SqlUnitOfWork() {
            var connectionString =
                ConfigurationManager
                    .ConnectionStrings[ConnectionStringName]
                    .ConnectionString;

            _context = new ObjectContext(connectionString);
            _context.ContextOptions.LazyLoadingEnabled = true;
        }

        public IRepository<Employee> Employees {
            get {
                if (_employees == null) {
                    _employees = new SqlRepository<Employee>(_context);
                }
                return _employees;
            }
        }

        public IRepository<TimeCard> TimeCards {
            get {
                if (_timeCards == null) {
                    _timeCards = new SqlRepository<TimeCard>(_context);
                }
                return _timeCards;
            }
        }

        public void Commit() {
            _context.SaveChanges();
        }

        SqlRepository<Employee> _employees = null;
        SqlRepository<TimeCard> _timeCards = null;
        readonly ObjectContext _context;
        const string ConnectionStringName = "EmployeeDataModelContainer";
    }
```

### <a name="using-the-custom-repository"></a>Использование пользовательского репозитория

Использование нашего пользовательского репозитория незначительно отличается от использования репозитория на основе Иобжектсет &lt; T &gt; . Вместо применения операторов LINQ непосредственно к свойству сначала необходимо вызвать один из методов репозитория, чтобы получить &lt; &gt; ссылку на IQueryable T.

``` csharp
    public ViewResult Index() {
        var model = _repository.FindAll()
                               .Include("TimeCards")
                               .OrderBy(e => e.HireDate);
        return View(model);
    }
```

Обратите внимание, что ранее реализованный оператор include будет работать без изменений. Метод Финдбид репозитория удаляет повторяющуюся логику из действий, пытающихся получить одну сущность.

``` csharp
    public ViewResult Details(int id) {
        var model = _repository.FindById(id);
        return View(model);
    }
```

Мы не имеем существенных различий в тестировании двух подходов, которые мы рассматривали. Мы могли бы предоставить фиктивные реализации IRepository &lt; T &gt; , создав конкретные классы, поддерживающие «сотрудники-набор», точно так же, &lt; &gt; как и в последнем разделе. Однако некоторые разработчики предпочитают использовать макеты объектов и макеты объектных платформ вместо создания фиктивных. Мы рассмотрим использование макетов для тестирования нашей реализации и обсуждение различий между макетами и подложными в следующем разделе.

### <a name="testing-with-mocks"></a>Тестирование с помощью макетов

Существует несколько подходов к созданию того, что Мартен Фаулер вызывает "Test Double". Тестовый двойной (например, ролик стунт Double) — это объект, который вы создаете для реальных, рабочих объектов во время тестов. Создаваемые нами репозитории в памяти — это тестовые Double для репозиториев, которые говорят SQL Server. Мы рассмотрели, как использовать эти тестовые-Double во время модульных тестов для изоляции кода и быстрого выполнения тестов.

Создаваемые двойные числа тестов имеют реальную и рабочую реализацию. В фоновом режиме каждый из них хранит конкретную коллекцию объектов, и они будут добавлять и удалять объекты из этой коллекции по мере работы с репозиторием во время теста. Некоторые разработчики, например, могут создавать свои тестовые двойные значения таким образом, с реальным кодом и рабочими реализациями.Эти тестовые удвоения — это то, что мы вызываем *поддельные*объекты. У них есть рабочие реализации, но они не настолько актуальны для использования в рабочей среде. Фиктивный репозиторий на самом деле не выполняет запись в базу данных. Фальшивый SMTP-сервер на самом деле не отправляет электронное сообщение по сети.

### <a name="mocks-versus-fakes"></a>Макеты и имитации

Существует другой тип теста, который дважды известен как *Макет*. Хотя имитации имеют рабочие реализации, макеты поставляются без реализации. С помощью макетной платформы объектов мы создаем эти макеты объектов во время выполнения и используем их в качестве тестовых значений Double. В этом разделе будет использоваться инфраструктура макетирования с открытым исходным кодом MOQ. Ниже приведен простой пример использования MOQ для динамического создания тестового типа Double для репозитория сотрудников.

``` csharp
    Mock<IRepository<Employee>> mock =
        new Mock<IRepository<Employee>>();
    IRepository<Employee> repository = mock.Object;
    repository.Add(new Employee());
    var employee = repository.FindById(1);
```

Мы задаем MOQ для &lt; реализации IRepository Employee &gt; , и она создает ее динамически. Чтобы получить объект, реализующий IRepository &lt; Employee &gt; , можно обратиться к свойству объекта фиктивного &lt; &gt; объекта T. Это внутренний объект, который мы можем передать в контроллеры, и они не будут уверены, что это тестовый двойной или реальный репозиторий. Мы можем вызывать методы для объекта точно так же, как мы бы вызывали методы для объекта с реальной реализацией.

Необходимо знать, что делает макет репозитория при вызове метода Add. Поскольку нет реализации, основанной на макете объекта, Add не выполняет никаких действий. Не существует какой-то конкретной коллекции, как в случае с имитацией, которую мы написали, поэтому сотрудник отклоняется. Как насчет возвращаемого значения Финдбид? В этом случае макет объекта делает только то, что он может сделать, что возвращает значение по умолчанию. Так как мы возвращаем ссылочный тип (Employee), возвращаемое значение имеет значение null.

Макеты могут показаться бесполезнымиными; Однако есть еще две функции макетов, о которых мы не говорили. Во первых, платформа MOQ записывает все вызовы, сделанные в макете объекта. Далее в коде мы можем спросить MOQ, если кто угодно вызвал метод Add, или если кто угодно вызвал метод Финдбид. Позже мы увидим, как можно использовать эту функцию записи "черного ящика" в тестах.

Второй замечательной функцией является то, как мы можем использовать MOQ для программирования макета объекта с *ожиданиями*. Ожидание указывает макету объекта, как реагировать на любое заданное взаимодействие. Например, можно запрограммировать ожидание в макете и сообщить ему, что он возвращает объект Employee, когда кто-то вызывает Финдбид. Платформа MOQ использует API установки и лямбда-выражения для программирования этих ожиданий.

``` csharp
    [TestMethod]
    public void MockSample() {
        Mock<IRepository<Employee>> mock =
            new Mock<IRepository<Employee>>();
        mock.Setup(m => m.FindById(5))
            .Returns(new Employee {Id = 5});
        IRepository<Employee> repository = mock.Object;
        var employee = repository.FindById(5);
        Assert.IsTrue(employee.Id == 5);
    }
```

В этом примере мы просим MOQ динамически создавать репозиторий, а затем запрограммирован репозиторий с ожиданием. Ожидание означает, что макет объекта возвращает новый объект Employee со значением идентификатора 5, когда кто-то вызывает метод Финдбид, передающий значение 5. Этот тест пройден, и нам не нужно было создавать полную реализацию для имитации IRepository &lt; t &gt; .

Давайте вернемся к тестам, которые мы написали ранее, и переработали их, чтобы использовать макеты вместо имитаций. Как и раньше, мы будем использовать базовый класс для настройки общих частей инфраструктуры, необходимых для всех тестов контроллера.

``` csharp
    public class EmployeeControllerTestBase {
        public EmployeeControllerTestBase() {
            _employeeData = EmployeeObjectMother.CreateEmployees()
                                                .AsQueryable();
            _repository = new Mock<IRepository<Employee>>();
            _unitOfWork = new Mock<IUnitOfWork>();
            _unitOfWork.Setup(u => u.Employees)
                       .Returns(_repository.Object);
            _controller = new EmployeeController(_unitOfWork.Object);
        }

        protected IQueryable<Employee> _employeeData;
        protected Mock<IUnitOfWork> _unitOfWork;
        protected EmployeeController _controller;
        protected Mock<IRepository<Employee>> _repository;
    }
```

Код установки остается главным образом. Вместо использования имитаций мы будем использовать MOQ для создания макетных объектов. Базовый класс упорядочивает макетную единицу работы, чтобы вернуть макет репозитория, когда код вызывает свойство Employees. Оставшаяся часть установки макета будет выполняться внутри набора тестов, предназначенного для каждого конкретного сценария. Например, средство тестирования для действия с индексом настраивает макет репозитория для возврата списка сотрудников, когда действие вызывает метод FindAll макетного репозитория.

``` csharp
    [TestClass]
    public class EmployeeControllerIndexActionTests
               : EmployeeControllerTestBase {
        public EmployeeControllerIndexActionTests() {
            _repository.Setup(r => r.FindAll())
                        .Returns(_employeeData);
        }
        // .. tests
        [TestMethod]
        public void ShouldBuildModelWithAllEmployees() {
            var result = _controller.Index();
            var model = result.ViewData.Model
                          as IEnumerable<Employee>;
            Assert.IsTrue(model.Count() == _employeeData.Count());
        }
        // .. and more tests
    }
```

За исключением ожиданий, наши тесты похожи на тесты, ранее имевшие место. Тем не менее, с возможностью записи структуры макета можно подходить к тестированию с другого угла. В следующем разделе мы рассмотрим эту новую перспективу.

### <a name="state-versus-interaction-testing"></a>Тестирование состояния и взаимодействия

Существуют различные методы, которые можно использовать для тестирования программного обеспечения с помощью макетов объектов. Одним из подходов является использование тестирования на основе состояния, которое мы уже сделали в этой статье. Тестирование на основе состояния делает утверждения о состоянии программного обеспечения. В последнем тесте мы вызвали метод действия на контроллере и внесли утверждение о модели, которую она должна создать. Ниже приведены некоторые другие примеры состояния тестирования.

-   Убедитесь, что репозиторий содержит новый объект Employee после выполнения инструкции CREATE.
-   Убедитесь, что модель содержит список всех сотрудников после выполнения индекса.
-   Убедитесь, что репозиторий не содержит данного сотрудника после выполнения инструкции DELETE.

Другим подходом, который вы увидите с макетами объектов, является проверка *взаимодействия*. Хотя тестирование на основе состояния делает утверждения о состоянии объектов, проверка на основе взаимодействия делает утверждения о взаимодействии объектов. Например.

-   Проверьте, вызывает ли контроллер метод Add репозитория при выполнении инструкции CREATE.
-   Убедитесь, что контроллер вызывает метод FindAll репозитория при выполнении индекса.
-   Убедитесь, что контроллер вызывает метод фиксации единицы работы, чтобы сохранить изменения при выполнении команды Edit.

Тестирование взаимодействия часто требует меньше тестовых данных, так как мы не знакомство в коллекциях и не проверяя счетчики. Например, если известно, что действие Details вызывает метод Финдбид репозитория с правильным значением, то действие, вероятно, работает правильно. Это поведение можно проверить без настройки тестовых данных, возвращаемых из Финдбид.

``` csharp
    [TestClass]
    public class EmployeeControllerDetailsActionTests
               : EmployeeControllerTestBase {
         // ...
        [TestMethod]
        public void ShouldInvokeRepositoryToFindEmployee() {
            var result = _controller.Details(_detailsId);
            _repository.Verify(r => r.FindById(_detailsId));
        }
        int _detailsId = 1;
    }
```

Единственная настройка, необходимая в вышеуказанном тесте, — это настройка, предоставляемая базовым классом. При вызове действия контроллера MOQ будет записывать взаимодействия с макетом репозитория. С помощью API проверки MOQ можно запросить MOQ, если контроллер вызвал Финдбид с правильным значением идентификатора. Если контроллер не вызвал метод или вызвал метод с непредвиденным значением параметра, метод Verify выдаст исключение, и тест завершится ошибкой.

Ниже приведен еще один пример проверки того, что действие Create вызывает фиксацию в текущей единице работы.

``` csharp
    [TestMethod]
    public void ShouldCommitUnitOfWork() {
        _controller.Create(_newEmployee);
        _unitOfWork.Verify(u => u.Commit());
    }
```

Одна опасность, связанная с тестированием взаимодействия, — это тенденция для определения взаимодействий. Возможность макета объекта записывать и проверять каждое взаимодействие с макетом объекта не означает, что тест должен попытаться проверить каждое взаимодействие. Некоторые взаимодействия представляют собой детали реализации, поэтому необходимо только проверить взаимодействия, *необходимые* для удовлетворения текущего теста.

Выбор между макетами или имитациями во многом зависит от тестируемой системы и личных настроек (или команды). Макетные объекты могут радикально уменьшить объем кода, необходимого для реализации тестовых значений Double, но не все это удобно в программировании и проверки взаимодействий.

## <a name="conclusions"></a>Выводы

В этом документе мы рассмотрели несколько подходов к созданию тестируемого кода при использовании Entity Framework ADO.NET для сохраняемости данных. Мы можем использовать встроенные абстракции, например Иобжектсет &lt; t &gt; , или создать собственные абстракции, такие как IRepository &lt; t &gt; .В обоих случаях поддержка POCO в ADO.NET Entity Framework 4,0 позволяет потребителям этих абстракций оставаться постоянной игнорирующих и высоко тестироваться. Дополнительные функции EF4, такие как неявная неактивная Загрузка, позволяют бизнес-приложениям и коду службы приложений работать, не беспокоясь о деталях реляционного хранилища данных. Наконец, создаваемые абстракции просты в макете или подмышлении в модульных тестах, и мы можем использовать эти тестовые удвоения для быстрого выполнения, высокой изолированности и надежности тестов.

### <a name="additional-resources"></a>Дополнительные ресурсы

-   Роберт C. Мартен, " [принцип единой ответственности](https://www.objectmentor.com/resources/articles/srp.pdf)"
-   Мартен Фаулер, [Каталог шаблонов](https://www.martinfowler.com/eaaCatalog/index.html) из *шаблонов архитектуры корпоративных приложений*
-   Гриффин Каприо, « [внедрение зависимостей](https://msdn.microsoft.com/magazine/cc163739.aspx)»
-   Блог по программированию данных [: "Пошаговое руководство. Разработка на основе тестирования с помощью Entity Framework 4,0](/archive/blogs/adonet/walkthrough-test-driven-development-with-the-entity-framework-4-0)".
-   Блог по программированию данных: [Использование шаблонов репозитория и единиц работы с Entity Framework 4,0](/archive/blogs/adonet/using-repository-and-unit-of-work-patterns-with-entity-framework-4-0)»
-   Аарон Йенсен, " [Введение в спецификации машин](http://codebetter.com/blogs/aaron.jensen/archive/2008/05/08/introducing-machine-specifications-or-mspec-for-short.aspx)"
-   «Иванов», « [BDD с MSTest](https://saintgimp.org/2009/01/20/bdd-with-mstest/)»
-   «Эванс», « [Разработка на основе домена](https://books.google.com/books?id=7dlaMs0SECsC&printsec=frontcover&dq=evans%20domain%20driven%20design&hl=en&ei=cHztS6C8KIaglAfA_dS1CA&sa=X&oi=book_result&ct=result&resnum=1&ved=0CCoQ6AEwAA)»
-   Мартен Фаулер, " [макеты не являются заглушками](https://martinfowler.com/articles/mocksArentStubs.html)"
-   Мартен Фаулер, " [Test Double](https://martinfowler.com/bliki/TestDouble.html)"
-   [Moq](https://code.google.com/p/moq/)

### <a name="biography"></a>Текст биографии

Скотт Аллен является участником технических специалистов по Pluralsight и основатель OdeToCode.com. В течение 15 лет коммерческой разработки программного обеспечения Скотт работал над решениями для всех, от 8-разрядных встраиваемых устройств до высокомасштабируемых веб-приложений ASP.NET. Вы можете связаться с Скотт в своем блоге по адресу Одетокоде или в Twitter по адресу [https://twitter.com/OdeToCode](https://twitter.com/OdeToCode) .
