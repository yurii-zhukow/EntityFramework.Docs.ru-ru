---
title: Тестируемость и система сущности 4.0 - EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 9430e2ab-261c-4e8e-8545-2ebc52d7a247
ms.openlocfilehash: 96b6b2791f12b7d60a233f7e6dc77e5a8579fb66
ms.sourcegitcommit: 144edccf9b29a7ffad119c235ac9808ec1a46193
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2020
ms.locfileid: "81434317"
---
# <a name="testability-and-entity-framework-40"></a>Тестируемость и рамочная система сущности 4.0
Скотт Аллен

Опубликовано: Май 2010

## <a name="introduction"></a>Введение

В этом документе описывается и демонстрируется, как писать тестируемый код с ADO.NET Entity Framework 4.0 и Visual Studio 2010. В настоящем документе не делается попытка сосредоточиться на конкретной методологии тестирования, такой как тест-ориентированный дизайн (TDD) или дизайн, управляемый поведением (BDD). Вместо этого в настоящем документе основное внимание будет уделено тому, как писать код, который использует рамки ADO.NET entity, но остается легко изолировать и тестировать в автоматическом режиме. Мы рассмотрим общие шаблоны проектирования, которые облегчают тестирование в сценариях доступа к данным, и посмотрим, как применять эти шаблоны при использовании платформы. Мы также рассмотрим конкретные особенности платформы, чтобы увидеть, как эти функции могут работать в тестируемом коде.

## <a name="what-is-testable-code"></a>Что такое тестируемый код?

Возможность проверить часть программного обеспечения с помощью автоматизированных модульных тестов предлагает много желательных преимуществ. Всем известно, что хорошие тесты уменьшит количество программных дефектов в приложении и увеличат качество приложения, но наличие модульных тестов выходит далеко за рамки простого поиска ошибок.

Хороший набор модульных тестов позволяет команде разработчиков сэкономить время и сохранить контроль над программным обеспечением, создаваемого ими. Команда может вносить изменения в существующий код, рефакторировать, редизайн и реструктурировать программное обеспечение в соответствии с новыми требованиями, а также добавлять новые компоненты в приложение, зная, что набор тестов может проверить поведение приложения. Единичное тестирование является частью быстрого цикла обратной связи для облегчения изменений и сохранения работоспособности программного обеспечения по мере увеличения сложности.

Модульное тестирование поставляется с ценой, однако. Команда должна инвестировать время для создания и поддержания модульных тестов. Объем усилий, необходимых для создания этих тестов, напрямую связан с **тестируемостью** базового программного обеспечения. Насколько легко тестировать программное обеспечение? Команда, разрабатывающая программное обеспечение с учетом тестируемости, создаст эффективные тесты быстрее, чем команда, работающая с нетестируемым программным обеспечением.

Корпорация Майкрософт разработала ADO.NET Entity Framework 4.0 (EF4) с учетом тестируемости. Это не означает, что разработчики будут писать модульные тесты против самого фреймворчного кода. Вместо этого цели тестируемости EF4 упрощает создание тестируемого кода, который строится поверх платформы. Прежде чем мы рассмотрим конкретные примеры, стоит понять качества проверяемого кода.

### <a name="the-qualities-of-testable-code"></a>Качества проверяемого кода

Код, который легко проверить, всегда будет демонстрировать по крайней мере две черты. Во-первых, тестируемый код легко **наблюдать.** Учитывая некоторый набор входов, должно быть легко наблюдать выход кода. Например, тестирование следующего метода легко, потому что метод непосредственно возвращает результат вычисления.

``` csharp
    public int Add(int x, int y) {
        return x + y;
    }
```

Тестирование метода затруднено, если метод записывает вычисленные значения в сетевой розетку, таблицу баз данных или файл, подобный следующему коду. Тест должен выполнить дополнительную работу для получения значения.

``` csharp
    public void AddAndSaveToFile(int x, int y) {
         var results = string.Format("The answer is {0}", x + y);
         File.WriteAllText("results.txt", results);
    }
```

Во-вторых, тестируемый код легко **изолировать.** Давайте использовать следующий псевдо-код как плохой пример проверяемого кода.

``` csharp
    public int ComputePolicyValue(InsurancePolicy policy) {
        using (var connection = new SqlConnection("dbConnection"))
        using (var command = new SqlCommand(query, connection)) {

            // business calculations omitted ...               

            if (totalValue > notificationThreshold) {
                var message = new MailMessage();
                message.Subject = "Warning!";
                var client = new SmtpClient();
                client.Send(message);
            }
        }
        return totalValue;
    }
```

Метод легко наблюдать – мы можем пройти в страховой полис и проверить, что возвратная стоимость соответствует ожидаемому результату. Однако для тестирования метода нам необходимо установить базу данных с правильной схемой и настроить сервер SMTP на случай, если метод попытается отправить электронное письмо.

Модульный тест требует проверить логику вычисления внутри метода, но тест может выйти из строя, поскольку сервер электронной почты находится в автономном режиме, или из-за перемещения сервера базы данных. Оба эти сбоя не связаны с поведением, которые тест хочет проверить. Поведение трудно изолировать.

Разработчики программного обеспечения, которые стремятся писать тестируемый код, часто стремятся сохранить разделение проблем в коде, который они пишут. Вышеупомянутый метод должен быть сосредоточен на бизнес-расчетах и делегировать информацию о реализации базы данных и электронной почты другим компонентам. Роберт К. Мартин называет это принципом единой ответственности. Объект должен инкапсулировать одну узкую ответственность, например, расчет стоимости политики. За все остальные работы по базе данных и уведомлению должна отвечать некий другой объект. Код, написанный таким образом, легче изолировать, потому что он ориентирован на одну задачу.

В .NET есть абстракции, которые мы должны следовать принципу единой ответственности и достичь изоляции. Мы можем использовать определения интерфейса и заставить код использовать абстракцию интерфейса вместо конкретного типа. Позже в этой статье мы увидим, как метод, подобный плохому примеру, представленному выше, может работать с интерфейсами, которые *выглядят* так, как будто они будут говорить с базой данных. Однако в тестовое время мы можем заменить фиктивную реализацию, которая не разговаривает с базой данных, а вместо этого хранит данные в памяти. Эта фиктивная реализация изолирует код от несвязанных проблем в коде доступа к данным или конфигурации базы данных.

Есть дополнительные преимущества изоляции. Вычисление бизнеса в последнем методе должно занять всего несколько миллисекунд, но сам тест может выполняться в течение нескольких секунд, поскольку код перемещается по сети и разговаривает с различными серверами. Единие тесты должны работать быстро, чтобы облегчить небольшие изменения. Единие тесты также должны быть повторяемыми и не проваливаться, поскольку у компонента, не связанного с тестом, есть проблема. Написание кода, который легко наблюдать и изолировать, означает, что разработчикам будет легче писать тесты для кода, тратить меньше времени на ожидание выполнения тестов и, что более важно, тратить меньше времени на отслеживание ошибок, которых не существует.

Надеюсь, вы сможете оценить преимущества тестирования и понять качества, которые демонстрирует проверяемый код. Мы собираемся рассмотреть вопрос о том, как писать код, который работает с EF4, чтобы сохранить данные в базе данных, оставаясь при этом наблюдаемым и легко изолировать, но сначала мы сузим наше внимание, чтобы обсудить тестируемые проекты для доступа к данным.

## <a name="design-patterns-for-data-persistence"></a>Шаблоны проектирования для сохранения данных

Оба плохих примера, представленные ранее, имели слишком много обязанностей. Первый плохой пример должен был выполнить расчет *и* записать в файл. Второй плохой пример должен был считывать данные из базы данных *и* выполнять бизнес-расчет *и* отправлять электронную почту. Разрабатывая более мелкие методы, разделяющие проблемы и делегирующих ответственность другим компонентам, вы сделаете большие шаги в написании проверяемого кода. Цель состоит в том, чтобы построить функциональность путем составления действий из небольших и целенаправленных абстракций.

Когда дело доходит до сохранения данных, небольшие и целенаправленные абстракции, которые мы ищем, настолько распространены, что они были задокументированы как шаблоны проектирования. Книга Мартина Фаулера «Шаблоны архитектуры корпоративных приложений» стала первой работой, описывающей эти закономерности в печатном виде. Мы предоставим краткое описание этих шаблонов в следующих разделах, прежде чем мы покажем, как эти ADO.NET Entity Framework реализует и работает с этими шаблонами.

### <a name="the-repository-pattern"></a>Шаблон репозитория

Фаулер говорит, что репозиторий "опосредует между доменом и слоями отображения данных с помощью коллекционного интерфейса для доступа к доменным объектам". Цель шаблона репозитория состоит в том, чтобы изолировать код от мелочей доступа к данным, и, как мы видели ранее изоляции является необходимой чертой для тестируемости.

Ключом к изоляции является то, как репозиторий предоставляет объекты с помощью интерфейса, похожего на сбор. Логика, которую вы пишете для использования репозитория, не имеет ни малейшего представления о том, как репозиторий материализует объекты, которые вы запрашиваете. Репозиторий может говорить с базой данных, или он может просто вернуть объекты из коллекции в памяти. Все, что нужно знать, это то, что репозиторий, как представляется, поддерживает коллекцию, и вы можете получить, добавить и удалить объекты из коллекции.

В существующих приложениях .NET конкретный репозиторий часто наследует от общего интерфейса, как следующее:

``` csharp
    public interface IRepository<T> {       
        IEnumerable<T> FindAll();
        IEnumerable<T> FindBy(Expression<Func\<T, bool>> predicate);
        T FindById(int id);
        void Add(T newEntity);
        void Remove(T entity);
    }
```

Мы внедрим несколько изменений в определение интерфейса, когда предоставим реализацию для EF4, но основная концепция останется прежней. Код может использовать конкретный репозиторий, реализующий этот интерфейс, для извлечения сущности по ее основному ключевому значению, для получения коллекции сущностей на основе оценки предиката или просто для получения всех доступных сущностей. Код также может добавлять и удалять сущности через интерфейс репозитория.

С учетом IRepository объектов сотрудника код может выполнять следующие операции.

``` csharp
    var employeesNamedScott =
        repository
            .FindBy(e => e.Name == "Scott")
            .OrderBy(e => e.HireDate);
    var firstEmployee = repository.FindById(1);
    var newEmployee = new Employee() {/*... */};
    repository.Add(newEmployee);
```

Поскольку код использует интерфейс (IRepository of Employee), мы можем предоставить код с различными реализациями интерфейса. Одной из реализаций может быть реализация, поддерживаемая EF4, и сохраняющиеся объекты в базе данных Microsoft S'L Server. Другая реализация (та, которую мы используем во время тестирования), может быть подкреплена списком объектов сотрудника в памяти. Интерфейс поможет достичь изоляции в коде.

Обратите внимание, что&lt;интерфейс&gt; IRepository T не предоставляет операцию «Сохранение». Как обновить существующие объекты? Вы можете встретить определения IRepository, которые включают операцию «Сохранение», и реализация этих репозиторий должна будет немедленно упорствовать объекта в базу данных. Однако во многих приложениях мы не хотим сохранять объекты по отдельности. Вместо этого мы хотим оживить объекты, возможно, из различных хранилищ, изменить эти объекты как часть деловой деятельности, а затем сохранить все объекты в рамках одной атомной операции. К счастью, существует шаблон, позволяющий такого рода поведение.

### <a name="the-unit-of-work-pattern"></a>Единица рабочей модели

Фаулер говорит, что единица работы будет "поддерживать список объектов, пострадавших от бизнес-транзакции и координирует написание из изменений и решение проблем с параллелью". Это ответственность единицы работы, чтобы отслеживать изменения объектов, которые мы вора в жизнь из репозитория и сохранять любые изменения, которые мы внесли в объекты, когда мы говорим единицы работы, чтобы совершить изменения. Кроме того, подразделение работы несет ответственность за удаление новых объектов, которые мы добавили во все репозитории, и вставить объекты в базу данных, а также удаление mange.

Если вы когда-либо делали какую-либо работу с ADO.NET DataSets, то вы уже знакомы с единицей шаблона работы. ADO.NET DataSets имел возможность отслеживать наши обновления, удаления и вставки объектов DataRow и мог (с помощью TableAdapter) согласовать все наши изменения в базе данных. Однако объекты DataSet моделируются в отключенном подмножестве базовой базы данных. Единица рабочего шаблона демонстрирует одно и то же поведение, но работает с бизнес-объектами и доменными объектами, которые изолированы от кода доступа к данным и не знают о базе данных.

Абстракция для моделирования единицы работы в коде .NET может выглядеть следующим образом:

``` csharp
    public interface IUnitOfWork {
        IRepository<Employee> Employees { get; }
        IRepository<Order> Orders { get; }
        IRepository<Customer> Customers { get; }
        void Commit();
    }
```

Разоблачая ссылки репозитория из единицы работы, мы можем обеспечить, чтобы единая единица рабочего объекта имеет возможность отслеживать все сущности, материализованные во время бизнес-транзакции. Реализация метода Commit для реальной единицы работы, где все волшебство происходит, чтобы примирить в памяти изменения с базой данных. 

С учетом ссылки IUnitOfWork код может вносить изменения в бизнес-объекты, извлеченные из одного или нескольких репозиторий, и сохранять все изменения с помощью атомной операции Commit.

``` csharp
    var firstEmployee = unitofWork.Employees.FindById(1);
    var firstCustomer = unitofWork.Customers.FindById(1);
    firstEmployee.Name = "Alex";
    firstCustomer.Name = "Christopher";
    unitofWork.Commit();
```

### <a name="the-lazy-load-pattern"></a>Шаблон ленивой нагрузки

Фаулер использует название ленивая нагрузка для описания "объект, который не содержит все данные, которые вам нужны, но знает, как получить его". Прозрачная ленивая загрузка является важной особенностью при написании проверяемого бизнес-кода и работе с реляционной базой данных. В качестве примера рассмотрим следующий код.

``` csharp
    var employee = repository.FindById(id);
    // ... and later ...
    foreach(var timeCard in employee.TimeCards) {
        // .. manipulate the timeCard
    }
```

Как заполняется коллекция TimeCards? Есть два возможных ответа. Один из ответов заключается в том, что репозиторий сотрудника, когда его просят забрать сотрудника, выдает запрос для получения как сотрудника, так и связанной с сотрудником информации о временной карте. В реляционных базах данных это обычно требует запроса с оговоркой JOIN и может привести к получению больше информации, чем требует приложение. Что делать, если приложение никогда не нужно касаться свойства TimeCards?

Второй ответ заключается в загрузке свойства TimeCards "по требованию". Эта ленивая загрузка неясна и прозрачна для бизнес-логики, поскольку код не вызывает специальные AA для получения информации о карточке времени. Код предполагает, что информация о карте времени присутствует при необходимости. Существует некоторая магия, связанная с ленивым погрузки, которая обычно включает в себя перехват времени выполнения метода вызовов. Код перехвата отвечает за разговор с базой данных и получение информации о карточке времени, оставляя бизнес-логику свободной для бизнес-логики. Эта ленивая магия нагрузки позволяет бизнес-коду изолировать себя от операций поиска данных и приводит к более проверяемому коду.

Недостатком ленивой нагрузки является то, что, когда приложению *действительно* нужна информация о карточке времени, код выполняет дополнительный запрос. Это не является проблемой для многих приложений, но для чувствительных к производительности приложений или приложений цикл через ряд объектов сотрудника и выполнения запроса для получения временных карт во время каждой итерации цикла (проблема часто называют n-1 проблемы запроса), ленивая загрузка перетаскивания. В этих сценариях приложение может захотеть загрузить информацию о карточке времени наиболее эффективным способом.

К счастью, мы увидим, как EF4 поддерживает как неявные ленивые нагрузки, так и эффективные нагрузки, которые мы перейдем к следующему разделу и реализуем эти шаблоны.

## <a name="implementing-patterns-with-the-entity-framework"></a>Внедрение шаблонов с рамочной системой образований

Хорошей новостью является то, что все шаблоны проектирования, описанные в последнем разделе, просты в реализации с EF4. Чтобы продемонстрировать, что мы собираемся использовать простое приложение ASP.NET MVC для отображения и отображения информации о сотрудниках и связанных с ними данных о карточках времени. Начнем с использования следующих "обычных старых объектов CLR" (POCOs). 

``` csharp
    public class Employee {
        public int Id { get; set; }
        public string Name { get; set; }
        public DateTime HireDate { get; set; }
        public ICollection<TimeCard> TimeCards { get; set; }
    }

    public class TimeCard {
        public int Id { get; set; }
        public int Hours { get; set; }
        public DateTime EffectiveDate { get; set; }
    }
```

Эти определения классов немного изменятся по мере того, как мы исследуем различные подходы и особенности EF4, но цель состоит в том, чтобы сохранить эти классы как сохранение невежественным (PI), насколько это возможно. Объект PI не *знает, как*или даже *если*состояние, в которое он содержится, живет внутри базы данных. PI и POCOs идут рука об руку с тестируемым программным обеспечением. Объекты, использующие подход POCO, менее ограничены, более гибки и легче тестируются, поскольку они могут работать без присутствия базы данных.

С POCOs на месте мы можем создать модель данных entity (EDM) в Visual Studio (см. рисунок 1). Мы не будем использовать EDM для создания кода для наших сущностей. Вместо этого, мы хотим использовать сущности, которые мы с любовью ремесла вручную. Мы будем использовать EDM только для создания схемы базы данных и предоставления метаданных EF4, необходимых для картирования объектов в базе данных.

![ef test_01](~/ef6/media/eftest-01.jpg)

**Рисунок 1**

Примечание: если вы хотите сначала разработать модель EDM, можно создать чистый код POCO из EDM. Вы можете сделать это с помощью расширения Visual Studio 2010, предоставленного командой Data Programmability. Чтобы загрузить расширение, запустите менеджер расширения из меню Tools в Visual Studio и ищите онлайн-галерею шаблонов для "POCO" (см. рисунок 2). Есть несколько шаблонов POCO, доступных для EF. Для получения дополнительной информации об [Walkthrough: POCO Template for the Entity Framework](https://docs.microsoft.com/archive/blogs/adonet/walkthrough-poco-template-for-the-entity-framework)использовании шаблона см.

![ef test_02](~/ef6/media/eftest-02.png)

**Рисунок 2**

С этой отправной точки POCO мы рассмотрим два различных подхода к тестируемому коду. Первый подход я называю подходом EF, поскольку он использует абстракции из API Системы сущностей для реализации единиц работы и репозиторий. Во втором подходе мы создадим наши собственные абстракции репозитория, а затем увидим преимущества и недостатки каждого подхода. Начнем с изучения подхода EF.  

### <a name="an-ef-centric-implementation"></a>Реализация ef Centric

Рассмотрим следующее действие контроллера из проекта ASP.NET MVC. Действие извлекает объект сотрудника и возвращает результат для отображения подробного представления сотрудника.

``` csharp
    public ViewResult Details(int id) {
        var employee = _unitOfWork.Employees
                                  .Single(e => e.Id == id);
        return View(employee);
    }
```

Тестируемый ли код? Есть по крайней мере два теста, которые нам нужно проверить поведение действия. Во-первых, мы хотели бы проверить, что действие возвращает правильное представление – простой тест. Мы также хотим написать тест для проверки того, что действие получает правильного сотрудника, и мы хотели бы сделать это без выполнения кода для запроса базы данных. Помните, что мы хотим изолировать тестированный код. Изоляция гарантирует, что тест не выйдет из строя из-за ошибки в коде доступа к данным или конфигурации базы данных. Если тест не удается, мы будем знать, что у нас есть ошибка в логике контроллера, а не в каком-то компоненте системы более низкого уровня.

Для достижения изоляции нам понадобятся некоторые абстракции, такие как интерфейсы, которые мы представили ранее для репозиторий и единиц работы. Помните, что шаблон репозитория предназначен для посредничества между объектами домена и слоем картирования данных. В этом сценарии EF4 *является* слоем картирования данных и уже предоставляет абстракцию типа репозитория iObjectSet&lt;T&gt; (из пространства имен System.Data.Objects). Определение интерфейса выглядит следующим образом.

``` csharp
    public interface IObjectSet<TEntity> :
                     IQueryable<TEntity>,
                     IEnumerable<TEntity>,
                     IQueryable,
                     IEnumerable
                     where TEntity : class
    {
        void AddObject(TEntity entity);
        void Attach(TEntity entity);
        void DeleteObject(TEntity entity);
        void Detach(TEntity entity);
    }
```

IObjectSet&lt;&gt; T отвечает требованиям к репозиторию, поскольку он напоминает коллекцию&lt;&gt;объектов (через IEnumerable T) и предоставляет методы добавления и удаления объектов из смоделированной коллекции. Методы присоединения и отъема предоставляют дополнительные возможности API EF4. Для использования IObjectSet&lt;T&gt; в качестве интерфейса для репозиториев нам нужна единица рабочей абстракции для связывания репозиториев.

``` csharp
    public interface IUnitOfWork {
        IObjectSet<Employee> Employees { get; }
        IObjectSet<TimeCard> TimeCards { get; }
        void Commit();
    }
```

Одна конкретная реализация этого интерфейса будет говорить с сервером S'L и легко создать с помощью класса ObjectContext от EF4. Класс ObjectContext является реальной единицей работы в API EF4.

``` csharp
    public class SqlUnitOfWork : IUnitOfWork {
        public SqlUnitOfWork() {
            var connectionString =
                ConfigurationManager
                    .ConnectionStrings[ConnectionStringName]
                    .ConnectionString;
            _context = new ObjectContext(connectionString);
        }

        public IObjectSet<Employee> Employees {
            get { return _context.CreateObjectSet<Employee>(); }
        }

        public IObjectSet<TimeCard> TimeCards {
            get { return _context.CreateObjectSet<TimeCard>(); }
        }

        public void Commit() {
            _context.SaveChanges();
        }

        readonly ObjectContext _context;
        const string ConnectionStringName = "EmployeeDataModelContainer";
    }
```

Оживлять&lt;IObjectSet T&gt; так же просто, как ссылаться на метод CreateObjectSet объекта ObjectContext. За кулисами рамки будут использовать метаданные, которые мы предоставили&lt;в&gt;EDM для производства конкретных ObjectSet T . Мы будем придерживаться возвращения интерфейса IObjectSet&lt;T,&gt; потому что это поможет сохранить тестируемость в клиентском коде.

Эта конкретная реализация полезна в производстве, но мы должны сосредоточиться на том, как мы будем использовать нашу абстракцию IUnitOfWork для облегчения тестирования.

### <a name="the-test-doubles"></a>Тестовый парный разряд

Чтобы изолировать действие контроллера, нам понадобится возможность переключения между реальной единицей работы (при поддержке ObjectContext) и тестовой двойной или "поддельной" единицей работы (выполняя операции в памяти). Общий подход для выполнения этого типа переключения заключается в том, чтобы не позволить контроллеру MVC мгновенно гостевого блока работы, а вместо этого передать единицу работы в контроллер в качестве параметра конструктора.

``` csharp
    class EmployeeController : Controller {
      publicEmployeeController(IUnitOfWork unitOfWork)  {
          _unitOfWork = unitOfWork;
      }
      ...
    }
```

Вышеуказанный код является примером инъекции зависимости. Мы не позволяем контроллеру создавать его зависимость (единицу работы), но вводим зависимость в контроллер. В проекте MVC обычно используется фабрика пользовательских контроллеров в сочетании с инверсией элемента управления (IoC) контейнера для автоматизации впрыска зависимости. Эти темы выходят за рамки данной статьи, но вы можете прочитать больше, следуя ссылкам в конце этой статьи.

Поддельная единица реализации работы, которую мы можем использовать для тестирования, может выглядеть следующим образом.

``` csharp
    public class InMemoryUnitOfWork : IUnitOfWork {
        public InMemoryUnitOfWork() {
            Committed = false;
        }
        public IObjectSet<Employee> Employees {
            get;
            set;
        }

        public IObjectSet<TimeCard> TimeCards {
            get;
            set;
        }

        public bool Committed { get; set; }
        public void Commit() {
            Committed = true;
        }
    }
```

Обратите внимание, поддельные единицы работы подвергает совершается собственности. Иногда полезно добавлять функции в поддельный класс, облегчающие тестирование. В этом случае легко наблюдать, если код совершает единицу работы, проверяя свойство Commited.

Нам также понадобится поддельный&lt;IObjectSet T&gt; для хранения объектов сотрудников и TimeCard в памяти. Мы можем обеспечить единую реализацию с использованием генериков.

``` csharp
    public class InMemoryObjectSet<T> : IObjectSet<T> where T : class
        public InMemoryObjectSet()
            : this(Enumerable.Empty<T>()) {
        }
        public InMemoryObjectSet(IEnumerable<T> entities) {
            _set = new HashSet<T>();
            foreach (var entity in entities) {
                _set.Add(entity);
            }
            _queryableSet = _set.AsQueryable();
        }
        public void AddObject(T entity) {
            _set.Add(entity);
        }
        public void Attach(T entity) {
            _set.Add(entity);
        }
        public void DeleteObject(T entity) {
            _set.Remove(entity);
        }
        public void Detach(T entity) {
            _set.Remove(entity);
        }
        public Type ElementType {
            get { return _queryableSet.ElementType; }
        }
        public Expression Expression {
            get { return _queryableSet.Expression; }
        }
        public IQueryProvider Provider {
            get { return _queryableSet.Provider; }
        }
        public IEnumerator<T> GetEnumerator() {
            return _set.GetEnumerator();
        }
        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        readonly HashSet<T> _set;
        readonly IQueryable<T> _queryableSet;
    }
```

Этот тестовый двойник делегирует большую&lt;&gt; часть своей работы базовому объекту HashSet T. Обратите внимание,&lt;что&gt; IObjectSet T требует общего ограничения, обеспечивающего T как класс (тип&lt;ссылки), а также заставляет нас реализовывать I'Eeryable T&gt;. С помощью стандартного оператора LIN' As'queryable легко сделать так, чтобы коллекция в памяти выглядела как I'I-Образный&lt;T.&gt;

### <a name="the-tests"></a>Тесты

Традиционные модульные тесты будут использовать один класс испытаний для проведения всех тестов для всех действий в одном контроллере MVC. Мы можем написать эти тесты, или любой тип модульного теста, используя подделки в памяти, которые мы создали. Однако для этой статьи мы избежим монолитного подхода класса тестов и вместо этого сгруппируем наши тесты, чтобы сосредоточиться на определенной функциональности.Например, "создать нового сотрудника" может быть функциональность, которая мы хотим проверить, поэтому мы будем использовать один класс тестирования для проверки одного действия контроллера, ответственного за создание нового сотрудника.

Существует некоторый общий код настройки, который нам нужен для всех этих классов тонкозернистого теста. Например, нам всегда нужно создавать наши хранилища памяти и поддельную единицу работы. Нам также нужен экземпляр контроллера сотрудника с поддельным блоком работы вводили. Мы поделимся этим общим кодом настройки в тестовых классах с помощью базового класса.

``` csharp
    public class EmployeeControllerTestBase {
        public EmployeeControllerTestBase() {
            _employeeData = EmployeeObjectMother.CreateEmployees()
                                                .ToList();
            _repository = new InMemoryObjectSet<Employee>(_employeeData);
            _unitOfWork = new InMemoryUnitOfWork();
            _unitOfWork.Employees = _repository;
            _controller = new EmployeeController(_unitOfWork);
        }

        protected IList<Employee> _employeeData;
        protected EmployeeController _controller;
        protected InMemoryObjectSet<Employee> _repository;
        protected InMemoryUnitOfWork _unitOfWork;
    }
```

"Объектная мать", используемая в базовом классе, является одним из распространенных шаблонов для создания тестовых данных. Мать объекта содержит заводские методы для мгновенного распознавания объектов тестирования для использования в нескольких тестовых приборах.

``` csharp
    public static class EmployeeObjectMother {
        public static IEnumerable<Employee> CreateEmployees() {
            yield return new Employee() {
                Id = 1, Name = "Scott", HireDate=new DateTime(2002, 1, 1)
            };
            yield return new Employee() {
                Id = 2, Name = "Poonam", HireDate=new DateTime(2001, 1, 1)
            };
            yield return new Employee() {
                Id = 3, Name = "Simon", HireDate=new DateTime(2008, 1, 1)
            };
        }
        // ... more fake data for different scenarios
    }
```

Мы можем использовать EmployeeControllerTestBase в качестве базового класса для ряда тестовых приборов (см. рисунок 3). Каждый тестовый прибор будет тестировать определенное действие контроллера. Например, один тестовый прибор будет сосредоточен на тестировании действия Create, используемого во время запроса HTTP GET (для отображения представления для создания сотрудника), а другой прибор будет сосредоточен на действии Create, используемом в запросе HTTP POST (для получения информации, представленной пользователем для создания сотрудника). Каждый полученный класс отвечает только за настройку, необходимую в его конкретном контексте, и для предоставления утверждений, необходимых для проверки результатов для его конкретного контекста тестирования.

![ef test_03](~/ef6/media/eftest-03.png)

**Рисунок 3**

Представленный здесь тип именования и стиль тестирования не требуются для тестируемого кода – это всего лишь один подход. Рисунок 4 показывает тесты, проводимые в Jet Brains Resharper тест бегун плагин для Visual Studio 2010.

![ef test_04](~/ef6/media/eftest-04.png)

**Рисунок 4**

При базовом классе для обработки общего кода настройки модульные тесты для каждого действия контроллера малы и просты в записи. Тесты будут выполняться быстро (так как мы выполняем операции в памяти), и не должны потерпеть неудачу из-за несвязанных инфраструктуры или экологических проблем (потому что мы изолировали блок, наданный тест).

``` csharp
    [TestClass]
    public class EmployeeControllerCreateActionPostTests
               : EmployeeControllerTestBase {
        [TestMethod]
        public void ShouldAddNewEmployeeToRepository() {
            _controller.Create(_newEmployee);
            Assert.IsTrue(_repository.Contains(_newEmployee));
        }
        [TestMethod]
        public void ShouldCommitUnitOfWork() {
            _controller.Create(_newEmployee);
            Assert.IsTrue(_unitOfWork.Committed);
        }
        // ... more tests

        Employee _newEmployee = new Employee() {
            Name = "NEW EMPLOYEE",
            HireDate = new System.DateTime(2010, 1, 1)
        };
    }
```

В этих тестах базовый класс выполняет большую часть работы по настройке. Помните, что конструктор базового класса создает репозиторий памяти, поддельную единицу работы и экземпляр класса EmployeeController. Тестовый класс происходит от этого базового класса и фокусируется на специфике тестирования метода Создания. В этом случае специфика сводится к шагам «обустроить, действовать и утверждать», которые вы увидите в любой процедуре модульного тестирования:

-   Создание нового объекта-сотрудника для имитации входящих данных.
-   Вызвать действие Create employeeController и пройти в newEmployee.
-   Проверка действия Create создает ожидаемые результаты (сотрудник отображается в репозитории).

То, что мы создали, позволяет нам протестировать любое из действий EmployeeController. Например, когда мы пишем тесты для действия Индекса контроллера сотрудника, мы можем наследовать из класса тестовой базы, чтобы установить ту же базовую настройку для наших тестов. Снова базовый класс создаст хранилище в памяти, поддельную единицу работы и экземпляр EmployeeController. Тесты для действия Индекса должны быть направлены только на то, чтобы ссылаться на действие Индекса и тестировать качества модели, которая возвращается к действию.

``` csharp
    [TestClass]
    public class EmployeeControllerIndexActionTests
               : EmployeeControllerTestBase {
        [TestMethod]
        public void ShouldBuildModelWithAllEmployees() {
            var result = _controller.Index();
            var model = result.ViewData.Model
                          as IEnumerable<Employee>;
            Assert.IsTrue(model.Count() == _employeeData.Count);
        }
        [TestMethod]
        public void ShouldOrderModelByHiredateAscending() {
            var result = _controller.Index();
            var model = result.ViewData.Model
                         as IEnumerable<Employee>;
            Assert.IsTrue(model.SequenceEqual(
                           _employeeData.OrderBy(e => e.HireDate)));
        }
        // ...
    }
```

Тесты, которые мы создаем с подделками в памяти, ориентированы на тестирование *состояния* программного обеспечения. Например, при тестировании действия «Создание» необходимо проверить состояние репозитория после выполнения действия «Создание» — удерживает ли репозиторий нового сотрудника?

``` csharp
    [TestMethod]
    public void ShouldAddNewEmployeeToRepository() {
        _controller.Create(_newEmployee);
        Assert.IsTrue(_repository.Contains(_newEmployee));
    }
```

Позже мы рассмотрим тестирование на основе взаимодействия. Тестирование на основе взаимодействия спросит, ссылается ли тестовый код на надлежащие методы на наши объекты и передает правильные параметры. Сейчас мы будем двигаться по крышке другой шаблон дизайна - ленивый нагрузки.

## <a name="eager-loading-and-lazy-loading"></a>Стремясь загрузки и ленивые загрузки

В какой-то момент в веб-приложении mVC ASP.NET мы, возможно, пожелаем отобразить информацию сотрудника и включить связанные с сотрудником временные карты. Например, у нас может быть сводный дисплей скарты времени, который показывает имя сотрудника и общее количество карт времени в системе. Существует несколько подходов, которые мы можем предпринять для реализации этой функции.

### <a name="projection"></a>Проекция

Один простой подход к созданию резюме заключается в создании модели, посвященной информации, которая мы хотим отображать в представлении. В этом сценарии модель может выглядеть следующим образом.

``` csharp
    public class EmployeeSummaryViewModel {
        public string Name { get; set; }
        public int TotalTimeCards { get; set; }
    }
```

Обратите внимание, что EmployeeSummaryViewModel не является сущностью - другими словами, это не то, что мы хотим сохранить в базе данных. Мы будем использовать этот класс только для перетасовки данных в представление в сильно набранном виде. Модель представления подобна объекту передачи данных (DTO), поскольку она не содержит поведения (без методов) - только свойства. Свойства будут хранить данные, необходимые для перемещения. С помощью стандартного проекционного оператора - оператора Select можно легко мгновенно извнести эту модель представления.

``` csharp
    public ViewResult Summary(int id) {
        var model = _unitOfWork.Employees
                               .Where(e => e.Id == id)
                               .Select(e => new EmployeeSummaryViewModel
                                  {
                                    Name = e.Name,
                                    TotalTimeCards = e.TimeCards.Count()
                                  })
                               .Single();
        return View(model);
    }
```

В приведенном выше коде есть две примечательные особенности. Во-первых – код легко тестировать, потому что его по-прежнему легко наблюдать и изолировать. Оператор Select работает так же хорошо против наших подделок в памяти, как и против реальной единицы работы.

``` csharp
    [TestClass]
    public class EmployeeControllerSummaryActionTests
               : EmployeeControllerTestBase {
        [TestMethod]
        public void ShouldBuildModelWithCorrectEmployeeSummary() {
            var id = 1;
            var result = _controller.Summary(id);
            var model = result.ViewData.Model as EmployeeSummaryViewModel;
            Assert.IsTrue(model.TotalTimeCards == 3);
        }
        // ...
    }
```

Вторая примечательная особенность заключается в том, как код позволяет EF4 генерировать единый, эффективный запрос для совместной сборки информации о сотрудниках и временных картах. Мы загрузили информацию о сотрудниках и информацию о временных картах в один и тот же объект без использования специальных AA. В коде просто выражается информация, необходимая для использования стандартных операторов LIN, которые работают против источников данных в памяти, а также удаленных источников данных. EF4 удалось перевести деревья выражения, генерируемые запросом\# LIN и C компилятором, в единый и эффективный запрос T-S'L.

``` SQL
    SELECT
    [Limit1].[Id] AS [Id],
    [Limit1].[Name] AS [Name],
    [Limit1].[C1] AS [C1]
    FROM (SELECT TOP (2)
      [Project1].[Id] AS [Id],
      [Project1].[Name] AS [Name],
      [Project1].[C1] AS [C1]
      FROM (SELECT
        [Extent1].[Id] AS [Id],
        [Extent1].[Name] AS [Name],
        (SELECT COUNT(1) AS [A1]
         FROM [dbo].[TimeCards] AS [Extent2]
         WHERE [Extent1].[Id] =
               [Extent2].[EmployeeTimeCard_TimeCard_Id]) AS [C1]
              FROM [dbo].[Employees] AS [Extent1]
               WHERE [Extent1].[Id] = @p__linq__0
         )  AS [Project1]
    )  AS [Limit1]
```

Есть и другие случаи, когда мы не хотим работать с моделью представления или объектом DTO, но с реальными сущностями. Когда мы знаем, что нам нужен сотрудник *и* карты времени сотрудника, мы можем с нетерпением загружать соответствующие данные ненавязчивым и эффективным образом.

### <a name="explicit-eager-loading"></a>Явная стремящаяся загрузка

Когда мы хотим с готовностью загрузить связанную информацию о сущности, нам нужен механизм бизнес-логики (или в этом сценарии, логика действия контроллера), чтобы выразить свое желание репозиторию. Класс ef4 Object'ery&lt;T&gt; определяет метод включения для указания связанных объектов для извлечения во время запроса. Помните, что EF4 ObjectContext разоблачает сущности через конкретный класс ObjectSet&lt;T,&gt; который наследует от Object's.a.&lt;&gt;Если бы мы&lt;использовали&gt; ссылки ObjectSet T в нашем действии контроллера, мы могли бы написать следующий код, чтобы указать несбывную нагрузку информации о карточке времени для каждого сотрудника.

``` csharp
    _employees.Include("TimeCards")
              .Where(e => e.HireDate.Year > 2009);
```

Однако, поскольку мы стараемся, чтобы наш код&lt;&gt; проверяемый, мы не подвергаем ObjectSet T из-за пределов реальной единицы рабочего класса. Вместо этого мы полагаемся&lt;на&gt; интерфейс IObjectSet T, который&lt;&gt; легче подделать, но IObjectSet T не определяет метод включения. Прелесть LIN'а заключается в том, что мы можем создать собственного оператора Include.

``` csharp
    public static class QueryableExtensions {
        public static IQueryable<T> Include<T>
                (this IQueryable<T> sequence, string path) {
            var objectQuery = sequence as ObjectQuery<T>;
            if(objectQuery != null)
            {
                return objectQuery.Include(path);
            }
            return sequence;
        }
    }
```

Обратите внимание, что этот оператор Включает в&lt;себя&gt; метод расширения&lt;для&gt;I'E'E'Eiryable T вместо IObjectSet T . Это дает нам возможность использовать метод с более широким диапазоном возможных&gt;типов,&lt;в&gt;том числе I'I'ryable&lt;&lt;T , IObjectSet T , ОбъектКуи T&gt;, и ObjectSet&lt;T&gt;. В случае, если основная последовательность не является&lt;подлинным EF4 Object's,s,&gt;то нет никакого вреда, и оператор Include не является op. Если основной последовательностью *является* &lt;Object'ery T&gt; (или&lt;&gt;выведенный из Object'ery T), то EF4 увидит наше требование о дополнительных данных и сформулирует надлежащий запрос S'L.

С этим новым оператором на месте мы можем явно запросить стремятся нагрузки информации карты времени из репозитория.

``` csharp
    public ViewResult Index() {
        var model = _unitOfWork.Employees
                               .Include("TimeCards")
                               .OrderBy(e => e.HireDate);
        return View(model);
    }
```

При запуске в отношении реального ObjectContext код создает следующий один запрос. Запрос собирает достаточно информации из базы данных за одну поездку, чтобы материализовать объекты сотрудников и полностью заполнить их свойство TimeCards.

``` SQL
    SELECT
    [Project1].[Id] AS [Id],
    [Project1].[Name] AS [Name],
    [Project1].[HireDate] AS [HireDate],
    [Project1].[C1] AS [C1],
    [Project1].[Id1] AS [Id1],
    [Project1].[Hours] AS [Hours],
    [Project1].[EffectiveDate] AS [EffectiveDate],
    [Project1].[EmployeeTimeCard_TimeCard_Id] AS [EmployeeTimeCard_TimeCard_Id]
    FROM ( SELECT
         [Extent1].[Id] AS [Id],
         [Extent1].[Name] AS [Name],
         [Extent1].[HireDate] AS [HireDate],
         [Extent2].[Id] AS [Id1],
         [Extent2].[Hours] AS [Hours],
         [Extent2].[EffectiveDate] AS [EffectiveDate],
         [Extent2].[EmployeeTimeCard_TimeCard_Id] AS
                    [EmployeeTimeCard_TimeCard_Id],
         CASE WHEN ([Extent2].[Id] IS NULL) THEN CAST(NULL AS int)
         ELSE 1 END AS [C1]
         FROM  [dbo].[Employees] AS [Extent1]
         LEFT OUTER JOIN [dbo].[TimeCards] AS [Extent2] ON [Extent1].[Id] = [Extent2].[EmployeeTimeCard_TimeCard_Id]
    )  AS [Project1]
    ORDER BY [Project1].[HireDate] ASC,
             [Project1].[Id] ASC, [Project1].[C1] ASC
```

Хорошей новостью является то, что код внутри метода действия остается полностью проверяемым. Нам не нужно предоставлять какие-либо дополнительные функции для наших подделок для поддержки оператора Include. Плохая новость заключается в том, что мы должны были использовать оператора Включить внутри кода, который мы хотели сохранить настойчивость невежественным. Это наиосновной пример типа компромиссов, которые необходимо оценить при создании проверяемого кода. Есть моменты, когда вам нужно, чтобы настойчивость проблемы утечки за пределами репозитория абстракции для достижения целей производительности.

Альтернативой нетерпеливой загрузке является ленивая загрузка. Ленивая загрузка означает, что нам *не* нужен наш бизнес-код, чтобы явно объявить требование о связанных данных. Вместо этого мы используем наши сущности в приложении, и если необходимы дополнительные данные, система entity загружает данные по требованию.

### <a name="lazy-loading"></a>Отложенная загрузка

Легко представить себе сценарий, при котором мы не знаем, какие данные понадобятся бизнес-логике. Возможно, мы знаем, что логике нужен объект сотрудника, но мы можем влиться в различные пути выполнения, где некоторые из этих путей требуют от сотрудника данных временных карт, а некоторые нет. Сценарии, подобные этому, идеально подходят для неявной ленивой загрузки, потому что данные волшебным образом появляются по мере необходимости.

Ленивая загрузка, также известная как отложенная загрузка, действительно предъявляет некоторые требования к объектам сущности. POOS с истинным незнанием настойчивости не будет сталкиваться с какими-либо требованиями со стороны настойчивости слоя, но истинное сохранение невежества практически невозможно достичь.Вместо этого мы измеряем упорство невежество в относительной степени. Было бы прискорбно, если бы нам нужно было наследовать от настойчивости ориентированный базовый класс или использовать специализированную коллекцию для достижения ленивых загрузки в POOS. К счастью, EF4 имеет менее навязчивое решение.

### <a name="virtually-undetectable"></a>Практически необнаруживаемые

При использовании объектов POCO EF4 может динамически генерировать прокси-подобие времени выполнения для сущностей. Эти прокси невидимо обернуть материализовались POOS и предоставлять дополнительные услуги путем перехвата каждого свойства получить и установить операцию для выполнения дополнительной работы. Одним из таких услуг является ленивый функции загрузки мы ищем. Другой службой является эффективный механизм отслеживания изменений, который может записывать, когда программа изменяет значения свойств объекта. Список изменений используется ObjectContext во время метода SaveChanges для сохранения любых измененных сущностей с использованием команд UPDATE.

Для того, чтобы эти прокси-компании работали, им нужен способ зацепиться за свойство получить и установить операции на сущности, и прокси достичь этой цели, переопределяя виртуальных членов. Таким образом, если мы хотим иметь неявную ленивую загрузку и эффективное отслеживание изменений, мы должны вернуться к нашим определениям класса POCO и пометить свойства как виртуальные.

``` csharp
    public class Employee {
        public virtual int Id { get; set; }
        public virtual string Name { get; set; }
        public virtual DateTime HireDate { get; set; }
        public virtual ICollection<TimeCard> TimeCards { get; set; }
    }
```

Мы все еще можем сказать, что организация Employee в основном является неосведомленной. Единственным требованием является использование виртуальных членов, и это не влияет на тестируемость кода. Нам не нужно получать от какого-либо специального базового класса, или даже использовать специальную коллекцию, посвященную ленивым загрузки. Как показывает код, любой класс,&lt;&gt; реализующий ICollection T, доступен для хранения связанных сущностей.

Существует также одно незначительное изменение, мы должны сделать внутри нашей единицы работы. Ленивая загрузка *отключена* по умолчанию при работе непосредственно с объектом ObjectContext. Существует свойство, мы можем установить на свойство ContextOptions для включения отложенной загрузки, и мы можем установить это свойство внутри нашей реальной единицы работы, если мы хотим, чтобы ленивый загрузки во всем мире.

``` csharp
    public class SqlUnitOfWork : IUnitOfWork {
         public SqlUnitOfWork() {
             // ...
             _context = new ObjectContext(connectionString);
             _context.ContextOptions.LazyLoadingEnabled = true;
         }    
         // ...
     }
```

При неявной ленивой загрузке включена, код приложения может использовать сотрудников и связанные карты времени сотрудника, оставаясь в блаженном неведении о работе, необходимой для загрузки дополнительных данных EF.

``` csharp
    var employee = _unitOfWork.Employees
                              .Single(e => e.Id == id);
    foreach (var card in employee.TimeCards) {
        // ...
    }
```

Ленивая загрузка упрощает запись кода приложения, а с помощью прокси-магии код остается полностью проверяемым. Подделки в памяти рабочего блока могут просто предзагружать поддельные объекты со связанными данными, когда это необходимо во время теста.

На этом этапе мы обратим наше внимание от создания&lt;репозиторий с помощью IObjectSet T&gt; и рассмотрим абстракции, чтобы скрыть все признаки инфраструктуры сохранения.

## <a name="custom-repositories"></a>Пользовательские репозитории

Когда мы впервые представили в этой статье шаблон проектирования единицы работы, мы предоставили некоторый пример кода для того, как может выглядеть единица работы. Давайте представим эту оригинальную идею, используя сценарий карты времени сотрудника и сотрудника, с которым мы работали.

``` csharp
    public interface IUnitOfWork {
        IRepository<Employee> Employees { get; }
        IRepository<TimeCard> TimeCards { get;  }
        void Commit();
    }
```

Основное различие между этой единицей работы и единицей работы, которую мы создали в последнем разделе, заключается в&lt;том, как эта единица работы не использует никаких абстракций из фреймворка EF4 (нет IObjectSet T).&gt; IObjectSet&lt;&gt; T хорошо работает как интерфейс репозитория, но API, который он предоставляет, может не соответствовать потребностям нашего приложения. В этом предстоящем подходе мы будем представлять репозитории, используя пользовательские абстракции IRepository&lt;T.&gt;

Многие разработчики, которые следуют тест-ориентированному дизайну, дизайну, управляемому поведением, и методологиям домена, предпочитают подход IRepository&lt;T&gt; по нескольким причинам. Во-первых, интерфейс IRepository&lt;T&gt; представляет собой слой «антикоррупционного» уровня. Как описано Эриком Эвансом в его книге Domain Driven Design, антикоррупционный слой удерживает ваш код домена от API инфраструктуры, как ИП. Во-вторых, разработчики могут создавать методы в репозиторий, которые отвечают точным потребностям приложения (как обнаружено при написании тестов). Например, нам часто приходится находить одну сущность с помощью значения идентификатора, чтобы мы могли добавить метод FindById в интерфейс репозитория.Наше определение IRepository&lt;T&gt; будет выглядеть следующим образом.

``` csharp
    public interface IRepository<T>
                    where T : class, IEntity {
        IQueryable<T> FindAll();
        IQueryable<T> FindWhere(Expression<Func\<T, bool>> predicate);
        T FindById(int id);       
        void Add(T newEntity);
        void Remove(T entity);
    }
```

Обратите внимание, что мы вернемся к&lt;&gt; использованию интерфейса I'Siryable T для разоблачения коллекций сущностей. Иски&lt;T&gt; позволяют деревьям выражения LIN'а вливаться в провайдер EF4 и дать поставщику целостное представление о запросе. Вторым вариантом было бы возвращение IEnumerable&lt;T,&gt;что означает, что поставщик EF4 LIN' будет видеть только выражения, встроенные внутри репозитория. Любая группировка, заказ и проекция, выполненная за пределами репозитория, не будут входить в команду S'L, отправленную в базу данных, что может повредить производительности. С другой стороны, репозиторий, возвращающийся&lt;&gt; только с iEnumerable T-результатов, никогда не удивит вас новой командой S'L. Оба подхода будут работать, и оба подхода остаются проверяемыми.

Обеспечить единую реализацию интерфейса IRepository&lt;&gt; T с использованием генериков и API EF4 ObjectContext.

``` csharp
    public class SqlRepository<T> : IRepository<T>
                                    where T : class, IEntity {
        public SqlRepository(ObjectContext context) {
            _objectSet = context.CreateObjectSet<T>();
        }
        public IQueryable<T> FindAll() {
            return _objectSet;
        }
        public IQueryable<T> FindWhere(
                               Expression<Func\<T, bool>> predicate) {
            return _objectSet.Where(predicate);
        }
        public T FindById(int id) {
            return _objectSet.Single(o => o.Id == id);
        }
        public void Add(T newEntity) {
            _objectSet.AddObject(newEntity);
        }
        public void Remove(T entity) {
            _objectSet.DeleteObject(entity);
        }
        protected ObjectSet<T> _objectSet;
    }
```

Подход&lt;IRepository&gt; T дает нам дополнительный контроль над нашими запросами, потому что клиент должен вызвать метод, чтобы добраться до сущности. Внутри метода мы могли бы предоставить дополнительные проверки и операторов LIN'а для обеспечения ограничений приложений. Обратите внимание, что интерфейс имеет два ограничения на общий параметр типа. Первым ограничением является запятнание класса&lt;конс, требуемое ObjectSet T,&gt;а второе ограничение вынуждает наши сущности реализовывать IEntity – абстракцию, созданную для приложения. Интерфейс IEntity заставляет сущности иметь свойство читаемого идона, и мы можем использовать это свойство в методе FindById. IEntity определяется со следующим кодом.

``` csharp
    public interface IEntity {
        int Id { get; }
    }
```

IEntity можно считать небольшим нарушением незнания настойчивости, поскольку наши организации обязаны реализовать этот интерфейс. Помните, что сохранение невежества о компромиссов, и для многих функции FindById будет перевешивать ограничения, введенные интерфейсом. Интерфейс не влияет на тестируемость.

Мгновенное воспроизведение&lt;iRepository&gt; T требует EF4 ObjectContext, поэтому конкретная единица реализации работы должна управлять моментом.

``` csharp
    public class SqlUnitOfWork : IUnitOfWork {
        public SqlUnitOfWork() {
            var connectionString =
                ConfigurationManager
                    .ConnectionStrings[ConnectionStringName]
                    .ConnectionString;

            _context = new ObjectContext(connectionString);
            _context.ContextOptions.LazyLoadingEnabled = true;
        }

        public IRepository<Employee> Employees {
            get {
                if (_employees == null) {
                    _employees = new SqlRepository<Employee>(_context);
                }
                return _employees;
            }
        }

        public IRepository<TimeCard> TimeCards {
            get {
                if (_timeCards == null) {
                    _timeCards = new SqlRepository<TimeCard>(_context);
                }
                return _timeCards;
            }
        }

        public void Commit() {
            _context.SaveChanges();
        }

        SqlRepository<Employee> _employees = null;
        SqlRepository<TimeCard> _timeCards = null;
        readonly ObjectContext _context;
        const string ConnectionStringName = "EmployeeDataModelContainer";
    }
```

### <a name="using-the-custom-repository"></a>Использование пользовательского репозитория

Использование нашего пользовательского репозитория существенно не отличается от использования&lt;&gt;репозитория на основе IObjectSet T . Вместо того, чтобы применять операторы LIN'а непосредственно к свойству, нам сначала нужно вызвать один метод репозитория, чтобы захватить ссылку на I'Eeryable&lt;T.&gt;

``` csharp
    public ViewResult Index() {
        var model = _repository.FindAll()
                               .Include("TimeCards")
                               .OrderBy(e => e.HireDate);
        return View(model);
    }
```

Обратите внимание, пользовательский Оператор Включить мы реализовали ранее будет работать без изменений. Метод FindById репозитория удаляет дублированную логику из действий, пытающихся получить одну сущность.

``` csharp
    public ViewResult Details(int id) {
        var model = _repository.FindById(id);
        return View(model);
    }
```

Существенной разницы в тестируемости двух рассмотренных подходов нет. Мы могли бы предоставить поддельные&lt;реализации IRepository&gt; T&lt;&gt; путем создания конкретных классов при поддержке сотрудника HashSet - так же, как то, что мы сделали в последнем разделе. Однако некоторые разработчики предпочитают использовать макеты объектов и макет объектов, а не строить подделки. Мы рассмотрим использование макетов для проверки нашей реализации и обсуждения различий между макетами и подделками в следующем разделе.

### <a name="testing-with-mocks"></a>Тестирование с помощью моков

Существуют различные подходы к созданию того, что Мартин Фаулер называет "тест-двойником". Тест овый (например, трюк трюк фильм двойной) является объектом, который вы строите, чтобы "стоять в" для реальных, производственных объектов во время испытаний. Созданные нами хранилища в памяти — это тестовые двойники для репозиториев, которые разговаривают с сервером S'L. Мы видели, как использовать эти тестовые двойники во время модульных тестов для изоляции кода и быстрого выполнения тестов.

Тестовые двойники, которые мы создали, имеют реальные рабочие реализации. За кулисами каждый из них хранит конкретную коллекцию объектов, и они будут добавлять и удалять объекты из этой коллекции, как мы манипулируем репозиторий во время теста. Некоторым разработчикам нравится создавать свои тесты в два раза таким образом – с реальным кодом и рабочими реализациями.Эти тест удваивает это то, что мы называем *подделками*. У них есть рабочие реализации, но они не являются достаточно реальными для использования в производстве. Поддельный репозиторий на самом деле не записывается в базу данных. Поддельный сервер SMTP на самом деле не отправить сообщение электронной почты по сети.

### <a name="mocks-versus-fakes"></a>Макеты против подделок

Существует еще один тип теста двойной известный как *макет*. В то время как подделки имеют рабочие реализации, макеты поставляются без реализации. С помощью макета инфраструктуры объекта мы строим эти макетные объекты во время выполнения и используем их в качестве тестового двойника. В этом разделе мы будем использовать платформу с открытым исходным кодом Moq. Вот простой пример использования Moq для динамического создания тестового дубля для репозитория сотрудников.

``` csharp
    Mock<IRepository<Employee>> mock =
        new Mock<IRepository<Employee>>();
    IRepository<Employee> repository = mock.Object;
    repository.Add(new Employee());
    var employee = repository.FindById(1);
```

Мы просим Moq для реализации&lt;&gt; IRepository сотрудника, и он строит один динамически. Мы можем добраться до объекта,&lt;реализующего IRepository Employee,&gt; приостановив доступ к свойству объекта объекта Mock&lt;T.&gt; Именно этот внутренний объект мы можем передать в наши контроллеры, и они не будут знать, если это тест двойной или реальный репозиторий. Мы можем ссылаться на методы на объекте так же, как мы хотели бы вызвать методы на объекте с реальной реализацией.

Вы должны быть удивлены, что макет репозитория будет делать, когда мы ссылаемся на метод добавления. Поскольку за объектом макета нет реализации, Добавить ничего не делает. Существует нет конкретной коллекции за кулисами, как мы имели с подделками мы написали, так что сотрудник отбрасывается. Как насчет возврата стоимости FindById? В этом случае объект макета делает единственное, что он может сделать, то есть вернуть значение по умолчанию. Поскольку мы возвращаем тип ссылки (сотрудник), значение возврата является нулевым значением.

Mocks может показаться бесполезным; однако, есть еще две особенности макетов, о которых мы не говорили. Во-первых, фреймворк Moq записывает все вызовы, сделанные на макет объекта. Позже в коде мы можем спросить Moq, ссылался ли кто-либо на метод добавления, или если кто-то сослался на метод FindById. Мы увидим позже, как мы можем использовать этот "черный ящик" функцию записи в тестах.

Вторая большая особенность заключается в том, как мы можем использовать Moq для программы макет объекта с *ожиданиями*. Ожидание говорит макет объект, как реагировать на любое взаимодействие. Например, мы можем запрограммировать ожидание в наш макет и сказать ему, чтобы вернуть объект сотрудника, когда кто-то вызывает FindById. Для программы этих ожиданий в фрейм-системе Moq используется API Setup API и lambda.

``` csharp
    [TestMethod]
    public void MockSample() {
        Mock<IRepository<Employee>> mock =
            new Mock<IRepository<Employee>>();
        mock.Setup(m => m.FindById(5))
            .Returns(new Employee {Id = 5});
        IRepository<Employee> repository = mock.Object;
        var employee = repository.FindById(5);
        Assert.IsTrue(employee.Id == 5);
    }
```

В этом примере мы просим Moq динамически построить репозиторий, а затем мы программировать репозиторий с ожиданием. Ожидание говорит объекту макета, чтобы вернуть новый объект сотрудника со значением Id 5, когда кто-то вызывает метод FindById, проходящий значение 5. Этот тест проходит, и нам не нужно было строить полную&lt;реализацию, чтобы подделать IRepository T&gt;.

Давайте вернемся к тестам, которые мы писали ранее, и переработаем их, чтобы использовать макеты вместо подделок. Как и раньше, мы будем использовать базовый класс для настройки общих элементов инфраструктуры, необходимых для всех тестов контроллера.

``` csharp
    public class EmployeeControllerTestBase {
        public EmployeeControllerTestBase() {
            _employeeData = EmployeeObjectMother.CreateEmployees()
                                                .AsQueryable();
            _repository = new Mock<IRepository<Employee>>();
            _unitOfWork = new Mock<IUnitOfWork>();
            _unitOfWork.Setup(u => u.Employees)
                       .Returns(_repository.Object);
            _controller = new EmployeeController(_unitOfWork.Object);
        }

        protected IQueryable<Employee> _employeeData;
        protected Mock<IUnitOfWork> _unitOfWork;
        protected EmployeeController _controller;
        protected Mock<IRepository<Employee>> _repository;
    }
```

Код настройки остается в основном неизменным. Вместо того, чтобы использовать подделки, мы будем использовать Moq для построения макет объектов. Базовый класс организует для макет ампорированной единицы работы, чтобы вернуть макет репозитория, когда код вызывает свойство сотрудников. Остальная часть установки макета будет проходить внутри тестовых светильников, посвященных каждому конкретному сценарию. Например, тестовый прибор для действия Индекса настраивает макет репозитория, чтобы вернуть список сотрудников, когда действие вызывает метод FindAll в репозитории макета.

``` csharp
    [TestClass]
    public class EmployeeControllerIndexActionTests
               : EmployeeControllerTestBase {
        public EmployeeControllerIndexActionTests() {
            _repository.Setup(r => r.FindAll())
                        .Returns(_employeeData);
        }
        // .. tests
        [TestMethod]
        public void ShouldBuildModelWithAllEmployees() {
            var result = _controller.Index();
            var model = result.ViewData.Model
                          as IEnumerable<Employee>;
            Assert.IsTrue(model.Count() == _employeeData.Count());
        }
        // .. and more tests
    }
```

За исключением ожиданий, наши тесты похожи на те тесты, которые мы проводили раньше. Однако, с возможностью записи макета фреймворка, мы можем подходить к тестированию под другим углом зрения. Мы рассмотрим эту новую перспективу в следующем разделе.

### <a name="state-versus-interaction-testing"></a>Тестирование состояния против взаимодействия

Существуют различные методы, которые можно использовать для тестирования программного обеспечения с макет объектов. Один из подходов заключается в использовании государственного тестирования, что мы и сделали в настоящем документе до сих пор. Государственное тестирование делает утверждения о состоянии программного обеспечения. В последнем тесте мы сослались на метод действия на контроллере и сделали утверждение о модели, которую он должен построить. Вот некоторые другие примеры состояния тестирования:

-   Проверка репозитория содержит новый объект сотрудника после выполнения Create.
-   Проверка модели содержит список всех сотрудников после выполнения Index.
-   Проверка репозитория не содержит данного сотрудника после выполнения удаления.

Другой подход, который вы увидите с объектами макета, заключается в проверке *взаимодействий.* В то время как тестирование на основе состояния делает утверждения о состоянии объектов, тестирование на основе взаимодействия делает утверждения о том, как объекты взаимодействуют. Пример:

-   Проверка контроллера вызывает метод добавления репозитория при выполнении create.
-   Проверка контроллера вызывает метод FindAll репозитория при выполнении Индекса.
-   Проверка контроллера вызывает блок выполнения блока работы для сохранения изменений при выполнении edit.

Взаимодействие тестирования часто требует меньше тестовых данных, потому что мы не тыкать внутри коллекций и проверки количества. Например, если мы знаем, что действие Детали вызывает метод FindById репозитория с правильным значением - то действие, вероятно, ведет себя правильно. Мы можем проверить это поведение без настройки каких-либо тестовых данных для возвращения из FindById.

``` csharp
    [TestClass]
    public class EmployeeControllerDetailsActionTests
               : EmployeeControllerTestBase {
         // ...
        [TestMethod]
        public void ShouldInvokeRepositoryToFindEmployee() {
            var result = _controller.Details(_detailsId);
            _repository.Verify(r => r.FindById(_detailsId));
        }
        int _detailsId = 1;
    }
```

Единственной установкой, необходимой в вышеуказанном тестовом приборе, является установка, предоставляемая базовым классом. Когда мы ссылаемся на действие контроллера, Moq записывает взаимодействия с репозиторием макета. Используя Verify API Moq, мы можем спросить Moq, если контроллер вызвал FindById с соответствующим значением id. Если контроллер не ссылался на метод или ссылался на метод с неожиданным значением параметра, метод Verify будет завершать и тест не будет.

Вот еще один пример для проверки действия Create вызывает commit на текущей единице работы.

``` csharp
    [TestMethod]
    public void ShouldCommitUnitOfWork() {
        _controller.Create(_newEmployee);
        _unitOfWork.Verify(u => u.Commit());
    }
```

Одной из опасностей при тестировании взаимодействия является тенденция к чрезмерному указанию взаимодействий. Способность макетного объекта записывать и проверять каждое взаимодействие с объектом макета не означает, что тест должен попытаться проверить каждое взаимодействие. Некоторые взаимодействия являются деталями реализации, и вы должны только проверить взаимодействия, *необходимые* для удовлетворения текущего теста.

Выбор между макетами или подделками во многом зависит от системы, которая вы тестируете, и ваших личных (или командных) предпочтений. Объекты Mock могут значительно сократить количество кода, необходимого для реализации тестовых дублера, но не всем комфортно программировать ожидания и проверять взаимодействия.

## <a name="conclusions"></a>Выводы

В этой статье мы продемонстрировали несколько подходов к созданию тестируемого кода при использовании ADO.NET возможностей для сохранения данных. Мы можем использовать встроенные в&lt;абстракции, как IObjectSet T&gt;,&lt;&gt;или создать наши собственные абстракции, как IRepository T .В обоих случаях поддержка POCO в ADO.NET entity Framework 4.0 позволяет потребителям этих абстракций оставаться постоянными невежественным и высоко проверяемыми. Дополнительные функции EF4, такие как неявная ленивая загрузка, позволяют бизнесу и коду обслуживания приложений работать, не беспокоясь о деталях релятивного хранилища данных. Наконец, абстракции, которые мы создаем, легко насмехаются или подделывают внутри модульных тестов, и мы можем использовать эти двойные тесты для достижения быстрой работы, сильно изолированных и надежных тестов.

### <a name="additional-resources"></a>Дополнительные ресурсы

-   Роберт К. Мартин, [«Принцип единой ответственности](https://www.objectmentor.com/resources/articles/srp.pdf)»
-   Мартин Фаулер, [Каталог шаблонов](https://www.martinfowler.com/eaaCatalog/index.html) из *шаблонов архитектуры корпоративных приложений*
-   Гриффин Каприо, " [Инъекции зависимостей](https://msdn.microsoft.com/magazine/cc163739.aspx)"
-   Блог о программируемости данных, « [Прохождение: Разработка тестовых управляемых с помощью Entity Framework 4.0](https://docs.microsoft.com/archive/blogs/adonet/walkthrough-test-driven-development-with-the-entity-framework-4-0)».
-   Блог о программируемости данных, [«Использование репозитория и шаблонов единицы работы с рамками сущности 4.0](https://docs.microsoft.com/archive/blogs/adonet/using-repository-and-unit-of-work-patterns-with-entity-framework-4-0)»
-   Аарон Дженсен, ["Представляем технические характеристики машин"](http://codebetter.com/blogs/aaron.jensen/archive/2008/05/08/introducing-machine-specifications-or-mspec-for-short.aspx)
-   Эрик Ли, ["BDD с MSTest](https://saintgimp.org/2009/01/20/bdd-with-mstest/)"
-   Эрик Эванс, " [Domain Driven Дизайн](https://books.google.com/books?id=7dlaMs0SECsC&printsec=frontcover&dq=evans%20domain%20driven%20design&hl=en&ei=cHztS6C8KIaglAfA_dS1CA&sa=X&oi=book_result&ct=result&resnum=1&ved=0CCoQ6AEwAA)"
-   Мартин Фаулер, ["Мокс не Стубс"](https://martinfowler.com/articles/mocksArentStubs.html)
-   Мартин Фаулер, " [Тест Двойной](https://martinfowler.com/bliki/TestDouble.html)"
-   [Moq](https://code.google.com/p/moq/)

### <a name="biography"></a>Биография

Скотт Аллен (Scott Allen) является членом технического персонала Pluralsight и основателем OdeToCode.com. За 15 лет коммерческой разработки программного обеспечения Скотт работал над решениями для всего, от 8-битных встроенных устройств до высокомасштабируемых ASP.NET веб-приложений. Вы можете связаться со Скоттом в своем блоге [https://twitter.com/OdeToCode](https://twitter.com/OdeToCode)на OdeToCode, или на Twitter в .
