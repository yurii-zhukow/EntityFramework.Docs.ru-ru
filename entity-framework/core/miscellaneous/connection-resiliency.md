---
title: Устойчивость подключения — EF Core
description: Использование устойчивости подключений для автоматического повторного выполнения невыполненных команд с Entity Framework Core
author: rowanmiller
ms.date: 11/15/2016
uid: core/miscellaneous/connection-resiliency
ms.openlocfilehash: 25b754334edd15532780cb4e40682bc211620c76
ms.sourcegitcommit: c0e6a00b64c2dcd8acdc0fe6d1b47703405cdf09
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/24/2020
ms.locfileid: "91210297"
---
# <a name="connection-resiliency"></a>Устойчивость подключений

Устойчивость подключений автоматически повторяет команды базы данных, завершившиеся сбоем. Эту функцию можно использовать с любой базой данных, предоставив «стратегию выполнения», которая инкапсулирует логику, необходимую для обнаружения сбоев и команд повтора. Поставщики EF Core могут предоставлять стратегии выполнения, связанные с конкретными условиями сбоя базы данных и оптимальными политиками повтора.

Например, поставщик SQL Server включает стратегию выполнения, специально адаптированную для SQL Server (включая SQL Azure). Он осведомлен о типах исключений, которые можно повторить, и имеет разумные значения по умолчанию для максимального количества повторных попыток, задержки между повторными попытками и т. д.

Стратегия выполнения указывается при настройке параметров для контекста. Обычно это происходит в `OnConfiguring` методе производного контекста:

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#OnConfiguring)]

или в `Startup.cs` для приложения ASP.NET Core:

``` csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddDbContext<PicnicContext>(
        options => options.UseSqlServer(
            "<connection string>",
            providerOptions => providerOptions.EnableRetryOnFailure()));
}
```

## <a name="custom-execution-strategy"></a>Настраиваемая стратегия выполнения

Существует механизм регистрации пользовательской стратегии выполнения, если вы хотите изменить какие-либо значения по умолчанию.

``` csharp
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder
        .UseMyProvider(
            "<connection string>",
            options => options.ExecutionStrategy(...));
}
```

## <a name="execution-strategies-and-transactions"></a>Стратегии и транзакции выполнения

Стратегия выполнения, которая автоматически повторяет попытки сбоев, должна иметь возможность воспроизводить каждую операцию в блоке повтора, которая завершается ошибкой. Если повторные попытки включены, каждая операция, выполняемая с помощью EF Core, станет собственной операцией возможностью повторной попытки. Это значит, что каждый запрос и каждый вызов `SaveChanges()` будет выполняться повторно как единица при возникновении временного сбоя.

Однако, если код инициирует транзакцию с помощью, `BeginTransaction()` вы определяете собственную группу операций, которую необходимо рассматривать как единую единицу, и все, что необходимо в рамках транзакции, должны быть воспроизведены, если произойдет сбой. При попытке сделать это при использовании стратегии выполнения вы получите исключение, аналогичное приведенному ниже.

> InvalidOperationException: настроенная стратегия выполнения "Склсерверретринжексекутионстратеги" не поддерживает инициированные пользователем транзакции. Используйте стратегию выполнения, возвращенную 'DbContext.Database.CreateExecutionStrategy()', чтобы выполнить все операции в транзакции как повторяемую единицу.

Решение заключается в том, чтобы вручную вызвать стратегию выполнения с делегатом, представляющим все, что необходимо выполнить. В случае временного сбоя стратегия выполнения будет снова вызывать делегат.

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#ManualTransaction)]

Этот подход также можно использовать с внешними транзакциями.

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#AmbientTransaction)]

## <a name="transaction-commit-failure-and-the-idempotency-issue"></a>Сбой фиксации транзакции и проблема идемпотентности

Как правило, при сбое соединения выполняется откат текущей транзакции. Однако, если соединение разорвано во время фиксации транзакции, результирующее состояние транзакции неизвестно. 

По умолчанию стратегия выполнения повторяет операцию, как если бы был выполнен откат транзакции, но если это не так, это приведет к возникновению исключения, если новое состояние базы данных несовместимо или может привести к **повреждению данных** , если операция не зависит от определенного состояния, например при вставке новой строки с автоматически созданными значениями ключа.

Существует несколько способов решения этой проблемы.

### <a name="option-1---do-almost-nothing"></a>Вариант 1-Do (почти) Nothing

Вероятность сбоя подключения во время фиксации транзакции мала, поэтому приложение может быть вполне неудачным, если это условие действительно происходит.

Однако необходимо избегать использования созданных хранилищем ключей, чтобы гарантировать, что вместо добавления повторяющейся строки создается исключение. Рассмотрите возможность использования генерируемого клиентом значения GUID или генератора значений на стороне клиента.

### <a name="option-2---rebuild-application-state"></a>Вариант 2. Перестроение состояния приложения

1. Удаление текущего `DbContext` .
2. Создайте новое `DbContext` и восстановите состояние приложения из базы данных.
3. Сообщите пользователю о том, что последняя операция могла завершиться неудачно.

### <a name="option-3---add-state-verification"></a>Вариант 3. Проверка добавления состояния

Для большинства операций, изменяющих состояние базы данных, можно добавить код, который проверяет, была ли она успешной. EF предоставляет метод расширения для упрощения этого `IExecutionStrategy.ExecuteInTransaction` .

Этот метод начинает и фиксирует транзакцию, а также принимает функцию в `verifySucceeded` параметре, который вызывается при возникновении временной ошибки во время фиксации транзакции.

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#Verification)]

> [!NOTE]
> Здесь `SaveChanges` вызывается с `acceptAllChangesOnSuccess` параметром, чтобы `false` избежать изменения состояния `Blog` сущности на, если она `Unchanged` `SaveChanges` выполнена. Это позволяет повторить ту же операцию в случае сбоя фиксации и отката транзакции.

### <a name="option-4---manually-track-the-transaction"></a>Вариант 4. Отслеживание транзакции вручную

Если необходимо использовать созданные хранилищем ключи или требуется универсальный способ обработки ошибок фиксации, которые не зависят от выполняемой операции, можно назначить идентификатор, который проверяется при сбое фиксации.

1. Добавьте таблицу в базу данных, используемую для наблюдения за состоянием транзакций.
2. Вставка строки в таблицу в начале каждой транзакции.
3. В случае сбоя соединения во время фиксации проверьте наличие соответствующей строки в базе данных.
4. Если фиксация прошла успешно, удалите соответствующую строку, чтобы избежать роста таблицы.

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#Tracking)]

> [!NOTE]
> Убедитесь, что контекст, используемый для проверки, имеет стратегию выполнения, определенную, так как соединение, скорее всего, снова завершится сбоем во время проверки, если оно завершилось сбоем во время фиксации транзакции.

## <a name="additional-resources"></a>Дополнительные ресурсы

* [Устранение временных ошибок подключения в базе данных SQL Azure и SQL Управляемый экземпляр](/azure/azure-sql/database/troubleshoot-common-connectivity-issues)
