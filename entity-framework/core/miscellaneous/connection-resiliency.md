---
title: Устойчивость подключения — EF Core
author: rowanmiller
ms.date: 11/15/2016
ms.assetid: e079d4af-c455-4a14-8e15-a8471516d748
uid: core/miscellaneous/connection-resiliency
ms.openlocfilehash: 07646e6ead845c38537945a03367ac7f50784236
ms.sourcegitcommit: cc0ff36e46e9ed3527638f7208000e8521faef2e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78414137"
---
# <a name="connection-resiliency"></a>Устойчивость подключений

Устойчивость подключений автоматически повторяет команды базы данных, завершившиеся сбоем. Эту функцию можно использовать с любой базой данных, предоставив «стратегию выполнения», которая инкапсулирует логику, необходимую для обнаружения сбоев и команд повтора. Поставщики EF Core могут предоставлять стратегии выполнения, связанные с конкретными условиями сбоя базы данных и оптимальными политиками повтора.

Например, поставщик SQL Server включает стратегию выполнения, специально адаптированную для SQL Server (включая SQL Azure). Он осведомлен о типах исключений, которые можно повторить, и имеет разумные значения по умолчанию для максимального количества повторных попыток, задержки между повторными попытками и т. д.

Стратегия выполнения указывается при настройке параметров для контекста. Обычно это происходит в методе `OnConfiguring` производном контексте:

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#OnConfiguring)]

или в `Startup.cs` для ASP.NET Core приложения:

``` csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddDbContext<PicnicContext>(
        options => options.UseSqlServer(
            "<connection string>",
            providerOptions => providerOptions.EnableRetryOnFailure()));
}
```

## <a name="custom-execution-strategy"></a>Настраиваемая стратегия выполнения

Существует механизм регистрации пользовательской стратегии выполнения, если вы хотите изменить какие-либо значения по умолчанию.

``` csharp
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder
        .UseMyProvider(
            "<connection string>",
            options => options.ExecutionStrategy(...));
}
```

## <a name="execution-strategies-and-transactions"></a>Стратегии и транзакции выполнения

Стратегия выполнения, которая автоматически повторяет попытки сбоев, должна иметь возможность воспроизводить каждую операцию в блоке повтора, которая завершается ошибкой. Если повторные попытки включены, каждая операция, выполняемая с помощью EF Core, станет собственной операцией возможностью повторной попытки. То есть каждый запрос и каждый вызов `SaveChanges()` будут повторены в качестве единицы при возникновении временного сбоя.

Однако, если код инициирует транзакцию с помощью `BeginTransaction()` вы определяете собственную группу операций, которую необходимо рассматривать как единую единицу, и все, что необходимо в рамках транзакции, должны быть воспроизведены, если это произойдет сбой. При попытке сделать это при использовании стратегии выполнения вы получите исключение, аналогичное приведенному ниже.

> InvalidOperationException: настроенная стратегия выполнения "Склсерверретринжексекутионстратеги" не поддерживает инициированные пользователем транзакции. Используйте стратегию выполнения, возвращенную 'DbContext.Database.CreateExecutionStrategy()', чтобы выполнить все операции в транзакции как повторяемую единицу.

Решение заключается в том, чтобы вручную вызвать стратегию выполнения с делегатом, представляющим все, что необходимо выполнить. Если происходит временный сбой, стратегия выполнения снова вызывает делегат.

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#ManualTransaction)]

Этот подход также можно использовать с внешними транзакциями.

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#AmbientTransaction)]

## <a name="transaction-commit-failure-and-the-idempotency-issue"></a>Сбой фиксации транзакции и проблема идемпотентности

Как правило, при сбое соединения выполняется откат текущей транзакции. Однако, если соединение разорвано во время фиксации транзакции, результирующее состояние транзакции неизвестно. 

По умолчанию стратегия выполнения повторяет операцию, как если бы был выполнен откат транзакции, но если это не так, это приведет к возникновению исключения, если новое состояние базы данных несовместимо или может привести к **повреждению данных** , если операция не зависит от определенного состояния, например при вставке новой строки с автоматически созданными значениями ключа.

Существует несколько способов решения этой проблемы.

### <a name="option-1---do-almost-nothing"></a>Вариант 1-Do (почти) Nothing

Вероятность сбоя подключения во время фиксации транзакции мала, поэтому приложение может быть вполне неудачным, если это условие действительно происходит.

Однако необходимо избегать использования созданных хранилищем ключей, чтобы гарантировать, что вместо добавления повторяющейся строки создается исключение. Рассмотрите возможность использования генерируемого клиентом значения GUID или генератора значений на стороне клиента.

### <a name="option-2---rebuild-application-state"></a>Вариант 2. Перестроение состояния приложения

1. Отменить текущую `DbContext`.
2. Создайте новый `DbContext` и восстановите состояние приложения из базы данных.
3. Сообщите пользователю о том, что последняя операция могла завершиться неудачно.

### <a name="option-3---add-state-verification"></a>Вариант 3. Проверка добавления состояния

Для большинства операций, изменяющих состояние базы данных, можно добавить код, который проверяет, была ли она успешной. EF предоставляет метод расширения для упрощения `IExecutionStrategy.ExecuteInTransaction`.

Этот метод начинает и фиксирует транзакцию, а также принимает функцию в `verifySucceeded` параметр, который вызывается при возникновении временной ошибки во время фиксации транзакции.

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#Verification)]

> [!NOTE]
> Здесь `SaveChanges` вызывается с `acceptAllChangesOnSuccess` установленным в значение `false`, чтобы избежать изменения состояния сущности `Blog` на `Unchanged`, если `SaveChanges` выполняется. Это позволяет повторить ту же операцию в случае сбоя фиксации и отката транзакции.

### <a name="option-4---manually-track-the-transaction"></a>Вариант 4. Отслеживание транзакции вручную

Если необходимо использовать созданные хранилищем ключи или требуется универсальный способ обработки ошибок фиксации, которые не зависят от выполняемой операции, можно назначить идентификатор, который проверяется при сбое фиксации.

1. Добавьте таблицу в базу данных, используемую для наблюдения за состоянием транзакций.
2. Вставка строки в таблицу в начале каждой транзакции.
3. В случае сбоя соединения во время фиксации проверьте наличие соответствующей строки в базе данных.
4. Если фиксация прошла успешно, удалите соответствующую строку, чтобы избежать роста таблицы.

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#Tracking)]

> [!NOTE]
> Убедитесь, что контекст, используемый для проверки, имеет стратегию выполнения, определенную, так как соединение, скорее всего, снова завершится сбоем во время проверки, если оно завершилось сбоем во время фиксации транзакции.
