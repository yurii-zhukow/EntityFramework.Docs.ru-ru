---
title: Работа с ссылочными типами, допускающими значение NULL — EF Core
description: Работа с ссылочными типами C#, допускающими значение null, при использовании Entity Framework Core
author: roji
ms.date: 09/09/2019
uid: core/miscellaneous/nullable-reference-types
ms.openlocfilehash: 749fef8560c6777dcb2314126b11d2dd6a3562f8
ms.sourcegitcommit: 032a1767d7a6e42052a005f660b80372c6521e7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/12/2021
ms.locfileid: "98128567"
---
# <a name="working-with-nullable-reference-types"></a><span data-ttu-id="9c2d0-103">Работа с ссылочными типами, допускающими значение null</span><span class="sxs-lookup"><span data-stu-id="9c2d0-103">Working with Nullable Reference Types</span></span>

<span data-ttu-id="9c2d0-104">В C# 8 появилась новая функция, именуемая [ссылочными типами, допускающими значение null (превентивной)](/dotnet/csharp/tutorials/nullable-reference-types), что позволяет создавать заметки для ссылочных типов, указывая, является ли он допустимым для того, чтобы они содержали значение null.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-104">C# 8 introduced a new feature called [nullable reference types (NRT)](/dotnet/csharp/tutorials/nullable-reference-types), allowing reference types to be annotated, indicating whether it is valid for them to contain null or not.</span></span> <span data-ttu-id="9c2d0-105">Если вы не знакомы с этой функцией, рекомендуется ознакомиться с ней, прочитав документацию по C#.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-105">If you are new to this feature, it is recommended that make yourself familiar with it by reading the C# docs.</span></span>

<span data-ttu-id="9c2d0-106">На этой странице EF Core вводится поддержка ссылочных типов, допускающих значения NULL, и приводятся рекомендации по работе с ними.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-106">This page introduces EF Core's support for nullable reference types, and describes best practices for working with them.</span></span>

## <a name="required-and-optional-properties"></a><span data-ttu-id="9c2d0-107">Обязательные и необязательные свойства</span><span class="sxs-lookup"><span data-stu-id="9c2d0-107">Required and optional properties</span></span>

<span data-ttu-id="9c2d0-108">Основная документация по обязательным и дополнительным свойствам и их взаимодействию с ссылочными типами, допускающими значение null, — это [обязательная и необязательная страница свойств](xref:core/modeling/entity-properties#required-and-optional-properties) .</span><span class="sxs-lookup"><span data-stu-id="9c2d0-108">The main documentation on required and optional properties and their interaction with nullable reference types is the [Required and Optional Properties](xref:core/modeling/entity-properties#required-and-optional-properties) page.</span></span> <span data-ttu-id="9c2d0-109">Для начала рекомендуется сначала прочитать эту страницу.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-109">It is recommended you start out by reading that page first.</span></span>

> [!NOTE]
> <span data-ttu-id="9c2d0-110">Соблюдайте осторожность при включении ссылочных типов, допускающих значение null, в существующем проекте: свойства ссылочного типа, которые ранее были настроены как необязательные, теперь будут настроены как обязательные, если только они не имеют явно заметку null.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-110">Exercise caution when enabling nullable reference types on an existing project: reference type properties which were previously configured as optional will now be configured as required, unless they are explicitly annotated to be nullable.</span></span> <span data-ttu-id="9c2d0-111">При управлении схемой реляционной базы данных это может привести к созданию миграции, которые изменяют допустимость значений NULL в столбце базы данных.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-111">When managing a relational database schema, this may cause migrations to be generated which alter the database column's nullability.</span></span>

## <a name="non-nullable-properties-and-initialization"></a><span data-ttu-id="9c2d0-112">Свойства и инициализация, не допускающая значения NULL</span><span class="sxs-lookup"><span data-stu-id="9c2d0-112">Non-nullable properties and initialization</span></span>

<span data-ttu-id="9c2d0-113">Если ссылочные типы, допускающие значение null, включены, компилятор C# выдает предупреждения для любого неинициализированного свойства, не допускающего значения NULL, так как они будут содержать значение null.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-113">When nullable reference types are enabled, the C# compiler emits warnings for any uninitialized non-nullable property, as these would contain null.</span></span> <span data-ttu-id="9c2d0-114">В результате нельзя использовать следующий стандартный способ написания типов сущностей:</span><span class="sxs-lookup"><span data-stu-id="9c2d0-114">As a result, the following, common way of writing entity types cannot be used:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/CustomerWithWarning.cs?name=CustomerWithWarning&highlight=4-5)]

<span data-ttu-id="9c2d0-115">[Привязка конструктора](xref:core/modeling/constructors) — это полезный метод, гарантирующий, что свойства, не допускающие значения NULL, будут инициализированы:</span><span class="sxs-lookup"><span data-stu-id="9c2d0-115">[Constructor binding](xref:core/modeling/constructors) is a useful technique to ensure that your non-nullable properties are initialized:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/CustomerWithConstructorBinding.cs?name=CustomerWithConstructorBinding&highlight=6-9)]

<span data-ttu-id="9c2d0-116">К сожалению, в некоторых сценариях привязка конструктора не является вариантом; Например, свойства навигации не могут быть инициализированы таким образом.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-116">Unfortunately, in some scenarios constructor binding isn't an option; navigation properties, for example, cannot be initialized in this way.</span></span>

<span data-ttu-id="9c2d0-117">Обязательные свойства навигации представляют дополнительную сложность: Несмотря на то, что зависимый объект всегда будет существовать для данного участника, он может быть или не загружен определенным запросом в зависимости от потребностей в этой точке программы (см.[различные шаблоны для загрузки данных](xref:core/querying/related-data)).</span><span class="sxs-lookup"><span data-stu-id="9c2d0-117">Required navigation properties present an additional difficulty: although a dependent will always exist for a given principal, it may or may not be loaded by a particular query, depending on the needs at that point in the program ([see the different patterns for loading data](xref:core/querying/related-data)).</span></span> <span data-ttu-id="9c2d0-118">В то же время нежелательно делать эти свойства допускающими значение null, так как это приведет к тому, что все права доступа к ним будут проверять наличие значения NULL, даже если они требуются.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-118">At the same time, it is undesirable to make these properties nullable, since that would force all access to them to check for null, even if they are required.</span></span>

<span data-ttu-id="9c2d0-119">Одним из способов решения этих сценариев является наличие свойства, не допускающего значения NULL, с [резервным полем](xref:core/modeling/backing-field), допускающим значение null.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-119">One way to deal with these scenarios, is to have a non-nullable property with a nullable [backing field](xref:core/modeling/backing-field):</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Order.cs?range=10-17)]

<span data-ttu-id="9c2d0-120">Так как свойство навигации не допускает значения NULL, необходимо настроить требуемую навигацию. и при условии, что Навигация правильно загружена, зависимый объект будет доступен через свойство.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-120">Since the navigation property is non-nullable, a required navigation is configured; and as long as the navigation is properly loaded, the dependent will be accessible via the property.</span></span> <span data-ttu-id="9c2d0-121">Однако если доступ к свойству осуществляется без предварительной загрузки связанной сущности, создается исключение InvalidOperationException, так как контракт API используется неправильно.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-121">If, however, the property is accessed without first properly loading the related entity, an InvalidOperationException is thrown, since the API contract has been used incorrectly.</span></span> <span data-ttu-id="9c2d0-122">Обратите внимание, что EF должен быть настроен так, чтобы всегда обращаться к резервному полю, а не к свойству, так как оно зависит от возможности чтения значения даже при неопределенном значении. сведения о том, как это сделать, см. в документации по [резервным полям](xref:core/modeling/backing-field) , а также о `PropertyAccessMode.Field` том, чтобы убедиться, что конфигурация правильная.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-122">Note that EF must be configured to always access the backing field and not the property, as it relies on being able to read the value even when unset; consult the documentation on [backing fields](xref:core/modeling/backing-field) on how to do this, and consider specifying `PropertyAccessMode.Field` to make sure the configuration is correct.</span></span>

<span data-ttu-id="9c2d0-123">В качестве более сжатого альтернативного варианта можно просто инициализировать свойство значением NULL с помощью оператора NULL-терпим отношению (!):</span><span class="sxs-lookup"><span data-stu-id="9c2d0-123">As a terser alternative, it is possible to simply initialize the property to null with the help of the null-forgiving operator (!):</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Order.cs?range=19)]

<span data-ttu-id="9c2d0-124">Фактическое значение NULL не будет наблюдаться, за исключением случая программной ошибки, например при доступе к свойству навигации без правильной загрузки связанной сущности заранее.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-124">An actual null value will never be observed except as a result of a programming bug, e.g. accessing the navigation property without properly loading the related entity beforehand.</span></span>

> [!NOTE]
> <span data-ttu-id="9c2d0-125">Переходы по коллекциям, которые содержат ссылки на несколько связанных сущностей, всегда должны быть не допускать значения NULL.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-125">Collection navigations, which contain references to multiple related entities, should always be non-nullable.</span></span> <span data-ttu-id="9c2d0-126">Пустая коллекция означает, что связанные сущности не существуют, но сам список никогда не должен иметь значение null.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-126">An empty collection means that no related entities exist, but the list itself should never be null.</span></span>

## <a name="dbcontext-and-dbset"></a><span data-ttu-id="9c2d0-127">DbContext и DbSet</span><span class="sxs-lookup"><span data-stu-id="9c2d0-127">DbContext and DbSet</span></span>

<span data-ttu-id="9c2d0-128">Распространенная практика использования неинициализированных свойств DbSet в типах контекста также проблематична, так как компилятор выдаст для них предупреждения.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-128">The common practice of having uninitialized DbSet properties on context types is also problematic, as the compiler will now emit warnings for them.</span></span> <span data-ttu-id="9c2d0-129">Это можно исправить следующим образом.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-129">This can be fixed as follows:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/NullableReferenceTypesContext.cs?name=Context&highlight=3-4)]

<span data-ttu-id="9c2d0-130">Другой стратегией является использование автосвойств, не допускающих значения NULL, но для инициализации их в NULL с помощью оператора NULL-терпим отношению (!), чтобы не выводить предупреждение компилятора.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-130">Another strategy is to use non-nullable auto-properties, but to initialize them to null, using the null-forgiving operator (!) to silence the compiler warning.</span></span> <span data-ttu-id="9c2d0-131">Базовый конструктор DbContext гарантирует, что все свойства DbSet будут инициализированы, и на них не будет наблюдаться значение null.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-131">The DbContext base constructor ensures that all DbSet properties will get initialized, and null will never be observed on them.</span></span>

## <a name="navigating-and-including-nullable-relationships"></a><span data-ttu-id="9c2d0-132">Навигация и включение отношений, допускающих значение null</span><span class="sxs-lookup"><span data-stu-id="9c2d0-132">Navigating and including nullable relationships</span></span>

<span data-ttu-id="9c2d0-133">При работе с необязательными связями можно столкнуться с предупреждениями компилятора, в которых фактическое исключение пустой ссылки было бы невозможно.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-133">When dealing with optional relationships, it's possible to encounter compiler warnings where an actual null reference exception would be impossible.</span></span> <span data-ttu-id="9c2d0-134">При преобразовании и выполнении запросов LINQ EF Core гарантирует, что если необязательная связанная сущность не существует, любую навигацию для нее просто пропускается, а не создается.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-134">When translating and executing your LINQ queries, EF Core guarantees that if an optional related entity does not exist, any navigation to it will simply be ignored, rather than throwing.</span></span> <span data-ttu-id="9c2d0-135">Однако компилятор не знает об этой EF Core гарантии и выдает предупреждения, как если бы запрос LINQ выполнялся в памяти, с LINQ to Objects.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-135">However, the compiler is unaware of this EF Core guarantee, and produces warnings as if the LINQ query were executed in memory, with LINQ to Objects.</span></span> <span data-ttu-id="9c2d0-136">Поэтому необходимо использовать оператор NULL-терпим отношению (!) для информирования компилятора о том, что фактическое значение NULL невозможно:</span><span class="sxs-lookup"><span data-stu-id="9c2d0-136">As a result, it is necessary to use the null-forgiving operator (!) to inform the compiler that an actual null value isn't possible:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Program.cs?range=46)]

<span data-ttu-id="9c2d0-137">Аналогичная проблема возникает при включении нескольких уровней связей в необязательные переходы:</span><span class="sxs-lookup"><span data-stu-id="9c2d0-137">A similar issue occurs when including multiple levels of relationships across optional navigations:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Program.cs?range=36-39&highlight=2)]

<span data-ttu-id="9c2d0-138">Если вы считаете, что сделали это очень много, и рассматриваемые типы сущностей являются преимущественно (или исключительно), используемыми в запросах EF Core, рассмотрите возможность создания свойств навигации, не допускающих значения NULL, и настройки их как необязательных через API-интерфейс или заметки к данным.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-138">If you find yourself doing this a lot, and the entity types in question are predominantly (or exclusively) used in EF Core queries, consider making the navigation properties non-nullable, and to configure them as optional via the Fluent API or Data Annotations.</span></span> <span data-ttu-id="9c2d0-139">Это приведет к удалению всех предупреждений компилятора, сохраняя связь необязательной. Однако если сущности обходятся за пределами EF Core, можно заметить значения NULL, хотя свойства записываются как не допускающие значения NULL.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-139">This will remove all compiler warnings while keeping the relationship optional; however, if your entities are traversed outside of EF Core, you may observe null values although the properties are annotated as non-nullable.</span></span>

## <a name="limitations"></a><span data-ttu-id="9c2d0-140">Ограничения</span><span class="sxs-lookup"><span data-stu-id="9c2d0-140">Limitations</span></span>

* <span data-ttu-id="9c2d0-141">В настоящее время реконструирование не поддерживает [Ссылочные типы C# 8 Nullable (НРТС)](/dotnet/csharp/tutorials/nullable-reference-types): EF Core всегда создает код c#, который предполагает, что эта функция отключена.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-141">Reverse engineering does not currently support [C# 8 nullable reference types (NRTs)](/dotnet/csharp/tutorials/nullable-reference-types): EF Core always generates C# code that assumes the feature is off.</span></span> <span data-ttu-id="9c2d0-142">Например, столбцы с текстом, допускающими значение null, будут формироваться в виде свойства с типом `string` , а не `string?` с помощью API-интерфейса Fluent или заметок к данным, используемых для настройки того, является ли свойство обязательным.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-142">For example, nullable text columns will be scaffolded as a property with type `string` , not `string?`, with either the Fluent API or Data Annotations used to configure whether a property is required or not.</span></span> <span data-ttu-id="9c2d0-143">Вы можете изменить сформированный код и заменить их на метки допустимости значений NULL в C#.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-143">You can edit the scaffolded code and replace these with C# nullability annotations.</span></span> <span data-ttu-id="9c2d0-144">Поддержка формирования шаблонов для ссылочных типов, допускающих значения NULL, ведется по выпуску [#15520](https://github.com/dotnet/efcore/issues/15520).</span><span class="sxs-lookup"><span data-stu-id="9c2d0-144">Scaffolding support for nullable reference types is tracked by issue [#15520](https://github.com/dotnet/efcore/issues/15520).</span></span>
* <span data-ttu-id="9c2d0-145">У поверхности общедоступного API EF Core еще нет аннотации для допустимости значений NULL (общедоступный API — "null-очевидным"), что иногда может оказаться неудобным для использования при включенной функции ПРЕВЕНТИВНОЙ.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-145">EF Core's public API surface has not yet been annotated for nullability (the public API is "null-oblivious"), making it sometimes awkward to use when the NRT feature is turned on.</span></span> <span data-ttu-id="9c2d0-146">Это особенно относится к асинхронным операторам LINQ, предоставляемым EF Core, таким как [фирстордефаултасинк](/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.firstordefaultasync#Microsoft_EntityFrameworkCore_EntityFrameworkQueryableExtensions_FirstOrDefaultAsync__1_System_Linq_IQueryable___0__System_Linq_Expressions_Expression_System_Func___0_System_Boolean___System_Threading_CancellationToken_).</span><span class="sxs-lookup"><span data-stu-id="9c2d0-146">This notably includes the async LINQ operators exposed by EF Core, such as [FirstOrDefaultAsync](/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.firstordefaultasync#Microsoft_EntityFrameworkCore_EntityFrameworkQueryableExtensions_FirstOrDefaultAsync__1_System_Linq_IQueryable___0__System_Linq_Expressions_Expression_System_Func___0_System_Boolean___System_Threading_CancellationToken_).</span></span> <span data-ttu-id="9c2d0-147">Мы планируем устранить эту эту необходимость в выпуске 6,0.</span><span class="sxs-lookup"><span data-stu-id="9c2d0-147">We plan to address this for the 6.0 release.</span></span>
