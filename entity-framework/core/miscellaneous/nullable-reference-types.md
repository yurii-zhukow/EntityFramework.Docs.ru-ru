---
title: Работа с ссылочными типами, допускающими значение NULL — EF Core
author: roji
ms.date: 09/09/2019
ms.assetid: bde4e0ee-fba3-4813-a849-27049323d301
uid: core/miscellaneous/nullable-reference-types
ms.openlocfilehash: 3acd446d64a94ffecb12c181e3910528d2293448
ms.sourcegitcommit: 51148929e3889c48227d96c95c4e310d53a3d2c9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/21/2020
ms.locfileid: "86873361"
---
# <a name="working-with-nullable-reference-types"></a>Работа с ссылочными типами, допускающими значение null

В C# 8 появилась новая функция, именуемая [ссылочными типами, допускающими значение NULL](/dotnet/csharp/tutorials/nullable-reference-types), которая позволяет создавать заметки для ссылочных типов, указывающих, является ли он допустимым для того, чтобы они содержали значение null. Если вы не знакомы с этой функцией, рекомендуется ознакомиться с ней, прочитав документацию по C#.

На этой странице EF Core вводится поддержка ссылочных типов, допускающих значения NULL, и приводятся рекомендации по работе с ними.

## <a name="required-and-optional-properties"></a>Обязательные и необязательные свойства

Основная документация по обязательным и дополнительным свойствам и их взаимодействию с ссылочными типами, допускающими значение null, — это [обязательная и необязательная страница свойств](xref:core/modeling/entity-properties#required-and-optional-properties) . Для начала рекомендуется сначала прочитать эту страницу.

> [!NOTE]
> Соблюдайте осторожность при включении ссылочных типов, допускающих значение null, в существующем проекте: свойства ссылочного типа, которые ранее были настроены как необязательные, теперь будут настроены как обязательные, если только они не имеют явно заметку null. При управлении схемой реляционной базы данных это может привести к созданию миграции, которые изменяют допустимость значений NULL в столбце базы данных.

## <a name="dbcontext-and-dbset"></a>DbContext и DbSet

Если ссылочные типы, допускающие значение null, включены, компилятор C# выдает предупреждения для любого неинициализированного свойства, не допускающего значения NULL, так как они будут содержать значение null. В результате, как правило, при наличии неинициализированных свойств DbSet в контексте типа будет выдаваться предупреждение. Чтобы устранить эту проблему, сделайте свойства DbSet свойствами только для чтения и инициализируйте их следующим образом:

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/NullableReferenceTypesContext.cs?name=Context&highlight=3-4)]

## <a name="non-nullable-properties-and-initialization"></a>Свойства и инициализация, не допускающая значения NULL

Предупреждения компилятора для неинициализированных ссылочных типов также являются проблемой для обычных свойств типов сущностей. В нашем примере мы исключаем эти предупреждения с помощью [привязки конструктора](xref:core/modeling/constructors), функции, которая идеально подходит для свойств, не допускающих значения NULL, гарантируя, что они всегда инициализированы. Однако в некоторых сценариях привязка конструктора не является вариантом: свойства навигации, например, не могут быть инициализированы таким образом.

Обязательные свойства навигации представляют дополнительную сложность: Несмотря на то, что зависимый объект всегда будет существовать для данного участника, он может быть или не загружен определенным запросом в зависимости от потребностей в этой точке программы (см.[различные шаблоны для загрузки данных](xref:core/querying/related-data)). В то же время нежелательно делать эти свойства допускающими значение null, так как это приведет к тому, что все права доступа к ним будут проверять наличие значения NULL, даже если они требуются.

Одним из способов решения этих сценариев является наличие свойства, не допускающего значения NULL, с [резервным полем](xref:core/modeling/backing-field), допускающим значение null.

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Order.cs?range=10-17)]

Так как свойство навигации не допускает значения NULL, необходимо настроить требуемую навигацию. и при условии, что Навигация правильно загружена, зависимый объект будет доступен через свойство. Однако если доступ к свойству осуществляется без предварительной загрузки связанной сущности, создается исключение InvalidOperationException, так как контракт API используется неправильно. Обратите внимание, что EF должен быть настроен так, чтобы всегда обращаться к резервному полю, а не к свойству, так как оно зависит от возможности чтения значения даже при неопределенном значении. сведения о том, как это сделать, см. в документации по [резервным полям](xref:core/modeling/backing-field) , а также о `PropertyAccessMode.Field` том, чтобы убедиться, что конфигурация правильная.

В качестве более сжатого альтернативного варианта можно просто инициализировать свойство значением NULL с помощью оператора NULL-терпим отношению (!):

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Order.cs?range=19)]

Фактическое значение NULL не будет наблюдаться, за исключением случая программной ошибки, например при доступе к свойству навигации без правильной загрузки связанной сущности заранее.

> [!NOTE]
> Переходы по коллекциям, которые содержат ссылки на несколько связанных сущностей, всегда должны быть не допускать значения NULL. Пустая коллекция означает, что связанные сущности не существуют, но сам список никогда не должен иметь значение null.

## <a name="navigating-and-including-nullable-relationships"></a>Навигация и включение отношений, допускающих значение null

При работе с необязательными связями можно столкнуться с предупреждениями компилятора, в которых фактическое исключение пустой ссылки было бы невозможно. При преобразовании и выполнении запросов LINQ EF Core гарантирует, что если необязательная связанная сущность не существует, любую навигацию для нее просто пропускается, а не создается. Однако компилятор не знает об этой EF Core гарантии и выдает предупреждения, как если бы запрос LINQ выполнялся в памяти, с LINQ to Objects. Поэтому необходимо использовать оператор NULL-терпим отношению (!) для информирования компилятора о том, что фактическое значение NULL невозможно:

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Program.cs?range=46)]

Аналогичная проблема возникает при включении нескольких уровней связей в необязательные переходы:

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Program.cs?range=36-39&highlight=2)]

Если вы считаете, что сделали это очень много, и рассматриваемые типы сущностей являются преимущественно (или исключительно), используемыми в запросах EF Core, рассмотрите возможность создания свойств навигации, не допускающих значения NULL, и настройки их как необязательных через API-интерфейс или заметки к данным. Это приведет к удалению всех предупреждений компилятора, сохраняя связь необязательной. Однако если сущности обходятся за пределами EF Core, можно заметить значения NULL, хотя свойства записываются как не допускающие значения NULL.

## <a name="limitations"></a>Ограничения

* В настоящее время реконструирование не поддерживает [Ссылочные типы C# 8 Nullable (НРТС)](/dotnet/csharp/tutorials/nullable-reference-types): EF Core всегда создает код c#, который предполагает, что эта функция отключена. Например, столбцы с текстом, допускающими значение null, будут формироваться в виде свойства с типом `string` , а не `string?` с помощью API-интерфейса Fluent или заметок к данным, используемых для настройки того, является ли свойство обязательным. Вы можете изменить сформированный код и заменить их на метки допустимости значений NULL в C#. Поддержка формирования шаблонов для ссылочных типов, допускающих значения NULL, ведется по выпуску [#15520](https://github.com/aspnet/EntityFrameworkCore/issues/15520).
* У поверхности общедоступного API EF Core еще нет аннотации для допустимости значений NULL (общедоступный API — "null-очевидным"), что иногда может оказаться неудобным для использования при включенной функции ПРЕВЕНТИВНОЙ. Это особенно относится к асинхронным операторам LINQ, предоставляемым EF Core, таким как [фирстордефаултасинк](/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.firstordefaultasync#Microsoft_EntityFrameworkCore_EntityFrameworkQueryableExtensions_FirstOrDefaultAsync__1_System_Linq_IQueryable___0__System_Linq_Expressions_Expression_System_Func___0_System_Boolean___System_Threading_CancellationToken_). Мы планируем устранить эту эту необходимость в выпуске 5,0.
