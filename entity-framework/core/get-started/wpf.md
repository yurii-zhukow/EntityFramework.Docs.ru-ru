---
title: Начало работы с WPF — EF Core
description: Руководство по началу работы с WPF с использованием Entity Framework Core
author: jeremylikness
ms.author: jeliknes
ms.date: 07/24/2020
uid: core/get-started/wpf
ms.openlocfilehash: f183064fafbe2d0e7b8dbdafa921169afc9ffe78
ms.sourcegitcommit: f3512e3a98e685a3ba409c1d0157ce85cc390cf4
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2020
ms.locfileid: "94429927"
---
# <a name="getting-started-with-wpf"></a>Начало работы с WPF

В этом пошаговом руководстве показано, как привязать типы POCO к элементам управления WPF в форме "Основное — сведения". Приложение использует API-интерфейсы Entity Framework для заполнения объектов данными из базы данных, трассировки изменений и сохранения данных в базе данных.

Модель определяет два типа, которые участвуют в связи "один ко многим": **Category** (principal\\main) и **Product** (dependent\\detail). Платформа привязки данных WPF позволяет переходить между связанными объектами: выбор строки в главном представлении приводит к обновлению подробного представления соответствующими данными дочернего объекта.

Снимки экрана и листинги кода в этом пошаговом руководстве взяты из Visual Studio 2019 16.6.5.

> [!TIP]
> Вы можете скачать используемый в этой статье [пример](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/WPF) из репозитория GitHub.

## <a name="pre-requisites"></a>Предварительные требования

Для выполнения этого пошагового руководства необходимо установить Visual Studio 2019 16.3 или более поздней версии и выбрать при этом **рабочую нагрузку для классических приложений .NET**. Дополнительные сведения об установке новейшей версии Visual Studio см. в статье [Установка Visual Studio](/visualstudio/install/install-visual-studio).

## <a name="create-the-application"></a>Создание приложения

1. Открытие Visual Studio
2. На начальном экране выберите **Создать проект**.
3. Выполните поиск по запросу "WPF", выберите в результатах **Приложение WPF (.NET Core)** и нажмите кнопку **Далее**.
4. На следующем экране присвойте проекту имя, например **GetStartedWPF** , и щелкните **Создать**.

## <a name="install-the-entity-framework-nuget-packages"></a>Установка пакета NuGet для Entity Framework

1. Щелкните правой кнопкой мыши решение и выберите **Управление пакетами NuGet для решения...**

    ![Управление пакетами NuGet](_static/wpf-tutorial-nuget.jpg)

1. Введите `entityframeworkcore.sqlite` в поле поиска.
1. Выберите пакет **Microsoft.EntityFrameworkCore.Sqlite**.
1. Установите флажок рядом с проектом в области справа и нажмите кнопку **Установить**.

    ![Пакет SQLite](_static/wpf-tutorial-sqlite.jpg)

1. Повторите шаги для поиска `entityframeworkcore.proxies` и установите **Microsoft.EntityFrameworkCore.Proxies**.

> [!NOTE]
> При установке пакета SQLite автоматически извлекается связанный базовый пакет **Microsoft.EntityFrameworkCore**. Пакет **Microsoft.EntityFrameworkCore.Proxies** обеспечивает поддержку "отложенной загрузки" данных. Это означает, что при наличии сущностей с дочерними объектами в процессе начальной нагрузки извлекаются только родительские сущности. Прокси обнаруживают попытку доступа к дочерним сущностям и автоматически загружает их по требованию.

## <a name="define-a-model"></a>Определение модели

В этом пошаговом руководстве описана реализация модели с использованием Code First. Таким образом, EF Core создаст таблицы и схему базы данных на основе определенных вами классов C#.

Добавьте новый класс. Присвойте ему имя `Product.cs` и заполните его следующим образом:

**`Product.cs`**

[!code-csharp[](../../../samples/core/WPF/GetStartedWPF/GetStartedWPF/Product.cs)]

Затем добавьте класс с именем `Category.cs` и заполните его следующим кодом:

**`Category.cs`**

[!code-csharp[](../../../samples/core/WPF/GetStartedWPF/GetStartedWPF/Category.cs)]

Свойство **Products** класса **Category** и свойство **Category** класса **Product**  — это свойства навигации. В Entity Framework свойства навигации обеспечивают возможность навигации по связям между двумя типами сущностей.

В дополнение к определению сущностей необходимо определить класс, производный от DbContext и предоставляющий свойства DbSet&lt;TEntity&gt;. Свойства DbSet&lt;TEntity&gt; позволяют контексту определить, какие типы необходимо включить в модель.

Экземпляр производного типа DbContext управляет объектами сущностей во время выполнения, в частности заполняет объекты данными из базы данных, отслеживает изменения и сохраняет данные в базе данных.

Добавьте в проект новый класс `ProductContext.cs` со следующим определением:

**`ProductContext.cs`**

[!code-csharp[](../../../samples/core/WPF/GetStartedWPF/GetStartedWPF/ProductContext.cs)]

* `DbSet` сообщает EF Core, какие сущности C# следует сопоставить с базой данных.
* `DbContext` для EF Core можно настроить множеством способов. Информация о них приведена в статье [Настройка DbContext](xref:core/dbcontext-configuration/index).
* Чтобы задать файл данных SQLite, в этом примере используется переопределение `OnConfiguring`.
* Вызов `UseLazyLoadingProxies` указывает EF Core, что необходимо реализовать отложенную загрузку, благодаря которой дочерние сущности автоматически загружаются при доступе из родительской сущности.

Нажмите клавиши **CTRL+SHIFT+B** или последовательно выберите **Сборка&gt; Собрать решение** для компиляции проекта.

> [!TIP]
> Сведения о различных способах синхронизации базы данных и моделей EF Core см. в статье [Управление схемами баз данных](xref:core/managing-schemas/index).

## <a name="lazy-loading"></a>Отложенная загрузка

Свойство **Products** класса **Category** и свойство **Category** класса **Product**  — это свойства навигации. В Entity Framework Core свойства навигации обеспечивают возможность навигации по связям между двумя типами сущностей.

EF Core обеспечивает возможность автоматической загрузки связанных сущностей из базы данных при первом доступе к свойству навигации. В случае использования такого типа загрузки (называемой отложенной) следует помнить о следующем: если содержимое еще отсутствует в контексте, при первом обращении к каждому свойству навигации будет выполняться отдельный запрос базы данных.

При использовании типов сущностей POCO решение EF Core обеспечивает отложенную загрузку, создавая во время выполнения экземпляры производных прокси-типов, а затем переопределяя виртуальные свойства в классах для добавления обработчика загрузки. Чтобы получить отложенную загрузку связанных объектов, необходимо объявить методы получения свойств навигации как **общедоступные** и **виртуальные** ( **переопределяемые** в Visual Basic). При этом класс не должен быть **запечатанным** ( **непереопределяемым** в Visual Basic). При использовании Database First свойства навигации автоматически становятся виртуальными для включения возможности отложенной загрузки.

## <a name="bind-object-to-controls"></a>Привязка объекта к элементам управления

Добавьте классы, определенные в модели в качестве источников данных для этого приложения WPF.

1. Дважды щелкните файл **MainWindow.xaml** в Обозревателе решений, чтобы открыть главную форму.
1. Перейдите на вкладку **XAML** , чтобы изменить код XAML.
1. Сразу после открывающего тега `Window` добавьте следующие источники для подключения к сущностям EF Core.

    [!code-xaml[](../../../samples/core/WPF/GetStartedWPF/GetStartedWPF/MainWindow.xaml?range=1-13&highlight=9-13)]

1. Таким образом будет задан один источник для "родительских" категорий, а второй — для продуктов "сведения".
1. Затем добавьте в код XAML следующую разметку после закрывающего тега `Window.Resources`.

    [!code-xaml[](../../../samples/core/WPF/GetStartedWPF/GetStartedWPF/MainWindow.xaml?range=15-26)]

1. Обратите внимание, что для свойства `CategoryId` задано значение `ReadOnly`, поскольку оно назначается базой данных и не может быть изменено.

## <a name="adding-a-details-grid"></a>Добавление таблицы сведений

Теперь, когда существует таблица для отображения категорий, можно добавить таблицу сведений для отображения продуктов.

**`MainWindow.xaml`**

[!code-xaml[](../../../samples/core/WPF/GetStartedWPF/GetStartedWPF/MainWindow.xaml?range=27-40)]

Наконец, добавьте кнопку `Save` и привяжите событие Click к `Button_Click`.

[!code-xaml[](../../../samples/core/WPF/GetStartedWPF/GetStartedWPF/MainWindow.xaml?range=41-42)]

Представление конструктора должно выглядеть следующим образом:

![Снимок экрана конструктора WPF](_static/wpf-tutorial-designer.jpg)

## <a name="add-code-that-handles-data-interaction"></a>Добавление кода, обрабатывающего взаимодействие с данными

Теперь следует добавить в главное окно несколько обработчиков событий.

1. В окне XAML щелкните элемент **&lt;Window&gt;** , чтобы выбрать главное окно.
1. В окне **Свойства** в правом верхнем углу выберите **События** , а затем дважды щелкните текстовое поле справа от метки **Загружен**.

    ![Свойства главного окна](_static/wpf-tutorial-loaded.jpg)

В результате вы перейдете к коду программной части формы, который теперь можно изменить, чтобы использовать `ProductContext` для доступа к данным. Обновите код, как показано ниже.

Код объявляет длительный экземпляр `ProductContext`. Объект `ProductContext` используется для запроса и сохранения данных в базе данных. Затем из переопределенного метода `OnClosing` вызывается метод `Dispose()` для экземпляра `ProductContext`. Комментарии к коду объясняют, что делает каждый шаг.

**`MainWindow.xaml.cs`**

[!code-csharp[](../../../samples/core/WPF/GetStartedWPF/GetStartedWPF/MainWindow.xaml.cs)]

> [!NOTE]
> Для создания базы данных при первом запуске в коде используется вызов метода `EnsureCreated()`. Это приемлемо для демонстраций, но в рабочих приложениях следует изучить возможности [миграций](xref:core/managing-schemas/migrations/index) для управления схемой. Код также выполняется синхронно, так как он использует локальную базу данных SQLite. Для сценариев в рабочей среде, которые обычно предполагают использование удаленного сервера, рекомендуется применять асинхронные версии методов `Load` и `SaveChanges`.

## <a name="test-the-wpf-application"></a>Тестирование приложения WPF

Скомпилируйте и запустите приложение, нажав клавишу **F5** или выбрав **Отладка&gt; Начать отладку**. База данных должна быть создана автоматически и сохранена в файле с именем `products.db`. Введите имя категории и нажмите клавишу ВВОД, а затем добавьте продукты в нижнюю таблицу. Нажмите кнопку "Сохранить" и посмотрите, обновилась ли таблица с учетом указанных идентификаторов базы данных. Выделите строку и нажмите **Удалить** , чтобы ее удалить. Сущность будет удалена при нажатии кнопки **Сохранить**.

![Выполнение приложения](_static/wpf-tutorial-app.jpg)

## <a name="property-change-notification"></a>Уведомление об изменении свойства

Этот пример предполагает выполнение четырех шагов для синхронизации сущностей с пользовательским интерфейсом.

1. При начальном вызове `_context.Categories.Load()` загружаются данные категорий.
1. Прокси отложенной загрузки загружают данные зависимых продуктов.
1. Встроенная функция отслеживания изменений EF Core вносит необходимые изменения в сущности, в том числе вставки и удаления, при вызове метода `_context.SaveChanges()`.
1. Вызовы `DataGridView.Items.Refresh()` приводят к принудительной перезагрузке с вновь созданными идентификаторами.

Это подходит для нашего примера для начала работы, в других сценариях может потребоваться дополнительный код. Элементы управления WPF преобразовывают для просмотра пользовательский интерфейс, считывая поля и свойства сущностей. При изменении значения в пользовательском интерфейсе это значение передается в сущность. При изменении значения свойства непосредственно в сущности, например при его загрузке из базы данных, WPF не отражает эти изменения сразу же в пользовательском интерфейсе. Подсистема преобразования для просмотра должна быть уведомлена об изменениях. В данном проекте это выполняется путем вызова `Refresh()` вручную. Такое уведомление можно легко автоматизировать, реализовав интерфейс [INotifyPropertyChanged](/dotnet/api/system.componentmodel.inotifypropertychanged). Компоненты WPF будут автоматически обнаруживать интерфейс и регистрироваться для получения событий изменения. За создание таких событий отвечает сущность.

> [!TIP]
> Дополнительные сведения об обработке изменений см. в статье [Практическое руководство. Реализация уведомления об изменении свойства](/dotnet/framework/wpf/data/how-to-implement-property-change-notification).

## <a name="next-steps"></a>Следующие шаги

Узнайте больше о [настройке DbContext](xref:core/dbcontext-configuration/index).
