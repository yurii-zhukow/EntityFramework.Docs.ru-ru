---
title: Обновление предыдущих версий до EF Core 2 — EF Core
description: Инструкции и замечания по обновлению до Entity Framework Core 2.0
author: divega
ms.date: 08/13/2017
uid: core/what-is-new/ef-core-2.0/upgrade
ms.openlocfilehash: bdc0cfe8c0be4a83f8c78ba2ac66bb1e18cea0f7
ms.sourcegitcommit: abda0872f86eefeca191a9a11bfca976bc14468b
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/14/2020
ms.locfileid: "90072347"
---
# <a name="upgrading-applications-from-previous-versions-to-ef-core-20"></a><span data-ttu-id="69da8-103">Обновление приложений с предыдущих версий до EF Core 2.0</span><span class="sxs-lookup"><span data-stu-id="69da8-103">Upgrading applications from previous versions to EF Core 2.0</span></span>

<span data-ttu-id="69da8-104">В версии 2.0 мы воспользовались возможностью значительно усовершенствовать существующие API и поведение.</span><span class="sxs-lookup"><span data-stu-id="69da8-104">We have taken the opportunity to significantly refine our existing APIs and behaviors in 2.0.</span></span> <span data-ttu-id="69da8-105">Есть несколько нововведений, которые могут потребовать изменения существующего кода приложения, хотя мы надеемся, что влияние на большинство приложений окажется незначительным. В большинстве случаев требуется только повторная компиляция и минимальные документированные изменения по замене устаревших API.</span><span class="sxs-lookup"><span data-stu-id="69da8-105">There are a few improvements that can require modifying existing application code, although we believe that for the majority of applications the impact will be low, in most cases requiring just recompilation and minimal guided changes to replace obsolete APIs.</span></span>

<span data-ttu-id="69da8-106">Для обновления существующего приложения до EF Core 2.0 может потребоваться:</span><span class="sxs-lookup"><span data-stu-id="69da8-106">Updating an existing application to EF Core 2.0 may require:</span></span>

1. <span data-ttu-id="69da8-107">Обновление целевой реализации .NET для приложения до версии, поддерживающей .NET Standard 2.0.</span><span class="sxs-lookup"><span data-stu-id="69da8-107">Upgrading the target .NET implementation of the application to one that supports .NET Standard 2.0.</span></span> <span data-ttu-id="69da8-108">Дополнительные сведения см. в разделе [Поддерживаемые реализации .NET](xref:core/platforms/index).</span><span class="sxs-lookup"><span data-stu-id="69da8-108">See [Supported .NET Implementations](xref:core/platforms/index) for more details.</span></span>

2. <span data-ttu-id="69da8-109">Определение поставщика для целевой базы данных, совместимого с EF Core 2.0.</span><span class="sxs-lookup"><span data-stu-id="69da8-109">Identify a provider for the target database which is compatible with EF Core 2.0.</span></span> <span data-ttu-id="69da8-110">См. раздел [EF Core 2.0 требует поставщика базы данных версии 2.0](#ef-core-20-requires-a-20-database-provider) ниже.</span><span class="sxs-lookup"><span data-stu-id="69da8-110">See [EF Core 2.0 requires a 2.0 database provider](#ef-core-20-requires-a-20-database-provider) below.</span></span>

3. <span data-ttu-id="69da8-111">Обновление всех пакетов EF Core (сред выполнения и инструментария) до версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="69da8-111">Upgrading all the EF Core packages (runtime and tooling) to 2.0.</span></span> <span data-ttu-id="69da8-112">Дополнительные сведения см. в разделе [Установка EF Core](xref:core/get-started/install/index).</span><span class="sxs-lookup"><span data-stu-id="69da8-112">Refer to [Installing EF Core](xref:core/get-started/install/index) for more details.</span></span>

4. <span data-ttu-id="69da8-113">Внесение необходимых изменений в код, чтобы компенсировать критические изменения, описанные в оставшейся части этого документа.</span><span class="sxs-lookup"><span data-stu-id="69da8-113">Make any necessary code changes to compensate for the breaking changes described in the rest of this document.</span></span>

## <a name="aspnet-core-now-includes-ef-core"></a><span data-ttu-id="69da8-114">ASP.NET Core теперь включает EF Core</span><span class="sxs-lookup"><span data-stu-id="69da8-114">ASP.NET Core now includes EF Core</span></span>

<span data-ttu-id="69da8-115">Приложения, предназначенные для ASP.NET Core 2.0, могут использовать EF Core 2.0 без дополнительных зависимостей, кроме сторонних поставщиков базы данных.</span><span class="sxs-lookup"><span data-stu-id="69da8-115">Applications targeting ASP.NET Core 2.0 can use EF Core 2.0 without additional dependencies besides third party database providers.</span></span> <span data-ttu-id="69da8-116">Однако приложения, предназначенные для предыдущих версий ASP.NET Core, нужно обновить до ASP.NET Core 2.0, чтобы они могли использовать EF Core 2.0.</span><span class="sxs-lookup"><span data-stu-id="69da8-116">However, applications targeting previous versions of ASP.NET Core need to upgrade to ASP.NET Core 2.0 in order to use EF Core 2.0.</span></span> <span data-ttu-id="69da8-117">Дополнительные сведения об обновлении приложений ASP.NET Core до версии 2.0 см. в [соответствующем разделе документации по ASP.NET Core](/aspnet/core/migration/1x-to-2x/).</span><span class="sxs-lookup"><span data-stu-id="69da8-117">For more details on upgrading ASP.NET Core applications to 2.0 see [the ASP.NET Core documentation on the subject](/aspnet/core/migration/1x-to-2x/).</span></span>

## <a name="new-way-of-getting-application-services-in-aspnet-core"></a><span data-ttu-id="69da8-118">Новый способ получения служб приложений в ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="69da8-118">New way of getting application services in ASP.NET Core</span></span>

<span data-ttu-id="69da8-119">Рекомендуемый шаблон для веб-приложений ASP.NET Core был обновлен для версии 2.0, что нарушило логику времени разработки EF Core, используемую в 1.x.</span><span class="sxs-lookup"><span data-stu-id="69da8-119">The recommended pattern for ASP.NET Core web applications has been updated for 2.0 in a way that broke the design-time logic EF Core used in 1.x.</span></span> <span data-ttu-id="69da8-120">Ранее во время разработки EF Core пытался вызвать `Startup.ConfigureServices` напрямую, чтобы получить доступ к поставщику служб приложения.</span><span class="sxs-lookup"><span data-stu-id="69da8-120">Previously at design-time, EF Core would try to invoke `Startup.ConfigureServices` directly in order to access the application's service provider.</span></span> <span data-ttu-id="69da8-121">В ASP.NET Core 2.0 конфигурация инициализируется за пределами класса `Startup`.</span><span class="sxs-lookup"><span data-stu-id="69da8-121">In ASP.NET Core 2.0, Configuration is initialized outside of the `Startup` class.</span></span> <span data-ttu-id="69da8-122">Приложения, использующие EF Core, обычно обращаются к своей строке подключения из конфигурации, поэтому одного класса `Startup` уже недостаточно.</span><span class="sxs-lookup"><span data-stu-id="69da8-122">Applications using EF Core typically access their connection string from Configuration, so `Startup` by itself is no longer sufficient.</span></span> <span data-ttu-id="69da8-123">При обновлении приложения ASP.NET Core 1. x может появиться следующая ошибка при использовании средств EF Core.</span><span class="sxs-lookup"><span data-stu-id="69da8-123">If you upgrade an ASP.NET Core 1.x application, you may receive the following error when using the EF Core tools.</span></span>

> <span data-ttu-id="69da8-124">В "ApplicationContext" не найден конструктор без параметров.</span><span class="sxs-lookup"><span data-stu-id="69da8-124">No parameterless constructor was found on 'ApplicationContext'.</span></span> <span data-ttu-id="69da8-125">Либо добавьте конструктор без параметров в "ApplicationContext", либо добавьте реализацию "IDesignTimeDbContextFactory&lt;ApplicationContext&gt;" в той же сборке, что и "ApplicationContext"</span><span class="sxs-lookup"><span data-stu-id="69da8-125">Either add a parameterless constructor to 'ApplicationContext' or add an implementation of 'IDesignTimeDbContextFactory&lt;ApplicationContext&gt;' in the same assembly as 'ApplicationContext'</span></span>

<span data-ttu-id="69da8-126">В шаблоне по умолчанию для ASP.NET Core 2.0 добавлен новый обработчик времени разработки.</span><span class="sxs-lookup"><span data-stu-id="69da8-126">A new design-time hook has been added in ASP.NET Core 2.0's default template.</span></span> <span data-ttu-id="69da8-127">Статический метод `Program.BuildWebHost` позволяет EF Core получить доступ к поставщику службы приложения во время разработки.</span><span class="sxs-lookup"><span data-stu-id="69da8-127">The static `Program.BuildWebHost` method enables EF Core to access the application's service provider at design time.</span></span> <span data-ttu-id="69da8-128">При обновлении приложения ASP.NET Core 1. x необходимо обновить класс `Program`, чтобы он выглядел следующим образом.</span><span class="sxs-lookup"><span data-stu-id="69da8-128">If you are upgrading an ASP.NET Core 1.x application, you will need to update the `Program` class to resemble the following.</span></span>

``` csharp
using Microsoft.AspNetCore;
using Microsoft.AspNetCore.Hosting;

namespace AspNetCoreDotNetCore2._0App
{
    public class Program
    {
        public static void Main(string[] args)
        {
            BuildWebHost(args).Run();
        }

        public static IWebHost BuildWebHost(string[] args) =>
            WebHost.CreateDefaultBuilder(args)
                .UseStartup<Startup>()
                .Build();
    }
}
```

<span data-ttu-id="69da8-129">Внедрение этого нового шаблона при обновлении приложений до версии 2.0 настоятельно рекомендуется и необходимо для работы таких функций продукта, как миграция Entity Framework Core.</span><span class="sxs-lookup"><span data-stu-id="69da8-129">The adoption of this new pattern when updating applications to 2.0 is highly recommended and is required in order for product features like Entity Framework Core Migrations to work.</span></span> <span data-ttu-id="69da8-130">Другой распространенной альтернативой является [реализация *IDesignTimeDbContextFactory\<TContext>* ](xref:core/miscellaneous/cli/dbcontext-creation#from-a-design-time-factory).</span><span class="sxs-lookup"><span data-stu-id="69da8-130">The other common alternative is to [implement *IDesignTimeDbContextFactory\<TContext>*](xref:core/miscellaneous/cli/dbcontext-creation#from-a-design-time-factory).</span></span>

## <a name="idbcontextfactory-renamed"></a><span data-ttu-id="69da8-131">IDbContextFactory переименован</span><span class="sxs-lookup"><span data-stu-id="69da8-131">IDbContextFactory renamed</span></span>

<span data-ttu-id="69da8-132">Чтобы обеспечить поддержку разнообразных шаблонов приложений и предоставить пользователям больший контроль над использованием `DbContext` во время разработки, мы, в прошлом, предоставляли интерфейс `IDbContextFactory<TContext>`.</span><span class="sxs-lookup"><span data-stu-id="69da8-132">In order to support diverse application patterns and give users more control over how their `DbContext` is used at design time, we have, in the past, provided the `IDbContextFactory<TContext>` interface.</span></span> <span data-ttu-id="69da8-133">Во время разработки средства EF Core обнаруживали реализации этого интерфейса в проекте и использовали его для создания объектов `DbContext`.</span><span class="sxs-lookup"><span data-stu-id="69da8-133">At design-time, the EF Core tools will discover implementations of this interface in your project and use it to create `DbContext` objects.</span></span>

<span data-ttu-id="69da8-134">Этот интерфейс имел очень общее имя, которое вводило некоторых пользователей в заблуждение, и они пытались использовать его повторно в других сценариях создания `DbContext`.</span><span class="sxs-lookup"><span data-stu-id="69da8-134">This interface had a very general name which mislead some users to try re-using it for other `DbContext`-creating scenarios.</span></span> <span data-ttu-id="69da8-135">Они были застигнуты врасплох, когда средства EF пытались использовать их реализацию во время разработки и вызвали сбой таких команд, как `Update-Database` или `dotnet ef database update`.</span><span class="sxs-lookup"><span data-stu-id="69da8-135">They were caught off guard when the EF Tools then tried to use their implementation at design-time and caused commands like `Update-Database` or `dotnet ef database update` to fail.</span></span>

<span data-ttu-id="69da8-136">Чтобы сообщить о строгой семантике этого интерфейса во время разработки, мы переименовали его в `IDesignTimeDbContextFactory<TContext>`.</span><span class="sxs-lookup"><span data-stu-id="69da8-136">In order to communicate the strong design-time semantics of this interface, we have renamed it to `IDesignTimeDbContextFactory<TContext>`.</span></span>

<span data-ttu-id="69da8-137">В версии 2.0 `IDbContextFactory<TContext>` по-прежнему существует, но помечен как устаревший.</span><span class="sxs-lookup"><span data-stu-id="69da8-137">For the 2.0 release the `IDbContextFactory<TContext>` still exists but is marked as obsolete.</span></span>

## <a name="dbcontextfactoryoptions-removed"></a><span data-ttu-id="69da8-138">DbContextFactoryOptions удален</span><span class="sxs-lookup"><span data-stu-id="69da8-138">DbContextFactoryOptions removed</span></span>

<span data-ttu-id="69da8-139">Из-за описанных выше изменений ASP.NET Core 2.0 мы обнаружили, что `DbContextFactoryOptions` больше не требуется в новом интерфейсе `IDesignTimeDbContextFactory<TContext>`.</span><span class="sxs-lookup"><span data-stu-id="69da8-139">Because of the ASP.NET Core 2.0 changes described above, we found that `DbContextFactoryOptions` was no longer needed on the new `IDesignTimeDbContextFactory<TContext>` interface.</span></span> <span data-ttu-id="69da8-140">Вместо этого следует использовать альтернативные варианты.</span><span class="sxs-lookup"><span data-stu-id="69da8-140">Here are the alternatives you should be using instead.</span></span>

| <span data-ttu-id="69da8-141">DbContextFactoryOptions</span><span class="sxs-lookup"><span data-stu-id="69da8-141">DbContextFactoryOptions</span></span> | <span data-ttu-id="69da8-142">Альтернатива</span><span class="sxs-lookup"><span data-stu-id="69da8-142">Alternative</span></span>                                                  |
|:------------------------|:-------------------------------------------------------------|
| <span data-ttu-id="69da8-143">ApplicationBasePath</span><span class="sxs-lookup"><span data-stu-id="69da8-143">ApplicationBasePath</span></span>     | <span data-ttu-id="69da8-144">AppContext.BaseDirectory</span><span class="sxs-lookup"><span data-stu-id="69da8-144">AppContext.BaseDirectory</span></span>                                     |
| <span data-ttu-id="69da8-145">ContentRootPath</span><span class="sxs-lookup"><span data-stu-id="69da8-145">ContentRootPath</span></span>         | <span data-ttu-id="69da8-146">Directory.GetCurrentDirectory()</span><span class="sxs-lookup"><span data-stu-id="69da8-146">Directory.GetCurrentDirectory()</span></span>                              |
| <span data-ttu-id="69da8-147">EnvironmentName</span><span class="sxs-lookup"><span data-stu-id="69da8-147">EnvironmentName</span></span>         | <span data-ttu-id="69da8-148">Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT")</span><span class="sxs-lookup"><span data-stu-id="69da8-148">Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT")</span></span> |

## <a name="design-time-working-directory-changed"></a><span data-ttu-id="69da8-149">Рабочий каталог времени разработки изменен</span><span class="sxs-lookup"><span data-stu-id="69da8-149">Design-time working directory changed</span></span>

<span data-ttu-id="69da8-150">Изменения в ASP.NET Core 2.0 также требуют, чтобы рабочий каталог, используемый `dotnet ef`, согласовывался с рабочим каталогом, используемым Visual Studio при запуске приложения.</span><span class="sxs-lookup"><span data-stu-id="69da8-150">The ASP.NET Core 2.0 changes also required the working directory used by `dotnet ef` to align with the working directory used by Visual Studio when running your application.</span></span> <span data-ttu-id="69da8-151">Одним из наблюдаемых побочных эффектов является то, что имена файлов SQLite теперь относятся к каталогу проекта, а не к выходному каталогу, как было раньше.</span><span class="sxs-lookup"><span data-stu-id="69da8-151">One observable side effect of this is that SQLite filenames are now relative to the project directory and not the output directory like they used to be.</span></span>

## <a name="ef-core-20-requires-a-20-database-provider"></a><span data-ttu-id="69da8-152">EF Core 2.0 требует поставщика базы данных версии 2.0</span><span class="sxs-lookup"><span data-stu-id="69da8-152">EF Core 2.0 requires a 2.0 database provider</span></span>

<span data-ttu-id="69da8-153">В EF Core 2.0 мы внесли много упрощений и улучшений в механизм работы поставщиков баз данных.</span><span class="sxs-lookup"><span data-stu-id="69da8-153">For EF Core 2.0 we have made many simplifications and improvements in the way database providers work.</span></span> <span data-ttu-id="69da8-154">Это означает, что поставщики 1.0.x и 1.1.x не будут работать с EF Core 2.0.</span><span class="sxs-lookup"><span data-stu-id="69da8-154">This means that 1.0.x and 1.1.x providers will not work with EF Core 2.0.</span></span>

<span data-ttu-id="69da8-155">Поставщики SQL Server и SQLite поставляются командой разработчиков EF, и версии 2.0 будут доступны в рамках выпуска EF Core 2.0.</span><span class="sxs-lookup"><span data-stu-id="69da8-155">The SQL Server and SQLite providers are shipped by the EF team and 2.0 versions will be available as part of the 2.0 release.</span></span> <span data-ttu-id="69da8-156">Сторонние поставщики с открытым кодом для [SQL Compact](https://github.com/ErikEJ/EntityFramework.SqlServerCompact), [PostgreSQL](https://github.com/npgsql/Npgsql.EntityFrameworkCore.PostgreSQL) и [MySQL](https://github.com/PomeloFoundation/Pomelo.EntityFrameworkCore.MySql) находятся в процессе обновления до версии 2.0.</span><span class="sxs-lookup"><span data-stu-id="69da8-156">The open-source third party providers for [SQL Compact](https://github.com/ErikEJ/EntityFramework.SqlServerCompact), [PostgreSQL](https://github.com/npgsql/Npgsql.EntityFrameworkCore.PostgreSQL), and [MySQL](https://github.com/PomeloFoundation/Pomelo.EntityFrameworkCore.MySql) are being updated for 2.0.</span></span> <span data-ttu-id="69da8-157">Для всех других поставщиков обратитесь к автору поставщика.</span><span class="sxs-lookup"><span data-stu-id="69da8-157">For all other providers, please contact the provider writer.</span></span>

## <a name="logging-and-diagnostics-events-have-changed"></a><span data-ttu-id="69da8-158">События журнала и диагностики изменены</span><span class="sxs-lookup"><span data-stu-id="69da8-158">Logging and Diagnostics events have changed</span></span>

<span data-ttu-id="69da8-159">Примечание. Эти изменения не должны повлиять на большую часть кода приложений.</span><span class="sxs-lookup"><span data-stu-id="69da8-159">Note: these changes should not impact most application code.</span></span>

<span data-ttu-id="69da8-160">В версии 2.0 были изменены идентификаторы событий для сообщений, отправляемых в [ILogger](/dotnet/api/microsoft.extensions.logging.ilogger).</span><span class="sxs-lookup"><span data-stu-id="69da8-160">The event IDs for messages sent to an [ILogger](/dotnet/api/microsoft.extensions.logging.ilogger) have changed in 2.0.</span></span> <span data-ttu-id="69da8-161">Теперь эти идентификаторы событий являются уникальными в рамках всего кода EF Core.</span><span class="sxs-lookup"><span data-stu-id="69da8-161">The event IDs are now unique across EF Core code.</span></span> <span data-ttu-id="69da8-162">Эти сообщения теперь соответствуют стандартному шаблону для структурированного ведения журнала, используемому, например, MVC.</span><span class="sxs-lookup"><span data-stu-id="69da8-162">These messages now also follow the standard pattern for structured logging used by, for example, MVC.</span></span>

<span data-ttu-id="69da8-163">Кроме того, были изменены категории средства ведения журнала.</span><span class="sxs-lookup"><span data-stu-id="69da8-163">Logger categories have also changed.</span></span> <span data-ttu-id="69da8-164">Теперь используется известный набор категорий, доступных через [DbLoggerCategory](https://github.com/aspnet/EntityFrameworkCore/blob/rel/2.0.0/src/EFCore/DbLoggerCategory.cs).</span><span class="sxs-lookup"><span data-stu-id="69da8-164">There is now a well-known set of categories accessed through [DbLoggerCategory](https://github.com/aspnet/EntityFrameworkCore/blob/rel/2.0.0/src/EFCore/DbLoggerCategory.cs).</span></span>

<span data-ttu-id="69da8-165">События [DiagnosticSource](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md) теперь используют те же имена идентификаторов событий, что и соответствующие сообщения `ILogger`.</span><span class="sxs-lookup"><span data-stu-id="69da8-165">[DiagnosticSource](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md) events now use the same event ID names as the corresponding `ILogger` messages.</span></span> <span data-ttu-id="69da8-166">Все полезные данные события представляют собой номинальные типы, производные от [EventData](/dotnet/api/microsoft.entityframeworkcore.diagnostics.eventdata).</span><span class="sxs-lookup"><span data-stu-id="69da8-166">The event payloads are all nominal types derived from [EventData](/dotnet/api/microsoft.entityframeworkcore.diagnostics.eventdata).</span></span>

<span data-ttu-id="69da8-167">Идентификаторы событий, типы полезных данных и категории задокументированы в описаниях классов [CoreEventId](/dotnet/api/microsoft.entityframeworkcore.diagnostics.coreeventid) и [RelationalEventId](/dotnet/api/microsoft.entityframeworkcore.diagnostics.relationaleventid).</span><span class="sxs-lookup"><span data-stu-id="69da8-167">Event IDs, payload types, and categories are documented in the [CoreEventId](/dotnet/api/microsoft.entityframeworkcore.diagnostics.coreeventid) and the [RelationalEventId](/dotnet/api/microsoft.entityframeworkcore.diagnostics.relationaleventid) classes.</span></span>

<span data-ttu-id="69da8-168">Идентификаторы также перемещены из Microsoft.EntityFrameworkCore.Infrastructure в новое пространство имен Microsoft.EntityFrameworkCore.Diagnostics.</span><span class="sxs-lookup"><span data-stu-id="69da8-168">IDs have also moved from Microsoft.EntityFrameworkCore.Infrastructure to the new Microsoft.EntityFrameworkCore.Diagnostics namespace.</span></span>

## <a name="ef-core-relational-metadata-api-changes"></a><span data-ttu-id="69da8-169">Изменения API реляционных метаданных EF Core</span><span class="sxs-lookup"><span data-stu-id="69da8-169">EF Core relational metadata API changes</span></span>

<span data-ttu-id="69da8-170">EF Core 2.0 теперь будет создавать отдельный объект [IModel](/dotnet/api/microsoft.entityframeworkcore.metadata.imodel) для каждого из используемых поставщиков.</span><span class="sxs-lookup"><span data-stu-id="69da8-170">EF Core 2.0 will now build a different [IModel](/dotnet/api/microsoft.entityframeworkcore.metadata.imodel) for each different provider being used.</span></span> <span data-ttu-id="69da8-171">Обычно это является прозрачным для приложения.</span><span class="sxs-lookup"><span data-stu-id="69da8-171">This is usually transparent to the application.</span></span> <span data-ttu-id="69da8-172">Это позволило упростить работу с API метаданных более низкого уровня, например, добиться того, что любое обращение к _основным концепциям реляционных метаданных_ всегда осуществляется путем вызова `.Relational` вместо `.SqlServer`, `.Sqlite` и т. д. Поэтому следующий код 1.1.x</span><span class="sxs-lookup"><span data-stu-id="69da8-172">This has facilitated a simplification of lower-level metadata APIs such that any access to _common relational metadata concepts_ is always made through a call to `.Relational` instead of `.SqlServer`, `.Sqlite`, etc. For example, 1.1.x code like this:</span></span>

``` csharp
var tableName = context.Model.FindEntityType(typeof(User)).SqlServer().TableName;
```

<span data-ttu-id="69da8-173">теперь следует писать так:</span><span class="sxs-lookup"><span data-stu-id="69da8-173">Should now be written like this:</span></span>

``` csharp
var tableName = context.Model.FindEntityType(typeof(User)).Relational().TableName;
```

<span data-ttu-id="69da8-174">Вместо использования таких методов, как `ForSqlServerToTable`, теперь доступны методы расширения для написания условного кода на основе текущего используемого поставщика.</span><span class="sxs-lookup"><span data-stu-id="69da8-174">Instead of using methods like `ForSqlServerToTable`, extension methods are now available to write conditional code based on the current provider in use.</span></span> <span data-ttu-id="69da8-175">Пример:</span><span class="sxs-lookup"><span data-stu-id="69da8-175">For example:</span></span>

```csharp
modelBuilder.Entity<User>().ToTable(
    Database.IsSqlServer() ? "SqlServerName" : "OtherName");
```

<span data-ttu-id="69da8-176">Обратите внимание, что это изменение применяется только к API-интерфейсам и метаданным, определенным для _всех_ реляционных поставщиков.</span><span class="sxs-lookup"><span data-stu-id="69da8-176">Note that this change only applies to APIs/metadata that is defined for _all_ relational providers.</span></span> <span data-ttu-id="69da8-177">API и метаданные остаются неизменными, если они относятся только к одному поставщику.</span><span class="sxs-lookup"><span data-stu-id="69da8-177">The API and metadata remains the same when it is specific to only a single provider.</span></span> <span data-ttu-id="69da8-178">Например, кластеризованные индексы относятся к SQL Sever, поэтому должны по-прежнему использоваться `ForSqlServerIsClustered` и `.SqlServer().IsClustered()`.</span><span class="sxs-lookup"><span data-stu-id="69da8-178">For example, clustered indexes are specific to SQL Sever, so `ForSqlServerIsClustered` and  `.SqlServer().IsClustered()` must still be used.</span></span>

## <a name="dont-take-control-of-the-ef-service-provider"></a><span data-ttu-id="69da8-179">Не контролируйте поставщика служб EF</span><span class="sxs-lookup"><span data-stu-id="69da8-179">Don’t take control of the EF service provider</span></span>

<span data-ttu-id="69da8-180">EF Core использует внутренний `IServiceProvider` (контейнер внедрения зависимостей) для своей внутренней реализации.</span><span class="sxs-lookup"><span data-stu-id="69da8-180">EF Core uses an internal `IServiceProvider` (a dependency injection container) for its internal implementation.</span></span> <span data-ttu-id="69da8-181">Приложения должны позволить EF Core создавать и управлять этим поставщиком, за исключением особых случаев.</span><span class="sxs-lookup"><span data-stu-id="69da8-181">Applications should allow EF Core to create and manage this provider except in special cases.</span></span> <span data-ttu-id="69da8-182">Настоятельно рекомендуем удалить все вызовы `UseInternalServiceProvider`.</span><span class="sxs-lookup"><span data-stu-id="69da8-182">Strongly consider removing any calls to `UseInternalServiceProvider`.</span></span> <span data-ttu-id="69da8-183">Если приложению необходимо вызвать `UseInternalServiceProvider`, рассмотрите возможность [регистрации проблемы](https://github.com/dotnet/efcore/Issues), чтобы мы могли изучить другие способы решения вашего вопроса.</span><span class="sxs-lookup"><span data-stu-id="69da8-183">If an application does need to call `UseInternalServiceProvider`, then please consider [filing an issue](https://github.com/dotnet/efcore/Issues) so we can investigate other ways to handle your scenario.</span></span>

<span data-ttu-id="69da8-184">Вызов `AddEntityFramework`, `AddEntityFrameworkSqlServer` и т. д. не требуется для кода приложения, если только `UseInternalServiceProvider` также не вызывается.</span><span class="sxs-lookup"><span data-stu-id="69da8-184">Calling `AddEntityFramework`, `AddEntityFrameworkSqlServer`, etc. is not required by application code unless `UseInternalServiceProvider` is also called.</span></span> <span data-ttu-id="69da8-185">Удалите все существующие вызовы `AddEntityFramework`, `AddEntityFrameworkSqlServer` и т. д. `AddDbContext` должен использоваться так же, как и раньше.</span><span class="sxs-lookup"><span data-stu-id="69da8-185">Remove any existing calls to `AddEntityFramework` or `AddEntityFrameworkSqlServer`, etc. `AddDbContext` should still be used in the same way as before.</span></span>

## <a name="in-memory-databases-must-be-named"></a><span data-ttu-id="69da8-186">Базы данных в памяти должны иметь имена</span><span class="sxs-lookup"><span data-stu-id="69da8-186">In-memory databases must be named</span></span>

<span data-ttu-id="69da8-187">Глобальные неименованные базы данных в памяти были удалены, и теперь все базы данных в памяти должны иметь имя.</span><span class="sxs-lookup"><span data-stu-id="69da8-187">The global unnamed in-memory database has been removed and instead all in-memory databases must be named.</span></span> <span data-ttu-id="69da8-188">Пример:</span><span class="sxs-lookup"><span data-stu-id="69da8-188">For example:</span></span>

``` csharp
optionsBuilder.UseInMemoryDatabase("MyDatabase");
```

<span data-ttu-id="69da8-189">При этом создается или используется база данных с именем "MyDatabase".</span><span class="sxs-lookup"><span data-stu-id="69da8-189">This creates/uses a database with the name “MyDatabase”.</span></span> <span data-ttu-id="69da8-190">Если `UseInMemoryDatabase` вызывается снова с тем же именем, будет использоваться та же база данных в памяти, что позволяет совместно использовать в нескольких экземплярах контекста.</span><span class="sxs-lookup"><span data-stu-id="69da8-190">If `UseInMemoryDatabase` is called again with the same name, then the same in-memory database will be used, allowing it to be shared by multiple context instances.</span></span>

## <a name="read-only-api-changes"></a><span data-ttu-id="69da8-191">Изменения API только для чтения</span><span class="sxs-lookup"><span data-stu-id="69da8-191">Read-only API changes</span></span>

<span data-ttu-id="69da8-192">`IsReadOnlyBeforeSave`, `IsReadOnlyAfterSave`и `IsStoreGeneratedAlways` были устаревшими и заменены на [BeforeSaveBehavior](/dotnet/api/microsoft.entityframeworkcore.metadata.iproperty.beforesavebehavior) и [AfterSaveBehavior](/dotnet/api/microsoft.entityframeworkcore.metadata.iproperty.aftersavebehavior).</span><span class="sxs-lookup"><span data-stu-id="69da8-192">`IsReadOnlyBeforeSave`, `IsReadOnlyAfterSave`, and `IsStoreGeneratedAlways` have been obsoleted and replaced with [BeforeSaveBehavior](/dotnet/api/microsoft.entityframeworkcore.metadata.iproperty.beforesavebehavior) and [AfterSaveBehavior](/dotnet/api/microsoft.entityframeworkcore.metadata.iproperty.aftersavebehavior).</span></span> <span data-ttu-id="69da8-193">Это поведение применяется к любому свойству (не только к свойствам, созданным хранилищем) и определяет, как значение свойства должно использоваться при вставке в строку базы данных (`BeforeSaveBehavior`) или при обновлении существующей строки базы данных (`AfterSaveBehavior`).</span><span class="sxs-lookup"><span data-stu-id="69da8-193">These behaviors apply to any property (not only store-generated properties) and determine how the value of the property should be used when inserting into a database row (`BeforeSaveBehavior`) or when updating an existing database row (`AfterSaveBehavior`).</span></span>

<span data-ttu-id="69da8-194">Свойства, помеченные как [ValueGenerated.OnAddOrUpdate](/dotnet/api/microsoft.entityframeworkcore.metadata.valuegenerated) (например, для вычисляемых столбцов), по умолчанию будут игнорировать любые значения, заданные в данный момент в свойстве.</span><span class="sxs-lookup"><span data-stu-id="69da8-194">Properties marked as [ValueGenerated.OnAddOrUpdate](/dotnet/api/microsoft.entityframeworkcore.metadata.valuegenerated) (for example, for computed columns) will by default ignore any value currently set on the property.</span></span> <span data-ttu-id="69da8-195">Это означает, что созданное хранилищем значение всегда будет получено независимо от того, было ли какое-либо значение установлено или изменено для отслеживаемого объекта.</span><span class="sxs-lookup"><span data-stu-id="69da8-195">This means that a store-generated value will always be obtained regardless of whether any value has been set or modified on the tracked entity.</span></span> <span data-ttu-id="69da8-196">Это поведение можно изменить, задав другое значение `Before\AfterSaveBehavior`.</span><span class="sxs-lookup"><span data-stu-id="69da8-196">This can be changed by setting a different `Before\AfterSaveBehavior`.</span></span>

## <a name="new-clientsetnull-delete-behavior"></a><span data-ttu-id="69da8-197">Новое поведение ClientSetNull при удалении</span><span class="sxs-lookup"><span data-stu-id="69da8-197">New ClientSetNull delete behavior</span></span>

<span data-ttu-id="69da8-198">В предыдущих выпусках [DeleteBehavior.Restrict](/dotnet/api/microsoft.entityframeworkcore.deletebehavior) имело для сущностей, отслеживаемых контекстом, поведение, которое ближе соответствовало семантике `SetNull`.</span><span class="sxs-lookup"><span data-stu-id="69da8-198">In previous releases, [DeleteBehavior.Restrict](/dotnet/api/microsoft.entityframeworkcore.deletebehavior) had a behavior for entities tracked by the context that more closed matched `SetNull` semantics.</span></span> <span data-ttu-id="69da8-199">В EF Core 2.0 было введено новое поведение по умолчанию `ClientSetNull` для дополнительных связей.</span><span class="sxs-lookup"><span data-stu-id="69da8-199">In EF Core 2.0, a new `ClientSetNull` behavior has been introduced as the default for optional relationships.</span></span> <span data-ttu-id="69da8-200">Это поведение имеет семантику `SetNull` для отслеживаемых сущностей и поведение `Restrict` для баз данных, созданных с помощью EF Core.</span><span class="sxs-lookup"><span data-stu-id="69da8-200">This behavior has `SetNull` semantics for tracked entities and `Restrict` behavior for databases created using EF Core.</span></span> <span data-ttu-id="69da8-201">Из нашего опыта, это является наиболее ожидаемым и полезным поведением для отслеживаемых сущностей и баз данных.</span><span class="sxs-lookup"><span data-stu-id="69da8-201">In our experience, these are the most expected/useful behaviors for tracked entities and the database.</span></span> <span data-ttu-id="69da8-202">`DeleteBehavior.Restrict` теперь учитывается для отслеживаемых сущностей, если заданы дополнительные связи.</span><span class="sxs-lookup"><span data-stu-id="69da8-202">`DeleteBehavior.Restrict` is now honored for tracked entities when set for optional relationships.</span></span>

## <a name="provider-design-time-packages-removed"></a><span data-ttu-id="69da8-203">Пакеты времени разработки поставщика удалены</span><span class="sxs-lookup"><span data-stu-id="69da8-203">Provider design-time packages removed</span></span>

<span data-ttu-id="69da8-204">Пакет `Microsoft.EntityFrameworkCore.Relational.Design` был удален.</span><span class="sxs-lookup"><span data-stu-id="69da8-204">The `Microsoft.EntityFrameworkCore.Relational.Design` package has been removed.</span></span> <span data-ttu-id="69da8-205">Его содержимое было объединено в `Microsoft.EntityFrameworkCore.Relational` и `Microsoft.EntityFrameworkCore.Design`.</span><span class="sxs-lookup"><span data-stu-id="69da8-205">It's contents were consolidated into `Microsoft.EntityFrameworkCore.Relational` and `Microsoft.EntityFrameworkCore.Design`.</span></span>

<span data-ttu-id="69da8-206">Это распространяется на пакеты времени разработки поставщика.</span><span class="sxs-lookup"><span data-stu-id="69da8-206">This propagates into the provider design-time packages.</span></span> <span data-ttu-id="69da8-207">Эти пакеты (`Microsoft.EntityFrameworkCore.Sqlite.Design`, `Microsoft.EntityFrameworkCore.SqlServer.Design` и т. д.) были удалены, а их содержимое объединено в основные пакеты поставщиков.</span><span class="sxs-lookup"><span data-stu-id="69da8-207">Those packages (`Microsoft.EntityFrameworkCore.Sqlite.Design`, `Microsoft.EntityFrameworkCore.SqlServer.Design`, etc.) were removed and their contents consolidated into the main provider packages.</span></span>

<span data-ttu-id="69da8-208">Чтобы включить `Scaffold-DbContext` или `dotnet ef dbcontext scaffold` в EF Core 2.0, достаточно сослаться только на один пакет поставщика.</span><span class="sxs-lookup"><span data-stu-id="69da8-208">To enable `Scaffold-DbContext` or `dotnet ef dbcontext scaffold` in EF Core 2.0, you only need to reference the single provider package:</span></span>

``` xml
<PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer"
    Version="2.0.0" />
<PackageReference Include="Microsoft.EntityFrameworkCore.Tools"
    Version="2.0.0"
    PrivateAssets="All" />
<DotNetCliToolReference Include="Microsoft.EntityFrameworkCore.Tools.DotNet"
    Version="2.0.0" />
```
