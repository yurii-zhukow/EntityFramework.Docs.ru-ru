---
title: Критические изменения в EF Core 5.0 — EF Core
description: Полный список критических изменений, появившихся в Entity Framework Core 5.0
author: bricelam
ms.date: 11/07/2020
uid: core/what-is-new/ef-core-5.0/breaking-changes
ms.openlocfilehash: 4a463e785edaceaf5dd96164c39e2cc9b5f86de4
ms.sourcegitcommit: 032a1767d7a6e42052a005f660b80372c6521e7e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/12/2021
ms.locfileid: "98128749"
---
# <a name="breaking-changes-in-ef-core-50"></a>Критические изменения в EF Core 5.0

Указанные ниже изменения в API и поведении могут нарушить работу существующих приложений при их обновлении до EF Core 5.0.0.

## <a name="summary"></a>Сводка

| **Критическое изменение**                                                                                                                   | **Влияние** |
|:--------------------------------------------------------------------------------------------------------------------------------------|------------|
| [EF Core 5.0 не поддерживает платформу .NET Framework](#netstandard21)                                                                         | Средний     |
| [IProperty.GetColumnName() считается устаревшим](#getcolumnname-obsolete)                                                                  | Средний     |
| [Для десятичных значений требуется указывать значения точности и масштаба](#decimals)                                                                            | Средний     |
| [Атрибут обязательного поля имеет разную семантику для навигации к основной сущности и навигации к зависимой сущности](#required-dependent)                                 | Средний     |
| [Определение запроса заменено методами, зависящими от поставщика](#defining-query)                                                          | Средний     |
| [Навигации по ссылке, которая не является пустой, не переопределяются запросами](#nonnullreferences)                                                   | Средний     |
| [ToView() по-разному обрабатывается миграциями](#toview)                                                                              | Средний     |
| [ToTable(null) помечает тип сущности как не сопоставленный с таблицей](#totable)                                                              | Средний     |
| [Из расширения NTS для SQLite удален метод HasGeometricDimension.](#geometric-sqlite)                                                   | Низкий        |
| [Cosmos: ключ секции теперь добавляется в первичный ключ](#cosmos-partition-key)                                                        | Низкий        |
| [Cosmos: свойство `id` переименовано в `__id`](#cosmos-id)                                                                                 | Низкий        |
| [Cosmos: byte[] теперь хранится в виде строки base64, а не числового массива](#cosmos-byte)                                             | Низкий        |
| [Cosmos: GetPropertyName и SetPropertyName переименованы](#cosmos-metadata)                                                          | Низкий        |
| [Генераторы значений вызываются, когда состояние сущности меняется с "отсоединено" на "не изменено", "обновлено" или "удалено"](#non-added-generation) | Низкий        |
| [IMigrationsModelDiffer теперь использует IRelationalModel](#relational-model)                                                                 | Низкий        |
| [Дискриминаторы доступны только для чтения](#read-only-discriminators)                                                                             | Низкий        |
| [Относящиеся к поставщику методы EF.Functions вызываются для поставщика InMemory](#no-client-methods)                                              | Низкий        |
| [IndexBuilder.HasName считается устаревшим](#index-obsolete)                                                                               | Низкий        |
| [Добавлено средство преобразования во множественное число для формирования шаблонов реконструированных моделей](#pluralizer)                                                 | Низкий        |
| [INavigationBase заменяет INavigation в некоторых API, чтобы поддерживать пропуск навигации](#inavigationbase)                                     | Низкий        |
| [Некоторые запросы с помощью коррелированной коллекции, которые также используют `Distinct` или `GroupBy`, больше не поддерживаются](#collection-distinct-groupby). | Низкий        |
| [Использование коллекции запрашиваемого типа в проекции не поддерживается](#queryable-projection)                                          | Низкий        |

## <a name="medium-impact-changes"></a>Изменения средней степени влияния

<a name="netstandard21"></a>

### <a name="ef-core-50-does-not-support-net-framework"></a>EF Core 5.0 не поддерживает платформу .NET Framework

[Отслеживание вопроса № 15498](https://github.com/dotnet/efcore/issues/15498)

#### <a name="old-behavior"></a>Старое поведение

EF Core 3.1 предназначается для платформы .NET Standard 2.0, которая поддерживается платформой .NET Framework.

#### <a name="new-behavior"></a>Новое поведение

EF Core 5.0 предназначается для платформы .NET Standard 2.1, которая не поддерживается платформой .NET Framework. Это означает, что EF Core 5.0 нельзя использовать с приложениями .NET Framework.

#### <a name="why"></a>Почему

Это часть масштабного процесса между группами .NET, направленного на унификацию на базе единой целевой платформы .NET. Дополнительные сведения см. в разделе [Перспективы .NET Standard](https://devblogs.microsoft.com/dotnet/the-future-of-net-standard/).

#### <a name="mitigations"></a>Устранение проблем

В приложениях .NET Framework по-прежнему возможно использование выпуска EF Core 3.1, который рассчитан на [долгосрочную поддержку (LTS)](https://dotnet.microsoft.com/platform/support/policy/dotnet-core). Кроме того, можно обновить приложения для работы с .NET Core 2.1, .NET Core 3.1 или .NET 5, которые поддерживают .NET Standard 2.1.

<a name="getcolumnname-obsolete"></a>

### <a name="ipropertygetcolumnname-is-now-obsolete"></a>IProperty.GetColumnName() считается устаревшим

[Отслеживание проблемы № 2266](https://github.com/dotnet/efcore/issues/2266)

#### <a name="old-behavior"></a>Старое поведение

`GetColumnName()` возвращал имя столбца, с которым сопоставлено свойство.

#### <a name="new-behavior"></a>Новое поведение

`GetColumnName()` по-прежнему возвращает имя столбца, с которым сопоставлено свойство, но это поведение стало неоднозначным, так как EF Core 5 поддерживает TPT и одновременное сопоставление с представлением или функцией, где эти сопоставления могут использовать разные имена столбцов для одного и того же свойства.

#### <a name="why"></a>Почему

Мы пометили этот метод как устаревший, чтобы помочь пользователям более точно перегружать <xref:Microsoft.EntityFrameworkCore.RelationalPropertyExtensions.GetColumnName(Microsoft.EntityFrameworkCore.Metadata.IProperty,Microsoft.EntityFrameworkCore.Metadata.StoreObjectIdentifier@)>.

#### <a name="mitigations"></a>Устранение проблем

Используйте следующий код, чтобы получить имя столбца для определенной таблицы:

```csharp
var columnName = property.GetColumnName(StoreObjectIdentifier.Table("Users", null)));
```

<a name="decimals"></a>

### <a name="precision-and-scale-are-required-for-decimals"></a>Для десятичных значений требуется указывать значения точности и масштаба

[Отслеживание проблемы № 19293](https://github.com/dotnet/efcore/issues/19293)

#### <a name="old-behavior"></a>Старое поведение

В EF Core, как правило, не устанавливались значения точности и масштаба для объектов <xref:Microsoft.Data.SqlClient.SqlParameter>. Это означает, что полные значения точности и масштаба отправлялись в SQL Server, где на этом этапе выполнялось округление в зависимости от значений точности и масштаба, заданных для столбца базы данных.

#### <a name="new-behavior"></a>Новое поведение

Теперь EF Core устанавливает значения точности и масштаба для параметров, используя значения, которые заданы в свойствах модели EF Core. Таким образом, округление выполняется в SqlClient. Следовательно, если заданные значения точности и масштаба не совпадают с аналогичными в базе данных, округление может выполняться иначе.

#### <a name="why"></a>Почему

Для новых возможностей SQL Server, включая функцию Always Encrypted, требуется полностью указывать аспекты параметров. Кроме того, в результате внесенных в SqlClient изменений вместо усечения десятичных значений выполняется округление, что согласуется с поведением SQL Server. Благодаря этому EF Core может задавать эти аспекты для корректной настройки десятичных значений без изменения поведения.

#### <a name="mitigations"></a>Устранение проблем

Сопоставьте свойства десятичного значения с использованием имени типа, которое включает в себя значения точности и масштаба. Пример:

```csharp
public class Blog
{
    public int Id { get; set; }

    [Column(TypeName = "decimal(16, 5")]
    public decimal Score { get; set; }
}
```

Также можно использовать `HasPrecision` в API построения модели. Пример:

```csharp
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<Blog>().Property(e => e.Score).HasPrecision(16, 5);
    }
```

<a name="required-dependent"></a>

### <a name="required-on-the-navigation-from-principal-to-dependent-has-different-semantics"></a>Атрибут обязательного поля имеет разную семантику для навигации к основной сущности и навигации к зависимой сущности

[Отслеживание вопроса № 17286](https://github.com/dotnet/efcore/issues/17286)

#### <a name="old-behavior"></a>Старое поведение

При необходимости можно настроить только навигацию к основной сущности. Поэтому при применении `RequiredAttribute` к переходу к зависимой сущности (сущности, содержащей внешний ключ) вместо этого будет создан внешний ключ для определяющего типа сущности.

#### <a name="new-behavior"></a>Новое поведение

Благодаря добавленной поддержке обязательных зависимых объектов теперь можно пометить любую навигацию по ссылке как обязательную, а это означает, что в случае, показанном выше, внешний ключ будет определен на другой стороне отношения и свойства не будут помечены как обязательные.

Вызов `IsRequired` перед указанием зависимого элемента теперь неоднозначен.

```csharp
modelBuilder.Entity<Blog>()
    .HasOne(b => b.BlogImage)
    .WithOne(i => i.Blog)
    .IsRequired()
    .HasForeignKey<BlogImage>(b => b.BlogForeignKey);
```

#### <a name="why"></a>Почему

Необходимо новое поведение для обеспечения поддержки требуемых зависимых объектов ([см. #12100](https://github.com/dotnet/efcore/issues/12100)).

#### <a name="mitigations"></a>Устранение проблем

Удалите атрибут `RequiredAttribute` из навигации в зависимый объект и поместите его вместо этого в навигацию к основному объекту или настройте связь в `OnModelCreating`.

```csharp
modelBuilder.Entity<Blog>()
    .HasOne(b => b.BlogImage)
    .WithOne(i => i.Blog)
    .HasForeignKey<BlogImage>(b => b.BlogForeignKey)
    .IsRequired();
```

<a name="defining-query"></a>

### <a name="defining-query-is-replaced-with-provider-specific-methods"></a>Определение запроса заменено методами, зависящими от поставщика

[Отслеживание вопроса № 18903](https://github.com/dotnet/efcore/issues/18903)

#### <a name="old-behavior"></a>Старое поведение

Типы сущностей сопоставлялись с определяющими запросами на уровне ядра. Каждый раз, когда тип сущности использовался в запросе, корень типа сущности заменялся определяющим запросом для любого поставщика.

#### <a name="new-behavior"></a>Новое поведение

Интерфейсы API для определяющего запроса стали нерекомендуемыми. Появились новые интерфейсы API для конкретных поставщиков.

#### <a name="why"></a>Почему

Хотя определяющий запрос был реализован как заменяющий при использовании корня запроса в запросе, существовал ряд проблем.

- Если определяющий запрос проецировал тип сущности с помощью `new { ... }` в методе `Select`, определение его как сущности требовало дополнительной работы и не согласовывалось с тем, как номинальные типы в запросе обрабатываются в EF Core.
- Для реляционных поставщиков `FromSql` по-прежнему требуется для передачи строки SQL в виде выражения LINQ.

Изначально определяющие запросы появились как представления на стороне клиента, предназначенные для использования с поставщиком в памяти для сущностей без ключей (аналогично представлениям базы данных в реляционных базах данных). Такое определение упрощает тестирование приложения с базой данных в памяти. Впоследствии они стали применяться более широко. Это было полезной возможностью, но вносило несогласованность и затрудняло понимание. Поэтому мы решили упростить принцип их работы. Теперь определяющий запрос на основе LINQ предназначен исключительно для поставщика в памяти и обрабатывается по-особому. Дополнительные сведения см. в [этой проблеме](https://github.com/dotnet/efcore/issues/20023).

#### <a name="mitigations"></a>Устранение проблем

Для реляционных поставщиков используйте метод `ToSqlQuery` в `OnModelCreating` и передайте строку SQL, которая должна использоваться для типа сущности.
Для поставщика в памяти используйте метод `ToInMemoryQuery` в `OnModelCreating` и передайте запрос SQL, который должен использоваться для типа сущности.

<a name="nonnullreferences"></a>

### <a name="non-null-reference-navigations-are-not-overwritten-by-queries"></a>Навигации по ссылке, которая не является пустой, не переопределяются запросами

[Отслеживание проблемы № 2693](https://github.com/dotnet/EntityFramework.Docs/issues/2693)

#### <a name="old-behavior"></a>Старое поведение

В EF Core 3.1 навигации по ссылкам, которые изначально инициализированы значениями, отличными от NULL, иногда перезаписывались экземплярами сущностей из базы данных, независимо от того, совпадали ли значения ключей. Однако в других случаях в EF Core 3.1 выполнялось обратное действие и оставлялось существующее значение, отличное от NULL.

#### <a name="new-behavior"></a>Новое поведение

Начиная с версии EF Core 5.0, навигации по пустой ссылке, которая не является пустой, никогда не перезаписываются экземплярами, возвращаемыми запросом.

Обратите внимание, что безотложная инициализация навигации по _коллекции_ для пустой коллекции по-прежнему поддерживается.

#### <a name="why"></a>Почему

Инициализация свойства навигации по ссылкам для "пустого" экземпляра сущности приводит к неоднозначному состоянию. Пример:

```csharp
public class Blog
{
     public int Id { get; set; }
     public Author Author { get; set; ) = new Author();
}
```

Обычно запрос блогов и авторов сначала создает экземпляры `Blog`, а затем задает соответствующие экземпляры `Author` на основе данных, возвращаемых из базы данных. Однако в этом случае каждое свойство `Blog.Author` будет уже инициализировано для пустого свойства `Author`. Кроме EF Core, не существует способа выяснить, является ли этот экземпляр "пустым". Таким образом, перезапись этого экземпляра может без уведомления привести к выводу допустимого `Author`. Таким образом, EF Core 5.0 теперь не перезаписывает уже инициализированную навигацию.

Это новое поведение также соответствует обычному поведению EF6, хотя при исследовании мы также обнаружили некоторые случаи несогласованности в EF6.

#### <a name="mitigations"></a>Устранение проблем

В случае обнаружения такого прерывания исправление будет способствовать остановке активной инициализации свойств навигации по ссылкам.

<a name="toview"></a>

### <a name="toview-is-treated-differently-by-migrations"></a>ToView() по-разному обрабатывается миграциями

[Отслеживание проблемы № 2725](https://github.com/dotnet/efcore/issues/2725)

#### <a name="old-behavior"></a>Старое поведение

Вызов `ToView(string)` заставляет миграции игнорировать тип сущности в дополнение к сопоставлению его с представлением.

#### <a name="new-behavior"></a>Новое поведение

Теперь `ToView(string)` помечает тип сущности как не сопоставленный с таблицей в дополнение к сопоставлению его с представлением. Это приводит к тому, что при первой миграции после обновления до EF Core 5 предпринимается попытка удаления таблицы по умолчанию для этого типа сущности, так как он больше не игнорируется.

#### <a name="why"></a>Почему

EF Core теперь позволяет сопоставлять тип сущности и с таблицей, и с представлением одновременно, поэтому `ToView` больше нельзя использовать для указания, что тип сущности следует игнорировать при миграции.

#### <a name="mitigations"></a>Устранение проблем

Используйте следующий код, чтобы пометить сопоставленную таблицу как исключенную из миграции:

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<User>().ToTable("UserView", t => t.ExcludeFromMigrations());
}
```

<a name="totable"></a>

### <a name="totablenull-marks-the-entity-type-as-not-mapped-to-a-table"></a>ToTable(null) помечает тип сущности как не сопоставленный с таблицей

[Отслеживание проблемы № 21172](https://github.com/dotnet/efcore/issues/21172)

#### <a name="old-behavior"></a>Старое поведение

`ToTable(null)` сбрасывает имя таблицы в значение по умолчанию.

#### <a name="new-behavior"></a>Новое поведение

`ToTable(null)` теперь помечает тип сущности как не сопоставленный с какой-либо таблицей.

#### <a name="why"></a>Почему

EF Core теперь позволяет сопоставлять тип сущности и с таблицей, и с представлением одновременно, поэтому `ToTable(null)` используется для указания, что тип сущности не сопоставлен ни с какой таблицей.

#### <a name="mitigations"></a>Устранение проблем

Используйте следующий код, чтобы сбрасывать имя таблицы в значение по умолчанию, если отсутствует сопоставление с представлением или DbFunction:

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<User>().Metadata.RemoveAnnotation(RelationalAnnotationNames.TableName);
}
```

## <a name="low-impact-changes"></a>Изменения низкой степени влияния

<a name="geometric-sqlite"></a>

### <a name="removed-hasgeometricdimension-method-from-sqlite-nts-extension"></a>Из расширения NTS для SQLite удален метод HasGeometricDimension.

[Отслеживание проблемы #14257](https://github.com/dotnet/efcore/issues/14257)

#### <a name="old-behavior"></a>Старое поведение

Метод HasGeometricDimension использовался для включения дополнительных измерений (Z и M) для столбцов геометрии. Однако он влиял только на создание базы данных. Его не требовалось указывать для запроса значений с дополнительными измерениями. Он также не работал корректно при вставке или обновлении значений с дополнительными измерениями ([см. проблему #14257](https://github.com/dotnet/efcore/issues/14257)).

#### <a name="new-behavior"></a>Новое поведение

Чтобы включить вставку и обновление геометрических значений с дополнительными измерениями (Z и M), необходимо указать измерение в составе имени типа столбца. Этот интерфейс API более точно соответствует базовой работе функции AddGeometryColumn расширения SpatiaLite.

#### <a name="why"></a>Почему

Использование метода HasGeometricDimension после указания измерения в типе столбца является ненужным и избыточным, поэтому этот метод полностью удален.

#### <a name="mitigations"></a>Устранение проблем

Чтобы указать измерение, используйте `HasColumnType`:

```csharp
modelBuilder.Entity<GeoEntity>(
    x =>
    {
        // Allow any GEOMETRY value with optional Z and M values
        x.Property(e => e.Geometry).HasColumnType("GEOMETRYZM");

        // Allow only POINT values with an optional Z value
        x.Property(e => e.Point).HasColumnType("POINTZ");
    });
```

<a name="cosmos-partition-key"></a>

### <a name="cosmos-partition-key-is-now-added-to-the-primary-key"></a>Cosmos: ключ секции теперь добавляется в первичный ключ

[Отслеживание вопроса № 15289](https://github.com/dotnet/efcore/issues/15289)

#### <a name="old-behavior"></a>Старое поведение

Свойство ключа секции добавлялось только в альтернативный ключ, включающий `id`.

#### <a name="new-behavior"></a>Новое поведение

В соответствии с соглашением свойство ключа секции теперь также добавляется в первичный ключ.

#### <a name="why"></a>Почему

Это изменение делает модель более согласованной с семантикой Azure Cosmos DB и повышает производительность `Find` и некоторых запросов.

#### <a name="mitigations"></a>Устранение проблем

Чтобы предотвратить добавление свойства ключа секции в первичный ключ, настройте его в `OnModelCreating`.

```csharp
modelBuilder.Entity<Blog>()
    .HasKey(b => b.Id);
```

<a name="cosmos-id"></a>

### <a name="cosmos-id-property-renamed-to-__id"></a>Cosmos: свойство `id` переименовано в `__id`

[Отслеживание вопроса № 17751](https://github.com/dotnet/efcore/issues/17751)

#### <a name="old-behavior"></a>Старое поведение

Теневое свойство, сопоставленное со свойством JSON `id`, также называлось `id`.

#### <a name="new-behavior"></a>Новое поведение

Теневое свойство, создаваемое в соответствии с соглашением, теперь называется `__id`.

#### <a name="why"></a>Почему

Это изменение снижает вероятность того, что свойство `id` будет конфликтовать с существующим свойством типа сущности.

#### <a name="mitigations"></a>Устранение проблем

Чтобы вернуться к поведению, принятому в версии 3.x, настройте свойство `id` в `OnModelCreating`.

```csharp
modelBuilder.Entity<Blog>()
    .Property<string>("id")
    .ToJsonProperty("id");
```

<a name="cosmos-byte"></a>

### <a name="cosmos-byte-is-now-stored-as-a-base64-string-instead-of-a-number-array"></a>Cosmos: byte[] теперь хранится в виде строки base64, а не числового массива

[Отслеживание вопроса № 17306](https://github.com/dotnet/efcore/issues/17306)

#### <a name="old-behavior"></a>Старое поведение

Свойства типа byte[] хранились в виде числового массива.

#### <a name="new-behavior"></a>Новое поведение

Свойства типа byte[] теперь хранятся в виде строки base64.

#### <a name="why"></a>Почему

Такое представление byte[] ближе к ожидаемому и используется по умолчанию в основных библиотеках сериализации JSON.

#### <a name="mitigations"></a>Устранение проблем

Существующие данные, хранящиеся в виде числовых массивов, будут по-прежнему запрашиваться правильно, но в настоящее время не существует способа восстановить прежнее поведение вставки. Если это ограничение не позволяет реализовать ваш сценарий, оставьте комментарий к [этой проблеме](https://github.com/dotnet/efcore/issues/17306)

<a name="cosmos-metadata"></a>

### <a name="cosmos-getpropertyname-and-setpropertyname-were-renamed"></a>Cosmos: GetPropertyName и SetPropertyName переименованы

[Отслеживание вопроса № 17874](https://github.com/dotnet/efcore/issues/17874)

#### <a name="old-behavior"></a>Старое поведение

Ранее методы расширения назывались `GetPropertyName` и `SetPropertyName`.

#### <a name="new-behavior"></a>Новое поведение

Старый интерфейс API был удален, и были добавлены новые методы: `GetJsonPropertyName` и `SetJsonPropertyName`.

#### <a name="why"></a>Почему

Данное изменение устраняет неоднозначность в отношении того, что настраивают эти методы.

#### <a name="mitigations"></a>Устранение проблем

Используйте новый API.

<a name="non-added-generation"></a>

### <a name="value-generators-are-called-when-the-entity-state-is-changed-from-detached-to-unchanged-updated-or-deleted"></a>Генераторы значений вызываются, когда состояние сущности меняется с "отсоединено" на "не изменено", "обновлено" или "удалено"

[Отслеживание вопроса № 15289](https://github.com/dotnet/efcore/issues/15289)

#### <a name="old-behavior"></a>Старое поведение

Генераторы значений вызывались только при изменении состояния сущности на «добавлено».

#### <a name="new-behavior"></a>Новое поведение

Генераторы значений теперь вызываются, когда состояние сущности меняется с "отсоединено" на "не изменено", "обновлено" или "удалено", а свойство содержит значения по умолчанию.

#### <a name="why"></a>Почему

Это изменение было необходимо для улучшения работы со свойствами, которые не сохраняются в хранилище данных, а их значения всегда создаются на клиенте.

#### <a name="mitigations"></a>Устранение проблем

Чтобы предотвратить вызов генератора значений, присвойте свойству значение, отличное от значения по умолчанию, до изменения состояния.

<a name="relational-model"></a>

### <a name="imigrationsmodeldiffer-now-uses-irelationalmodel"></a>IMigrationsModelDiffer теперь использует IRelationalModel

[Отслеживание вопроса № 20305](https://github.com/dotnet/efcore/issues/20305)

#### <a name="old-behavior"></a>Старое поведение

API `IMigrationsModelDiffer` определялся с помощью `IModel`.

#### <a name="new-behavior"></a>Новое поведение

Теперь API `IMigrationsModelDiffer` использует `IRelationalModel`. Однако моментальный снимок модели по-прежнему содержит только `IModel`, так как этот код является частью приложения, и Entity Framework не может изменить его без внесения значительных изменений.

#### <a name="why"></a>Почему

`IRelationalModel` — это вновь добавленное представление схемы базы данных. Его использование для поиска различий выполняется быстрее и точнее.

#### <a name="mitigations"></a>Устранение проблем

Используйте следующий код для сравнения модели из `snapshot` с моделью из `context`.

```csharp
var dependencies = context.GetService<ProviderConventionSetBuilderDependencies>();
var relationalDependencies = context.GetService<RelationalConventionSetBuilderDependencies>();

var typeMappingConvention = new TypeMappingConvention(dependencies);
typeMappingConvention.ProcessModelFinalizing(((IConventionModel)modelSnapshot.Model).Builder, null);

var relationalModelConvention = new RelationalModelConvention(dependencies, relationalDependencies);
var sourceModel = relationalModelConvention.ProcessModelFinalized(snapshot.Model);

var modelDiffer = context.GetService<IMigrationsModelDiffer>();
var hasDifferences = modelDiffer.HasDifferences(
    ((IMutableModel)sourceModel).FinalizeModel().GetRelationalModel(),
    context.Model.GetRelationalModel());
```

Мы планируем улучшить этот процесс в версии 6.0 ([см. #22031](https://github.com/dotnet/efcore/issues/22031)).

<a name="read-only-discriminators"></a>

### <a name="discriminators-are-read-only"></a>Дискриминаторы доступны только для чтения

[Отслеживание вопроса № 21154](https://github.com/dotnet/efcore/issues/21154)

#### <a name="old-behavior"></a>Старое поведение

Можно было изменить значение дискриминатора перед вызовом метода `SaveChanges`

#### <a name="new-behavior"></a>Новое поведение

В приведенном выше случае будет вызвано исключение.

#### <a name="why"></a>Почему

EF не ожидает изменения типа сущности, пока он еще отслеживается, поэтому изменение значения дискриминатора оставляет контекст в несогласованном состоянии, что может привести к непредвиденному поведению.

#### <a name="mitigations"></a>Устранение проблем

Если необходимо изменить значение дискриминатора и контекст будет удален сразу после вызова `SaveChanges`, дискриминатор можно сделать изменяемым.

```csharp
modelBuilder.Entity<BaseEntity>()
    .Property<string>("Discriminator")
    .Metadata.SetAfterSaveBehavior(PropertySaveBehavior.Save);
```

<a name="no-client-methods"></a>

### <a name="provider-specific-effunctions-methods-throw-for-inmemory-provider"></a>Относящиеся к поставщику методы EF.Functions вызываются для поставщика InMemory

[Отслеживание вопроса № 20294](https://github.com/dotnet/efcore/issues/20294)

#### <a name="old-behavior"></a>Старое поведение

Относящиеся к конкретному поставщику методы EF.Functions содержали реализацию для выполнения на стороне клиента, что позволяло им выполняться в поставщике InMemory. Например, `EF.Functions.DateDiffDay` — это относящийся к SQL Server метод, который работал в поставщике InMemory.

#### <a name="new-behavior"></a>Новое поведение

Методы, относящиеся к конкретному поставщику, были изменены так, чтобы в теле метода создавалось исключение, блокирующее вычисление метода на стороне клиента.

#### <a name="why"></a>Почему

Методы, относящиеся к конкретному поставщику, сопоставляются с функцией базы данных. Вычисление, выполняемое сопоставленной функцией базы данных, не всегда может реплицироваться на стороне клиента в LINQ. Поэтому результаты, полученные при выполнении одного и того же метода на сервере и в клиенте, могут различаться. Так как эти методы используются в LINQ для преобразования в определенные функции базы данных, их не нужно вычислять на стороне клиента. Так как поставщик InMemory — это другая *база данных*, эти методы недоступны для него. При попытке выполнить их для поставщика InMemory или любого другого поставщика, который не преобразует эти методы, создается исключение.

#### <a name="mitigations"></a>Устранение проблем

Так как точно воссоздать поведение функций базы данных невозможно, содержащие их запросы следует тестировать на основе базы данных того же типа, что и рабочая база данных.

<a name="index-obsolete"></a>

### <a name="indexbuilderhasname-is-now-obsolete"></a>IndexBuilder.HasName считается устаревшим

[Отслеживание проблемы № 21089](https://github.com/dotnet/efcore/issues/21089)

#### <a name="old-behavior"></a>Старое поведение

Ранее допускалось определение только одного индекса для конкретного набора свойств. Имя для базы данных индекса настраивалось с использованием IndexBuilder.HasName.

#### <a name="new-behavior"></a>Новое поведение

Теперь допускается несколько индексов для одного набора свойств. Эти индексы отличаются именами в пределах модели. По соглашению имя модели используется в качестве имени базы данных, но его также можно указать независимо с использованием HasDatabaseName.

#### <a name="why"></a>Почему

В будущем мы хотим включить для набора свойств параллельные индексы с сортировкой по возрастанию и убыванию, а также индексы с разными параметрами сортировки. Это изменение продвигает нас в этом направлении.

#### <a name="mitigations"></a>Устранение проблем

Любой код, который ранее вызывал IndexBuilder.HasName, необходимо изменить для вызова HasDatabaseName.

Если в проекте есть миграции, созданные до версии EF Core 2.0.0, вы можете игнорировать предупреждения для этих файлов, подавив их с помощью `#pragma warning disable 612, 618`.

<a name="pluralizer"></a>

### <a name="a-pluralizer-is-now-included-for-scaffolding-reverse-engineered-models"></a>Добавлено средство преобразования во множественное число для формирования шаблонов реконструированных моделей

[Отслеживание проблемы № 11160](https://github.com/dotnet/efcore/issues/11160)

#### <a name="old-behavior"></a>Старое поведение

Ранее нужно было устанавливать отдельный пакет, чтобы преобразовывать имена DbSet и коллекций во множественное число и имена таблиц в единственное число при создании шаблонов DbContext и типов сущностей путем реконструирования из схемы базы данных.

#### <a name="new-behavior"></a>Новое поведение

Теперь EF Core содержит собственное средство для преобразования во множественное число на основе библиотеки [Humanizer](https://github.com/Humanizr/Humanizer). Именно эту библиотеку использует Visual Studio, рекомендуя имена переменных.

#### <a name="why"></a>Почему

Использование форм множественного числа для свойств коллекций и единственного числа для типов и ссылочных свойств считается идиоматичным в .NET.

#### <a name="mitigations"></a>Устранение проблем

Чтобы отключить средство для преобразования во множественное число, укажите параметр `--no-pluralize` для `dotnet ef dbcontext scaffold` или `-NoPluralize` для `Scaffold-DbContext`.

<a name="inavigationbase"></a>

### <a name="inavigationbase-replaces-inavigation-in-some-apis-to-support-skip-navigations"></a>INavigationBase заменяет INavigation в некоторых API, чтобы поддерживать пропуск навигации

[Отслеживание проблемы № 2568](https://github.com/dotnet/EntityFramework.Docs/issues/2568)

#### <a name="old-behavior"></a>Старое поведение

В версиях EF Core, предшествующих версии 5.0, поддерживалась только одна форма свойства навигации, представленная интерфейсом `INavigation`.

#### <a name="new-behavior"></a>Новое поведение

EF Core 5.0 представляет связи "многие ко многим", которые используют "пропуск навигации". Они представлены интерфейсом `ISkipNavigation`, а большинство функциональных возможностей `INavigation` переданы в общий базовый интерфейс: `INavigationBase`.

#### <a name="why"></a>Почему

Большая часть функций между обычной навигацией и пропуском навигации одинаковы. Тем не менее пропуск навигации имеет другую связь с внешними ключами по сравнению с обычной навигацией, поскольку вовлеченные внешние ключи находятся не на обоих концах связи, а скорее в объекте соединения.

#### <a name="mitigations"></a>Устранение проблем

Во многих случаях приложения могут переключиться на использование нового базового интерфейса, не нуждаясь в дополнительных изменениях. Однако если навигация используется для доступа к свойствам внешнего ключа, код приложения нужно либо ограничить только обычными переходами, либо обновить, чтобы он мог выполнять соответствующие действия как для обычной, так и для пропускной навигации.

<a name="collection-distinct-groupby"></a>

### <a name="some-queries-with-correlated-collection-that-also-use-distinct-or-groupby-are-no-longer-supported"></a>Некоторые запросы с помощью коррелированной коллекции, которые также используют `Distinct` или `GroupBy`, больше не поддерживаются.

[Отслеживание проблемы № 15873](https://github.com/dotnet/efcore/issues/15873)

**Старое поведение**

Ранее мы позволяли выполнять запросы, включающие коррелированные коллекции с последующим свойством `GroupBy` и некоторые запросы с использованием `Distinct`.

Пример GroupBy:

```csharp
context.Parents
    .Select(p => p.Children
        .GroupBy(c => c.School)
        .Select(g => g.Key))
```

Пример `Distinct`, в частности запросы `Distinct`, в которых внутренняя проекция коллекции не содержит первичный ключ:

```csharp
context.Parents
    .Select(p => p.Children
        .Select(c => c.School)
        .Distinct())
```

Эти запросы могли возвращать неверные результаты, если внутренняя коллекция содержала дубликаты, однако работала должным образом, если все элементы во внутренней коллекции являлись уникальными.

**Новое поведение**

Эти запросы больше не поддерживаются. Создается исключение, указывающее, что у нас недостаточно сведений для правильного создания результатов.

**Причина**

В сценариях с коррелированными коллекциями, чтобы назначить сущность коллекции правильному родительскому объекту, нужно знать первичный ключ сущности. Если внутренняя коллекция не использует `GroupBy` или `Distinct`, отсутствующий первичный ключ можно просто добавить в проекцию. Однако при использовании `GroupBy` и `Distinct` это не удастся сделать, так как такое действие приведет к изменению результата операции `GroupBy` или `Distinct`.

**Решение проблемы**

Перепишите запрос, чтобы не использовать операции `GroupBy` или `Distinct` во внутренней коллекции, и выполните эти операции на клиенте.

```csharp
context.Parents
    .Select(p => p.Children.Select(c => c.School))
    .ToList()
    .Select(x => x.GroupBy(c => c).Select(g => g.Key))
```

```csharp
context.Parents
    .Select(p => p.Children.Select(c => c.School))
    .ToList()
    .Select(x => x.Distinct())
```

<a name="queryable-projection"></a>

### <a name="using-a-collection-of-queryable-type-in-projection-is-not-supported"></a>Использование коллекции запрашиваемого типа в проекции не поддерживается

[Отслеживание проблемы № 16314](https://github.com/dotnet/efcore/issues/16314)

**Старое поведение**

Ранее в отдельных случаях коллекцию запрашиваемых типов можно было использовать в проекции, например как аргумент для конструктора `List<T>`:

```csharp
context.Blogs
    .Select(b => new List<Post>(context.Posts.Where(p => p.BlogId == b.Id)))
```

**Новое поведение**

Эти запросы больше не поддерживаются. Создается исключение с указанием на невозможность создания объекта запрашиваемого типа и предложением того, как это можно исправить.

**Причина**

Мы не можем реализовать объект запрашиваемого типа, поэтому такие объекты автоматически создавались с помощью типа `List<T>`. Это часто приводило к выводу исключения из-за несоответствия типов, которое было непонятным и могло быть неожиданным для некоторых пользователей. Мы решили распознать шаблон и выдать более осмысленное исключение.

**Решение проблемы**

Добавьте вызов `ToList()` после запрашиваемого объекта в проекции:

```csharp
context.Blogs.Select(b => context.Posts.Where(p => p.BlogId == b.Id).ToList())
```
