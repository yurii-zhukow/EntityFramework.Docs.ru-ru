---
title: Сравнение одиночных и разделенных запросов в EF Core
description: Преобразование запроса в одиночный и разделенный запросы в SQL с помощью Entity Framework Core
author: smitpatel
ms.date: 10/03/2019
uid: core/querying/single-split-queries
ms.openlocfilehash: 1c99d931c01b99de199710ffe661e1aac7a37263
ms.sourcegitcommit: f3512e3a98e685a3ba409c1d0157ce85cc390cf4
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2020
ms.locfileid: "94431204"
---
# <a name="single-vs-split-queries"></a>Сравнение одиночных и разделенных запросов

## <a name="single-queries"></a>Отдельные запросы

В реляционных базах данных все связанные сущности загружаются с помощью запросов JOIN в одиночном запросе.

```sql
SELECT [b].[BlogId], [b].[OwnerId], [b].[Rating], [b].[Url], [p].[PostId], [p].[AuthorId], [p].[BlogId], [p].[Content], [p].[Rating], [p].[Title]
FROM [Blogs] AS [b]
LEFT JOIN [Post] AS [p] ON [b].[BlogId] = [p].[BlogId]
ORDER BY [b].[BlogId], [p].[PostId]
```

Если в обычном блоге есть несколько связанных записей, тогда строки для этих записей будут дублировать данные блога. Такое дублирование приводит к возникновению "картезианского взрыва" (нарушение корректности синхронизации). Чем больше связей "один ко многим" будет загружено, тем большим будет объем дублирующихся данных, что негативно повлияет на производительность приложения.

## <a name="split-queries"></a>Разделенные запросы

> [!NOTE]
> Эта возможность появилась в EF Core 5.0. Это работает только при использовании `Include`. [Эта проблема](https://github.com/dotnet/efcore/issues/21234) заключается в поддержке отслеживания разделенного запроса при загрузке связанных данных в проекции без `Include`.

EF позволяет вам указать, что конкретный запрос LINQ нужно *разделить* на несколько SQL-запросов. Вместо запросов JOIN разделенные запросы создают дополнительный SQL-запрос для каждой включенной навигации по коллекции:

[!code-csharp[Main](../../../samples/core/Querying/RelatedData/Program.cs?name=AsSplitQuery&highlight=5)]

Будет создан следующий SQL-запрос:

```sql
SELECT [b].[BlogId], [b].[OwnerId], [b].[Rating], [b].[Url]
FROM [Blogs] AS [b]
ORDER BY [b].[BlogId]

SELECT [p].[PostId], [p].[AuthorId], [p].[BlogId], [p].[Content], [p].[Rating], [p].[Title], [b].[BlogId]
FROM [Blogs] AS [b]
INNER JOIN [Post] AS [p] ON [b].[BlogId] = [p].[BlogId]
ORDER BY [b].[BlogId]
```

> [!NOTE]
> Сущности со связями "один к одному" всегда загружаются с помощью запросов JOIN в одном запросе, так как они не влияют на производительность.

## <a name="enabling-split-queries-globally"></a>Глобальное включение разделения запросов

Можно также настроить разделение запросов по умолчанию для контекста приложения.

[!code-csharp[Main](../../../samples/core/Querying/RelatedData/SplitQueriesBloggingContext.cs?name=QuerySplittingBehaviorSplitQuery&highlight=6)]

Если разделение запросов настроено по умолчанию, можно по-прежнему настроить определенные запросы для выполнения в виде отдельных запросов.

[!code-csharp[Main](../../../samples/core/Querying/RelatedData/Program.cs?name=AsSingleQuery&highlight=5)]

EF Core по умолчанию использует режим одиночных запросов без всякой конфигурации. Поскольку это может вызвать проблемы с производительностью, EF Core выдает предупреждение при соблюдении следующих условий:

- EF Core обнаруживает, что запрос загружает несколько коллекций.
- Пользователь не настроил режим разбиения запроса глобально.
- Пользователь не использовал в запросе оператор `AsSingleQuery`/`AsSplitQuery`.

Чтобы отключить предупреждение, настройте режим разбиения запроса глобально или на уровне запроса, использовав соответствующее значение.

## <a name="characteristics-of-split-queries"></a>Характеристики разделенных запросов

Хотя разделение запросов позволяет избежать проблем с производительностью, связанных с запросами JOIN и картезианским взрывом, этот способ также имеет некоторые недостатки.

- Большинство баз данных обеспечивают согласованность данных для отдельных запросов, но не для нескольких запросов. Если при выполнении запросов параллельно выполняется обновление базы данных, результирующие данные могут оказаться несогласованными. Для предотвращения этого можно включить запросы в сериализуемую транзакцию или транзакцию моментального снимка, хотя это также может ухудшить производительность. Дополнительные сведения см. в документации конкретной базы данных.
- В настоящее время каждый запрос подразумевает дополнительный сетевой цикл обмена данными с базой данных. Множественный сетевой обмен данными может привести к снижению производительности, особенно если задержка при обращении к базе данных высока (например, в случае облачных служб).
- Хотя некоторые базы данных позволяют одновременно принимать результаты выполнения нескольких запросов (SQL Server с MARS, Sqlite), большинство из них разрешают выполнение только одного запроса на определенный момент времени. Поэтому перед выполнением последующих запросов все результаты предыдущих запросов необходимо поместить в буфер памяти приложения, что приводит к увеличению требований к памяти.

К сожалению, единой стратегии загрузки связанных сущностей, которая подходит для всех сценариев, не существует. Взвешенно оцените преимущества и недостатки использования отдельных и разделенных запросов и выберите оптимальный подход.
