---
title: Выполнение в клиенте и на сервере — EF Core
author: smitpatel
ms.date: 10/03/2019
ms.assetid: 8b6697cc-7067-4dc2-8007-85d80503d123
uid: core/querying/client-eval
ms.openlocfilehash: 429fec2d2da6eb8910ac20531455ec8183096ec6
ms.sourcegitcommit: ebfd3382fc583bc90f0da58e63d6e3382b30aa22
ms.contentlocale: ru-RU
ms.lasthandoff: 06/25/2020
ms.locfileid: "85370426"
---
# <a name="client-vs-server-evaluation"></a><span data-ttu-id="1b887-102">Выполнение в клиенте и на сервере</span><span class="sxs-lookup"><span data-stu-id="1b887-102">Client vs. Server Evaluation</span></span>

<span data-ttu-id="1b887-103">Как правило, Entity Framework Core пытается выполнить как можно большую часть работы по вычислению запроса на сервере.</span><span class="sxs-lookup"><span data-stu-id="1b887-103">As a general rule, Entity Framework Core attempts to evaluate a query on the server as much as possible.</span></span> <span data-ttu-id="1b887-104">Некоторые части запроса преобразуются в параметры, которые могут вычисляться на стороне клиента.</span><span class="sxs-lookup"><span data-stu-id="1b887-104">EF Core converts parts of the query into parameters, which it can evaluate on the client side.</span></span> <span data-ttu-id="1b887-105">Остальные части запроса (вместе с созданными параметрами) передаются поставщику базы данных, который должен определить эквивалентный запрос к базе данных для вычисления на сервере.</span><span class="sxs-lookup"><span data-stu-id="1b887-105">The rest of the query (along with the generated parameters) is given to the database provider to determine the equivalent database query to evaluate on the server.</span></span> <span data-ttu-id="1b887-106">EF Core поддерживает вычисление на стороне клиента в проекции верхнего уровня (в основном это последний вызов `Select()`).</span><span class="sxs-lookup"><span data-stu-id="1b887-106">EF Core supports partial client evaluation in the top-level projection (essentially, the last call to `Select()`).</span></span> <span data-ttu-id="1b887-107">Если проекцию верхнего уровня в запросе невозможно преобразовать на стороне сервера, EF Core получает необходимые данные с сервера и вычисляет оставшиеся части запроса на стороне клиента.</span><span class="sxs-lookup"><span data-stu-id="1b887-107">If the top-level projection in the query can't be translated to the server, EF Core will fetch any required data from the server and evaluate remaining parts of the query on the client.</span></span> <span data-ttu-id="1b887-108">Если EF Core обнаруживает выражение в любом месте, кроме проекции верхнего уровня, которую невозможно преобразовать на стороне сервера, то возникает исключение времени выполнения.</span><span class="sxs-lookup"><span data-stu-id="1b887-108">If EF Core detects an expression, in any place other than the top-level projection, which can't be translated to the server, then it throws a runtime exception.</span></span> <span data-ttu-id="1b887-109">Сведения о том, как EF Core определяет, что нельзя преобразовать на стороне сервера, см. в статье [Как работают запросы](xref:core/querying/how-query-works).</span><span class="sxs-lookup"><span data-stu-id="1b887-109">See [How queries work](xref:core/querying/how-query-works) to understand how EF Core determines what can't be translated to server.</span></span>

> [!NOTE]
> <span data-ttu-id="1b887-110">До версии 3.0 платформа Entity Framework Core поддерживала вычисление любой части запроса на стороне клиента.</span><span class="sxs-lookup"><span data-stu-id="1b887-110">Prior to version 3.0, Entity Framework Core supported client evaluation anywhere in the query.</span></span> <span data-ttu-id="1b887-111">Дополнительные сведения см. в разделе [Предыдущие версии](#previous-versions).</span><span class="sxs-lookup"><span data-stu-id="1b887-111">For more information, see the [previous versions section](#previous-versions).</span></span>

> [!TIP]
> <span data-ttu-id="1b887-112">Для этой статьи вы можете скачать [пример](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying) из репозитория GitHub.</span><span class="sxs-lookup"><span data-stu-id="1b887-112">You can view this article's [sample](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying) on GitHub.</span></span>

## <a name="client-evaluation-in-the-top-level-projection"></a><span data-ttu-id="1b887-113">Вычисление на стороне клиента в проекции верхнего уровня</span><span class="sxs-lookup"><span data-stu-id="1b887-113">Client evaluation in the top-level projection</span></span>

<span data-ttu-id="1b887-114">В приведенном ниже примере вспомогательный метод используется для стандартизации URL-адресов блогов, которые возвращаются из базы данных SQL Server.</span><span class="sxs-lookup"><span data-stu-id="1b887-114">In the following example, a helper method is used to standardize URLs for blogs, which are returned from a SQL Server database.</span></span> <span data-ttu-id="1b887-115">Так как поставщик SQL Server не знает, как реализован этот метод, его невозможно преобразовать в SQL.</span><span class="sxs-lookup"><span data-stu-id="1b887-115">Since the SQL Server provider has no insight into how this method is implemented, it isn't possible to translate it into SQL.</span></span> <span data-ttu-id="1b887-116">Все остальные аспекты запроса выполняются в базе данных, но передача возвращаемого `URL` с помощью этого метода выполняется в клиенте.</span><span class="sxs-lookup"><span data-stu-id="1b887-116">All other aspects of the query are evaluated in the database, but passing the returned `URL` through this method is done on the client.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ClientProjection)]

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ClientMethod)]

## <a name="unsupported-client-evaluation"></a><span data-ttu-id="1b887-117">Неподдерживаемое вычисление на стороне клиента</span><span class="sxs-lookup"><span data-stu-id="1b887-117">Unsupported client evaluation</span></span>

<span data-ttu-id="1b887-118">Хотя вычисление на стороне клиента полезно, иногда оно может приводить к снижению производительности.</span><span class="sxs-lookup"><span data-stu-id="1b887-118">While client evaluation is useful, it can result in poor performance sometimes.</span></span> <span data-ttu-id="1b887-119">Рассмотрим приведенный ниже запрос, в котором вспомогательный метод теперь используется в фильтре Where.</span><span class="sxs-lookup"><span data-stu-id="1b887-119">Consider the following query, in which the helper method is now used in a where filter.</span></span> <span data-ttu-id="1b887-120">Так как фильтр невозможно применить в базе данных, все данные необходимо извлечь в память, чтобы применить фильтр в клиенте.</span><span class="sxs-lookup"><span data-stu-id="1b887-120">Because the filter can't be applied in the database, all the data needs to be pulled into memory to apply the filter on the client.</span></span> <span data-ttu-id="1b887-121">В зависимости от фильтра и объема данных на сервере вычисление на стороне клиента может привести к низкой производительности.</span><span class="sxs-lookup"><span data-stu-id="1b887-121">Based on the filter and the amount of data on the server, client evaluation could result in poor performance.</span></span> <span data-ttu-id="1b887-122">Поэтому платформа Entity Framework Core блокирует такое вычисление и выдает исключение во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="1b887-122">So Entity Framework Core blocks such client evaluation and throws a runtime exception.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ClientWhere)]

## <a name="explicit-client-evaluation"></a><span data-ttu-id="1b887-123">Явное вычисление на стороне клиента</span><span class="sxs-lookup"><span data-stu-id="1b887-123">Explicit client evaluation</span></span>

<span data-ttu-id="1b887-124">В некоторых случаях, например, в указанных ниже, может потребоваться явное принудительное вычисление на стороне клиента.</span><span class="sxs-lookup"><span data-stu-id="1b887-124">You may need to force into client evaluation explicitly in certain cases like following</span></span>

- <span data-ttu-id="1b887-125">Объем данных мал, поэтому вычисление в клиенте не приводит к значительному снижению производительности.</span><span class="sxs-lookup"><span data-stu-id="1b887-125">The amount of data is small so that evaluating on the client doesn't incur a huge performance penalty.</span></span>
- <span data-ttu-id="1b887-126">Используемый оператор LINQ не преобразуется на стороне сервера.</span><span class="sxs-lookup"><span data-stu-id="1b887-126">The LINQ operator being used has no server-side translation.</span></span>

<span data-ttu-id="1b887-127">В таких случаях можно явно согласиться на вычисление в клиенте, вызвав такой метод, как `AsEnumerable` или `ToList` (`AsAsyncEnumerable` или `ToListAsync` при асинхронном выполнении).</span><span class="sxs-lookup"><span data-stu-id="1b887-127">In such cases, you can explicitly opt into client evaluation by calling methods like `AsEnumerable` or `ToList` (`AsAsyncEnumerable` or `ToListAsync` for async).</span></span> <span data-ttu-id="1b887-128">При использовании `AsEnumerable` результаты передаются в потоковом режиме, но при использовании `ToList` производится буферизация путем создания списка, который также занимает дополнительную память.</span><span class="sxs-lookup"><span data-stu-id="1b887-128">By using `AsEnumerable` you would be streaming the results, but using `ToList` would cause buffering by creating a list, which also takes additional memory.</span></span> <span data-ttu-id="1b887-129">Однако если перечисление выполняется несколько раз, сохранять результаты в списке выгоднее, так как запрос к базе данных только один.</span><span class="sxs-lookup"><span data-stu-id="1b887-129">Though if you're enumerating multiple times, then storing results in a list helps more since there's only one query to the database.</span></span> <span data-ttu-id="1b887-130">Вам следует оценить, какой метод полезнее в конкретном случае.</span><span class="sxs-lookup"><span data-stu-id="1b887-130">Depending on the particular usage, you should evaluate which method is more useful for the case.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ExplicitClientEval)]

## <a name="potential-memory-leak-in-client-evaluation"></a><span data-ttu-id="1b887-131">Возможная утечка памяти при вычислении на стороне клиента</span><span class="sxs-lookup"><span data-stu-id="1b887-131">Potential memory leak in client evaluation</span></span>

<span data-ttu-id="1b887-132">Так как преобразование и компиляция запросов требуют много ресурсов, EF Core кэширует скомпилированный план запроса.</span><span class="sxs-lookup"><span data-stu-id="1b887-132">Since query translation and compilation are expensive, EF Core caches the compiled query plan.</span></span> <span data-ttu-id="1b887-133">Кэшированный делегат может использовать клиентский код при вычислении проекции верхнего уровня на стороне клиента.</span><span class="sxs-lookup"><span data-stu-id="1b887-133">The cached delegate may use client code while doing client evaluation of top-level projection.</span></span> <span data-ttu-id="1b887-134">EF Core создает параметры для вычисляемых клиентом частей дерева и повторно использует план запроса, заменяя значения параметров.</span><span class="sxs-lookup"><span data-stu-id="1b887-134">EF Core generates parameters for the client-evaluated parts of the tree and reuses the query plan by replacing the parameter values.</span></span> <span data-ttu-id="1b887-135">Однако некоторые константы в дереве выражения невозможно преобразовать в параметры.</span><span class="sxs-lookup"><span data-stu-id="1b887-135">But certain constants in the expression tree can't be converted into parameters.</span></span> <span data-ttu-id="1b887-136">Если кэшированный делегат содержит такие константы, эти объекты не могут быть собраны сборщиком мусора, так как на них по-прежнему есть ссылки.</span><span class="sxs-lookup"><span data-stu-id="1b887-136">If the cached delegate contains such constants, then those objects can't be garbage collected since they're still being referenced.</span></span> <span data-ttu-id="1b887-137">Если такой объект содержит DbContext или другие службы, это может привести к росту потребления памяти приложением с течением времени.</span><span class="sxs-lookup"><span data-stu-id="1b887-137">If such an object contains a DbContext or other services in it, then it could cause the memory usage of the app to grow over time.</span></span> <span data-ttu-id="1b887-138">Такое поведение обычно является признаком утечки памяти.</span><span class="sxs-lookup"><span data-stu-id="1b887-138">This behavior is generally a sign of a memory leak.</span></span> <span data-ttu-id="1b887-139">EF Core создает исключение всякий раз, когда обнаруживает константы типа, который нельзя сопоставить с помощью текущего поставщика базы данных.</span><span class="sxs-lookup"><span data-stu-id="1b887-139">EF Core throws an exception whenever it comes across constants of a type that can't be mapped using current database provider.</span></span> <span data-ttu-id="1b887-140">Ниже приведены распространенные причины и способы решения.</span><span class="sxs-lookup"><span data-stu-id="1b887-140">Common causes and their solutions are as follows:</span></span>

- <span data-ttu-id="1b887-141">**Использование метода экземпляра**. При использовании методов экземпляра в клиентской проекции дерево выражения содержит константу экземпляра.</span><span class="sxs-lookup"><span data-stu-id="1b887-141">**Using an instance method**: When using instance methods in a client projection, the expression tree contains a constant of the instance.</span></span> <span data-ttu-id="1b887-142">Если метод не использует какие бы то ни было данные из экземпляра, рекомендуется сделать его статическим.</span><span class="sxs-lookup"><span data-stu-id="1b887-142">If your method doesn't use any data from the instance, consider making the method static.</span></span> <span data-ttu-id="1b887-143">Если в теле метода требуются данные экземпляра, передайте их в метод в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="1b887-143">If you need instance data in the method body, then pass the specific data as an argument to the method.</span></span>
- <span data-ttu-id="1b887-144">**Передача константных аргументов в метод**. Обычно такое происходит при использовании `this` в аргументе клиентского метода.</span><span class="sxs-lookup"><span data-stu-id="1b887-144">**Passing constant arguments to method**: This case arises generally by using `this` in an argument to client method.</span></span> <span data-ttu-id="1b887-145">Рекомендуем разделить аргумент на несколько скалярных аргументов, которые могут быть сопоставлены поставщиком базы данных.</span><span class="sxs-lookup"><span data-stu-id="1b887-145">Consider splitting the argument in to multiple scalar arguments, which can be mapped by the database provider.</span></span>
- <span data-ttu-id="1b887-146">**Другие константы**. Если константа используется в любом другом случае, оцените, требуется ли она при обработке.</span><span class="sxs-lookup"><span data-stu-id="1b887-146">**Other constants**: If a constant is come across in any other case, then you can evaluate whether the constant is needed in processing.</span></span> <span data-ttu-id="1b887-147">Если константа необходима или если ни одно из предыдущих решений не подходит, создайте локальную переменную для хранения значения и используйте ее в запросе.</span><span class="sxs-lookup"><span data-stu-id="1b887-147">If it's necessary to have the constant, or if you can't use a solution from the above cases, then create a local variable to store the value and use local variable in the query.</span></span> <span data-ttu-id="1b887-148">EF Core преобразует локальную переменную в параметр.</span><span class="sxs-lookup"><span data-stu-id="1b887-148">EF Core will convert the local variable into a parameter.</span></span>

## <a name="previous-versions"></a><span data-ttu-id="1b887-149">Предыдущие версии</span><span class="sxs-lookup"><span data-stu-id="1b887-149">Previous versions</span></span>

<span data-ttu-id="1b887-150">Следующий раздел относится к версиям EF Core до 3.0.</span><span class="sxs-lookup"><span data-stu-id="1b887-150">The following section applies to EF Core versions before 3.0.</span></span>

<span data-ttu-id="1b887-151">Более старые версии EF Core поддерживали вычисление на стороне клиента в любой части запроса, а не только в проекции верхнего уровня.</span><span class="sxs-lookup"><span data-stu-id="1b887-151">Older EF Core versions supported client evaluation in any part of the query--not just the top-level projection.</span></span> <span data-ttu-id="1b887-152">Поэтому запросы, наподобие приведенного в разделе [Неподдерживаемое вычисление на стороне клиента](#unsupported-client-evaluation), работали правильно.</span><span class="sxs-lookup"><span data-stu-id="1b887-152">That's why queries similar to one posted under the [Unsupported client evaluation](#unsupported-client-evaluation) section worked correctly.</span></span> <span data-ttu-id="1b887-153">Так как такое поведение могло приводить к неочевидным проблемам с производительностью, платформа EF Core добавляла в журнал предупреждение о вычислении в клиенте.</span><span class="sxs-lookup"><span data-stu-id="1b887-153">Since this behavior could cause unnoticed performance issues, EF Core logged a client evaluation warning.</span></span> <span data-ttu-id="1b887-154">Дополнительные сведения о просмотре выходных данных журнала см. в статье [Ведение журнала](xref:core/miscellaneous/logging).</span><span class="sxs-lookup"><span data-stu-id="1b887-154">For more information on viewing logging output, see [Logging](xref:core/miscellaneous/logging).</span></span>

<span data-ttu-id="1b887-155">Кроме того, платформа EF Core позволяла изменять поведение по умолчанию: либо создавать исключение, либо ничего не делать при вычислении в клиенте (исключая вычисление в проекции).</span><span class="sxs-lookup"><span data-stu-id="1b887-155">Optionally EF Core allowed you to change the default behavior to either throw an exception or do nothing when doing client evaluation (except for in the projection).</span></span> <span data-ttu-id="1b887-156">При выборе создания исключения поведение становилось таким же, как в версии 3.0.</span><span class="sxs-lookup"><span data-stu-id="1b887-156">The exception throwing behavior would make it similar to the behavior in 3.0.</span></span> <span data-ttu-id="1b887-157">Чтобы изменить поведение, необходимо настроить предупреждения при настройке параметров для контекста — обычно в `DbContext.OnConfiguring` или в `Startup.cs`, если используется ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="1b887-157">To change the behavior, you need to configure warnings while setting up the options for your context - typically in `DbContext.OnConfiguring`, or in `Startup.cs` if you're using ASP.NET Core.</span></span>

```csharp
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder
        .UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=EFQuerying;Trusted_Connection=True;")
        .ConfigureWarnings(warnings => warnings.Throw(RelationalEventId.QueryClientEvaluationWarning));
}
```
