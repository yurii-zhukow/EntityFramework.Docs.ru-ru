---
title: Сравнение запросов с отслеживанием и без отслеживания — EF Core
description: Сведения о запросах с отслеживанием и без отслеживания в Entity Framework Core
author: smitpatel
ms.date: 11/09/2020
uid: core/querying/tracking
ms.openlocfilehash: b4c059f9a9b726697009589271e007bd1d2afd56
ms.sourcegitcommit: f3512e3a98e685a3ba409c1d0157ce85cc390cf4
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2020
ms.locfileid: "94430447"
---
# <a name="tracking-vs-no-tracking-queries"></a><span data-ttu-id="c23a7-103">Сравнение запросов с отслеживанием и без отслеживания</span><span class="sxs-lookup"><span data-stu-id="c23a7-103">Tracking vs. No-Tracking Queries</span></span>

<span data-ttu-id="c23a7-104">Отслеживание поведения контролирует, будет ли Entity Framework Core хранить информацию об экземпляре сущности в средстве отслеживания изменений.</span><span class="sxs-lookup"><span data-stu-id="c23a7-104">Tracking behavior controls if Entity Framework Core will keep information about an entity instance in its change tracker.</span></span> <span data-ttu-id="c23a7-105">Если сущность отслеживается, любые изменения, обнаруженные в сущности, будут сохраняться в базе данных во время операции `SaveChanges()`.</span><span class="sxs-lookup"><span data-stu-id="c23a7-105">If an entity is tracked, any changes detected in the entity will be persisted to the database during `SaveChanges()`.</span></span> <span data-ttu-id="c23a7-106">EF Core также будет исправлять свойства навигации между сущностями в результатах запроса отслеживания и сущностями, которые находятся в средстве отслеживания изменений.</span><span class="sxs-lookup"><span data-stu-id="c23a7-106">EF Core will also fix up navigation properties between the entities in a tracking query result and the entities that are in the change tracker.</span></span>

> [!NOTE]
> <span data-ttu-id="c23a7-107">[Типы сущностей без ключей](xref:core/modeling/keyless-entity-types) не отслеживаются.</span><span class="sxs-lookup"><span data-stu-id="c23a7-107">[Keyless entity types](xref:core/modeling/keyless-entity-types) are never tracked.</span></span> <span data-ttu-id="c23a7-108">Каждый раз, когда в этой статье упоминаются типы сущностей, имеются ввиду типы сущностей, для которых определен ключ.</span><span class="sxs-lookup"><span data-stu-id="c23a7-108">Wherever this article mentions entity types, it refers to entity types which have a key defined.</span></span>

> [!TIP]  
> <span data-ttu-id="c23a7-109">Для этой статьи вы можете скачать [пример](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying/Tracking) из репозитория GitHub.</span><span class="sxs-lookup"><span data-stu-id="c23a7-109">You can view this article's [sample](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying/Tracking) on GitHub.</span></span>

## <a name="tracking-queries"></a><span data-ttu-id="c23a7-110">Отслеживания запросов</span><span class="sxs-lookup"><span data-stu-id="c23a7-110">Tracking queries</span></span>

<span data-ttu-id="c23a7-111">По умолчанию запросы, возвращающие типы сущностей, отслеживаются.</span><span class="sxs-lookup"><span data-stu-id="c23a7-111">By default, queries that return entity types are tracking.</span></span> <span data-ttu-id="c23a7-112">Что означает, что вы можете внести изменения в эти экземпляры сущностей и сохранить эти изменения с помощью операции `SaveChanges()`.</span><span class="sxs-lookup"><span data-stu-id="c23a7-112">Which means you can make changes to those entity instances and have those changes persisted by `SaveChanges()`.</span></span> <span data-ttu-id="c23a7-113">В следующем примере изменение рейтинга блогов будет обнаружено и сохранено в базе данных во время операции `SaveChanges()`.</span><span class="sxs-lookup"><span data-stu-id="c23a7-113">In the following example, the change to the blogs rating will be detected and persisted to the database during `SaveChanges()`.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#Tracking)]

<span data-ttu-id="c23a7-114">После возврата результатов в запросе отслеживания EF Core проверяет, находится ли сущность в контексте.</span><span class="sxs-lookup"><span data-stu-id="c23a7-114">When the results are returned in a tracking query, EF Core will check if the entity is already in the context.</span></span> <span data-ttu-id="c23a7-115">Если EF Core находит сущность, тогда возвращается этот же экземпляр.</span><span class="sxs-lookup"><span data-stu-id="c23a7-115">If EF Core finds an existing entity, then the same instance is returned.</span></span> <span data-ttu-id="c23a7-116">EF Core не перезаписывает текущие и исходные значения свойств сущности в записи значениями базы данных.</span><span class="sxs-lookup"><span data-stu-id="c23a7-116">EF Core won't overwrite current and original values of the entity's properties in the entry with the database values.</span></span> <span data-ttu-id="c23a7-117">Если сущность еще не существует в контексте, EF Core создает новый экземпляр сущности и присоединяет его к контексту.</span><span class="sxs-lookup"><span data-stu-id="c23a7-117">If the entity isn't found in the context, then EF Core will create new entity instance and attach it to the context.</span></span> <span data-ttu-id="c23a7-118">Результаты запросов не содержат сущности, которые добавлены в контекст, но не сохранены в базе данных.</span><span class="sxs-lookup"><span data-stu-id="c23a7-118">Query results don't contain any entity, which is added to the context but not yet saved to the database.</span></span>

## <a name="no-tracking-queries"></a><span data-ttu-id="c23a7-119">Отключение отслеживания запросов</span><span class="sxs-lookup"><span data-stu-id="c23a7-119">No-tracking queries</span></span>

<span data-ttu-id="c23a7-120">Никакие запросы отслеживания не полезны, когда результаты используются в сценарии только для чтения.</span><span class="sxs-lookup"><span data-stu-id="c23a7-120">No tracking queries are useful when the results are used in a read-only scenario.</span></span> <span data-ttu-id="c23a7-121">Они быстрее выполняются, потому что нет необходимости настраивать информацию об отслеживании изменений.</span><span class="sxs-lookup"><span data-stu-id="c23a7-121">They're quicker to execute because there's no need to set up the change tracking information.</span></span> <span data-ttu-id="c23a7-122">Если вам не нужно обновлять сущности, извлеченные из базы данных, то следует использовать запрос без отслеживания.</span><span class="sxs-lookup"><span data-stu-id="c23a7-122">If you don't need to update the entities retrieved from the database, then a no-tracking query should be used.</span></span> <span data-ttu-id="c23a7-123">Вы можете отключить отслеживание для отдельного запроса.</span><span class="sxs-lookup"><span data-stu-id="c23a7-123">You can swap an individual query to be no-tracking.</span></span> <span data-ttu-id="c23a7-124">Запрос на отслеживание не выдает результаты на основе содержимого в базе данных, независимо от локальных изменений и добавленных сущностей.</span><span class="sxs-lookup"><span data-stu-id="c23a7-124">No tracking query will also give you results based on what is in the database disregarding any local changes or added entities.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#NoTracking)]

<span data-ttu-id="c23a7-125">Вы также можете изменить поведение отслеживания по умолчанию на уровне экземпляра контекста:</span><span class="sxs-lookup"><span data-stu-id="c23a7-125">You can also change the default tracking behavior at the context instance level:</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ContextDefaultTrackingBehavior)]

## <a name="identity-resolution"></a><span data-ttu-id="c23a7-126">Разрешение идентификатора</span><span class="sxs-lookup"><span data-stu-id="c23a7-126">Identity resolution</span></span>

<span data-ttu-id="c23a7-127">Поскольку запрос отслеживания использует отслеживание изменений, EF Core выполнит разрешение удостоверения в запросе отслеживания.</span><span class="sxs-lookup"><span data-stu-id="c23a7-127">Since a tracking query uses the change tracker, EF Core will do identity resolution in a tracking query.</span></span> <span data-ttu-id="c23a7-128">При материализации сущности, если она уже отслеживается, EF Core вернет тот же экземпляр сущности из отслеживания изменений.</span><span class="sxs-lookup"><span data-stu-id="c23a7-128">When materializing an entity, EF Core will return the same entity instance from the change tracker if it's already being tracked.</span></span> <span data-ttu-id="c23a7-129">Если результат содержит одну и ту же сущность несколько раз, вы получаете один и тот же экземпляр для каждого события.</span><span class="sxs-lookup"><span data-stu-id="c23a7-129">If the result contains same entity multiple times, you get back same instance for each occurrence.</span></span> <span data-ttu-id="c23a7-130">Запросы без отслеживания не используют отслеживание изменений и не выполняют разрешение удостоверения.</span><span class="sxs-lookup"><span data-stu-id="c23a7-130">No-tracking queries don't use the change tracker and don't do identity resolution.</span></span> <span data-ttu-id="c23a7-131">Таким образом вы получаете новый экземпляр сущности, даже если одна и та же сущность содержится в результатах несколько раз.</span><span class="sxs-lookup"><span data-stu-id="c23a7-131">So you get back new instance of entity even when the same entity is contained in the result multiple times.</span></span> <span data-ttu-id="c23a7-132">Такая реакция на событие была иной в версиях до EF Core 3.0, см. [предыдущие версии](#previous-versions).</span><span class="sxs-lookup"><span data-stu-id="c23a7-132">This behavior was different in versions before EF Core 3.0, see [previous versions](#previous-versions).</span></span>

<span data-ttu-id="c23a7-133">Начиная с EF Core 5.0, эти два поведения можно комбинировать в одном запросе.</span><span class="sxs-lookup"><span data-stu-id="c23a7-133">Starting with EF Core 5.0, you can combine both of the above behaviors in same query.</span></span> <span data-ttu-id="c23a7-134">Это означает, что вы можете использовать запрос без отслеживания, выполняющий в результатах разрешение идентификатора.</span><span class="sxs-lookup"><span data-stu-id="c23a7-134">That is, you can have a no tracking query, which will do identity resolution in the results.</span></span> <span data-ttu-id="c23a7-135">Вместе с запрашивающим оператором `AsNoTracking()` добавлен другой оператор `AsNoTrackingWithIdentityResolution()`.</span><span class="sxs-lookup"><span data-stu-id="c23a7-135">Just like `AsNoTracking()` queryable operator, we've added another operator `AsNoTrackingWithIdentityResolution()`.</span></span> <span data-ttu-id="c23a7-136">Кроме того, в перечисление <xref:Microsoft.EntityFrameworkCore.QueryTrackingBehavior> добавлена связанная запись.</span><span class="sxs-lookup"><span data-stu-id="c23a7-136">There's also associated entry added in <xref:Microsoft.EntityFrameworkCore.QueryTrackingBehavior> enum.</span></span> <span data-ttu-id="c23a7-137">При настройке запроса таким образом, чтобы использовать разрешение идентификатора без отслеживания, во время создания результатов запроса используется автономный механизм отслеживания изменений в фоновом режиме, что позволяет реализовать каждый экземпляр.</span><span class="sxs-lookup"><span data-stu-id="c23a7-137">When you configure the query to use identity resolution with no tracking, we use a stand-alone change tracker in the background when generating query results so each instance is materialized only once.</span></span> <span data-ttu-id="c23a7-138">Поскольку средство отслеживания изменений отличается от средства, которое находится в контексте, результаты не отслеживаются по контексту.</span><span class="sxs-lookup"><span data-stu-id="c23a7-138">Since this change tracker is different from the one in the context, the results are not tracked by the context.</span></span> <span data-ttu-id="c23a7-139">После полного перечисления запроса средство отслеживания изменений выходит из области действия и при необходимости выполняется сборка мусора.</span><span class="sxs-lookup"><span data-stu-id="c23a7-139">After the query is enumerated fully, the change tracker goes out of scope and garbage collected as required.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#NoTrackingWithIdentityResolution)]

## <a name="tracking-and-custom-projections"></a><span data-ttu-id="c23a7-140">Отслеживание и пользовательские проекции</span><span class="sxs-lookup"><span data-stu-id="c23a7-140">Tracking and custom projections</span></span>

<span data-ttu-id="c23a7-141">Даже если тип результата запроса не является типом сущности, EF Core будет отслеживать типы сущностей, содержащиеся в результате по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="c23a7-141">Even if the result type of the query isn't an entity type, EF Core will still track entity types contained in the result by default.</span></span> <span data-ttu-id="c23a7-142">В следующем запросе, который возвращает анонимный тип, будут отслеживаться экземпляры `Blog` в результирующем наборе.</span><span class="sxs-lookup"><span data-stu-id="c23a7-142">In the following query, which returns an anonymous type, the instances of `Blog` in the result set will be tracked.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection1)]

<span data-ttu-id="c23a7-143">Если в результирующем наборе содержатся типы сущностей, выходящие из состава LINQ, EF Core будет отслеживать их.</span><span class="sxs-lookup"><span data-stu-id="c23a7-143">If the result set contains entity types coming out from LINQ composition, EF Core will track them.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection2)]

<span data-ttu-id="c23a7-144">Если результирующий набор не содержит типов сущностей, то отслеживание не выполняется.</span><span class="sxs-lookup"><span data-stu-id="c23a7-144">If the result set doesn't contain any entity types, then no tracking is done.</span></span> <span data-ttu-id="c23a7-145">В следующем запросе, мы возвратим анонимный тип с некоторыми значениями из сущности (но не экземплярами фактического типа сущности).</span><span class="sxs-lookup"><span data-stu-id="c23a7-145">In the following query, we return an anonymous type with some of the values from the entity (but no instances of the actual entity type).</span></span> <span data-ttu-id="c23a7-146">Отслеживаемых объектов из запроса не обнаружено.</span><span class="sxs-lookup"><span data-stu-id="c23a7-146">There are no tracked entities coming out of the query.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection3)]

 <span data-ttu-id="c23a7-147">EF Core поддерживает вычисление на стороне клиента в проекции верхнего уровня.</span><span class="sxs-lookup"><span data-stu-id="c23a7-147">EF Core supports doing client evaluation in the top-level projection.</span></span> <span data-ttu-id="c23a7-148">Если EF Core материализует экземпляр сущности для вычисления клиента, она будет отслеживаться.</span><span class="sxs-lookup"><span data-stu-id="c23a7-148">If EF Core materializes an entity instance for client evaluation, it will be tracked.</span></span> <span data-ttu-id="c23a7-149">Здесь, поскольку мы передаем сущности `blog` в метод клиента `StandardizeURL`, EF Core также будет отслеживать экземпляры блогов.</span><span class="sxs-lookup"><span data-stu-id="c23a7-149">Here, since we're passing `blog` entities to the client method `StandardizeURL`, EF Core will track the blog instances too.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ClientProjection)]

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ClientMethod)]

<span data-ttu-id="c23a7-150">EF Core не отслеживает экземпляры сущности без ключа, содержащиеся в результате.</span><span class="sxs-lookup"><span data-stu-id="c23a7-150">EF Core doesn't track the keyless entity instances contained in the result.</span></span> <span data-ttu-id="c23a7-151">Но EF Core отслеживает все остальные экземпляры типов сущностей с ключами в соответствии с правилами, приведенными выше.</span><span class="sxs-lookup"><span data-stu-id="c23a7-151">But EF Core tracks all the other instances of entity types with key according to rules above.</span></span>

<span data-ttu-id="c23a7-152">Некоторые из вышеперечисленных правил работали по-разному до EF Core 3.0.</span><span class="sxs-lookup"><span data-stu-id="c23a7-152">Some of the above rules worked differently before EF Core 3.0.</span></span> <span data-ttu-id="c23a7-153">Дополнительные сведения см. в разделе [Предыдущие версии](#previous-versions).</span><span class="sxs-lookup"><span data-stu-id="c23a7-153">For more information, see [previous versions](#previous-versions).</span></span>

## <a name="previous-versions"></a><span data-ttu-id="c23a7-154">предыдущих версий</span><span class="sxs-lookup"><span data-stu-id="c23a7-154">Previous versions</span></span>

<span data-ttu-id="c23a7-155">До версии 3.0 у EF Core были некоторые различия в способах отслеживания.</span><span class="sxs-lookup"><span data-stu-id="c23a7-155">Before version 3.0, EF Core had some differences in how tracking was done.</span></span> <span data-ttu-id="c23a7-156">Различия заключаются в следующем.</span><span class="sxs-lookup"><span data-stu-id="c23a7-156">Notable differences are as follows:</span></span>

- <span data-ttu-id="c23a7-157">Как поясняется на странице [Вычисление клиента против вычисления сервера](xref:core/querying/client-eval), до версии 3.0. EF Core поддерживал вычисление клиента в любой части запроса.</span><span class="sxs-lookup"><span data-stu-id="c23a7-157">As explained in [Client vs Server Evaluation](xref:core/querying/client-eval) page, EF Core supported client evaluation in any part of the query before version 3.0.</span></span> <span data-ttu-id="c23a7-158">Клиентское вычисление привело к материализации сущностей, которые не были частью результата.</span><span class="sxs-lookup"><span data-stu-id="c23a7-158">Client evaluation caused materialization of entities, which weren't part of the result.</span></span> <span data-ttu-id="c23a7-159">Поэтому EF Core проанализировал результат, чтобы определить, что нужно отслеживать. Эта конструкция имела следующие отличия:</span><span class="sxs-lookup"><span data-stu-id="c23a7-159">So EF Core analyzed the result to detect what to track. This design had certain differences as follows:</span></span>
  - <span data-ttu-id="c23a7-160">Вычисление клиента в проекции, которое вызвало материализацию, но не вернуло материализованный экземпляр сущности, не отслеживалось.</span><span class="sxs-lookup"><span data-stu-id="c23a7-160">Client evaluation in the projection, which caused materialization but didn't return the materialized entity instance wasn't tracked.</span></span> <span data-ttu-id="c23a7-161">Следующий пример не отслеживает сущности `blog`.</span><span class="sxs-lookup"><span data-stu-id="c23a7-161">The following example didn't track `blog` entities.</span></span>
    [!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ClientProjection)]

  - <span data-ttu-id="c23a7-162">В некоторых случаях EF Core не отслеживал объекты, выходящие из состава LINQ.</span><span class="sxs-lookup"><span data-stu-id="c23a7-162">EF Core didn't track the objects coming out of LINQ composition in certain cases.</span></span> <span data-ttu-id="c23a7-163">Следующий пример не отслеживает `Post`.</span><span class="sxs-lookup"><span data-stu-id="c23a7-163">The following example didn't track `Post`.</span></span>
    [!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection2)]

- <span data-ttu-id="c23a7-164">Всякий раз, когда результаты запроса содержали типы сущностей без ключей, весь запрос становится неотслеживаемым.</span><span class="sxs-lookup"><span data-stu-id="c23a7-164">Whenever query results contained keyless entity types, the whole query was made non-tracking.</span></span> <span data-ttu-id="c23a7-165">Что значит, что типы сущностей с ключами в результате тоже не отслеживались.</span><span class="sxs-lookup"><span data-stu-id="c23a7-165">That means that entity types with keys, which are in result weren't being tracked either.</span></span>
- <span data-ttu-id="c23a7-166">EF Core было выполнено разрешение идентификатора в запросе без отслеживания.</span><span class="sxs-lookup"><span data-stu-id="c23a7-166">EF Core did identity resolution in no-tracking query.</span></span> <span data-ttu-id="c23a7-167">Для отслеживания сущностей, которые уже были возвращены, используются слабые ссылки.</span><span class="sxs-lookup"><span data-stu-id="c23a7-167">It used weak references to keep track of entities that had already been returned.</span></span> <span data-ttu-id="c23a7-168">Таким образом, если набор результатов содержит одну и ту же сущность несколько раз, вы получите один и тот же экземпляр для каждого события.</span><span class="sxs-lookup"><span data-stu-id="c23a7-168">So if a result set contained the same entity multiples times, you would get the same instance for each occurrence.</span></span> <span data-ttu-id="c23a7-169">Хотя, если предыдущий результат с тем же идентификатором вышел за рамки видимости и был собран как мусор, EF Core возвращает новый экземпляр.</span><span class="sxs-lookup"><span data-stu-id="c23a7-169">Though if a previous result with the same identity went out of scope and got garbage collected, EF Core returned a new instance.</span></span>
