---
title: Сравнение запросов с отслеживанием и без отслеживания — EF Core
description: Сведения о запросах с отслеживанием и без отслеживания в Entity Framework Core
author: smitpatel
ms.date: 10/10/2019
uid: core/querying/tracking
ms.openlocfilehash: a01446d7aec4d47eda23d4ac056e1c8286d2a281
ms.sourcegitcommit: abda0872f86eefeca191a9a11bfca976bc14468b
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/14/2020
ms.locfileid: "90070969"
---
# <a name="tracking-vs-no-tracking-queries"></a>Сравнение запросов с отслеживанием и без отслеживания

Отслеживание поведения контролирует, будет ли Entity Framework Core хранить информацию об экземпляре сущности в средстве отслеживания изменений. Если сущность отслеживается, любые изменения, обнаруженные в сущности, будут сохраняться в базе данных во время операции `SaveChanges()`. EF Core также будет исправлять свойства навигации между сущностями в результатах запроса отслеживания и сущностями, которые находятся в средстве отслеживания изменений.

> [!NOTE]
> [Типы сущностей без ключей](xref:core/modeling/keyless-entity-types) не отслеживаются. Каждый раз, когда в этой статье упоминаются типы сущностей, имеются ввиду типы сущностей, для которых определен ключ.

> [!TIP]  
> Для этой статьи вы можете скачать [пример](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying) из репозитория GitHub.

## <a name="tracking-queries"></a>Отслеживания запросов

По умолчанию запросы, возвращающие типы сущностей, отслеживаются. Что означает, что вы можете внести изменения в эти экземпляры сущностей и сохранить эти изменения с помощью операции `SaveChanges()`. В следующем примере изменение рейтинга блогов будет обнаружено и сохранено в базе данных во время операции `SaveChanges()`.

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Sample.cs#Tracking)]

## <a name="no-tracking-queries"></a>Отключение отслеживания запросов

Никакие запросы отслеживания не полезны, когда результаты используются в сценарии только для чтения. Они быстрее выполняются, потому что нет необходимости настраивать информацию об отслеживании изменений. Если вам не нужно обновлять сущности, извлеченные из базы данных, то следует использовать запрос без отслеживания. Вы можете отключить отслеживание для отдельного запроса.

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Sample.cs#NoTracking)]

Вы также можете изменить поведение отслеживания по умолчанию на уровне экземпляра контекста:

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Sample.cs#ContextDefaultTrackingBehavior)]

## <a name="identity-resolution"></a>Разрешение идентификатора

Поскольку запрос отслеживания использует отслеживание изменений, EF Core выполнит разрешение удостоверения в запросе отслеживания. При материализации сущности, если она уже отслеживается, EF Core вернет тот же экземпляр сущности из отслеживания изменений. Если результат содержит одну и ту же сущность несколько раз, вы получаете один и тот же экземпляр для каждого события. Запросы без отслеживания не используют отслеживание изменений и не выполняют разрешение удостоверения. Таким образом вы получаете новый экземпляр сущности, даже если одна и та же сущность содержится в результатах несколько раз. Такая реакция на событие была иной в версиях до EF Core 3.0, см. [предыдущие версии](#previous-versions).

## <a name="tracking-and-custom-projections"></a>Отслеживание и пользовательские проекции

Даже если тип результата запроса не является типом сущности, EF Core будет отслеживать типы сущностей, содержащиеся в результате по умолчанию. В следующем запросе, который возвращает анонимный тип, будут отслеживаться экземпляры `Blog` в результирующем наборе.

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Sample.cs#CustomProjection1)]

Если в результирующем наборе содержатся типы сущностей, выходящие из состава LINQ, EF Core будет отслеживать их.

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Sample.cs#CustomProjection2)]

Если результирующий набор не содержит типов сущностей, то отслеживание не выполняется. В следующем запросе, мы возвратим анонимный тип с некоторыми значениями из сущности (но не экземплярами фактического типа сущности). Отслеживаемых объектов из запроса не обнаружено.

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Sample.cs#CustomProjection3)]

 EF Core поддерживает вычисление на стороне клиента в проекции верхнего уровня. Если EF Core материализует экземпляр сущности для вычисления клиента, она будет отслеживаться. Здесь, поскольку мы передаем сущности `blog` в метод клиента `StandardizeURL`, EF Core также будет отслеживать экземпляры блогов.

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Sample.cs#ClientProjection)]

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Sample.cs#ClientMethod)]

EF Core не отслеживает экземпляры сущности без ключа, содержащиеся в результате. Но EF Core отслеживает все остальные экземпляры типов сущностей с ключами в соответствии с правилами, приведенными выше.

Некоторые из вышеперечисленных правил работали по-разному до EF Core 3.0. Дополнительные сведения см. в разделе [Предыдущие версии](#previous-versions).

## <a name="previous-versions"></a>предыдущих версий

До версии 3.0 у EF Core были некоторые различия в способах отслеживания. Различия заключаются в следующем.

- Как поясняется на странице [Вычисление клиента против вычисления сервера](xref:core/querying/client-eval), до версии 3.0. EF Core поддерживал вычисление клиента в любой части запроса. Клиентское вычисление привело к материализации сущностей, которые не были частью результата. Поэтому EF Core проанализировал результат, чтобы определить, что нужно отслеживать. Эта конструкция имела следующие отличия:
  - Вычисление клиента в проекции, которое вызвало материализацию, но не вернуло материализованный экземпляр сущности, не отслеживалось. Следующий пример не отслеживает сущности `blog`.
    [!code-csharp[Main](../../../samples/core/Querying/Tracking/Sample.cs#ClientProjection)]

  - В некоторых случаях EF Core не отслеживал объекты, выходящие из состава LINQ. Следующий пример не отслеживает `Post`.
    [!code-csharp[Main](../../../samples/core/Querying/Tracking/Sample.cs#CustomProjection2)]

- Всякий раз, когда результаты запроса содержали типы сущностей без ключей, весь запрос становится неотслеживаемым. Что значит, что типы сущностей с ключами в результате тоже не отслеживались.
- EF Core было выполнено разрешение идентификатора в запросе без отслеживания. Для отслеживания сущностей, которые уже были возвращены, используются слабые ссылки. Таким образом, если набор результатов содержит одну и ту же сущность несколько раз, вы получите один и тот же экземпляр для каждого события. Хотя, если предыдущий результат с тем же идентификатором вышел за рамки видимости и был собран как мусор, EF Core возвращает новый экземпляр.
