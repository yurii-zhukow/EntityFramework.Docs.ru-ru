---
title: Сравнение запросов с отслеживанием и без отслеживания — EF Core
description: Сведения о запросах с отслеживанием и без отслеживания в Entity Framework Core
author: smitpatel
ms.date: 11/09/2020
uid: core/querying/tracking
ms.openlocfilehash: b4c059f9a9b726697009589271e007bd1d2afd56
ms.sourcegitcommit: f3512e3a98e685a3ba409c1d0157ce85cc390cf4
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2020
ms.locfileid: "94430447"
---
# <a name="tracking-vs-no-tracking-queries"></a>Сравнение запросов с отслеживанием и без отслеживания

Отслеживание поведения контролирует, будет ли Entity Framework Core хранить информацию об экземпляре сущности в средстве отслеживания изменений. Если сущность отслеживается, любые изменения, обнаруженные в сущности, будут сохраняться в базе данных во время операции `SaveChanges()`. EF Core также будет исправлять свойства навигации между сущностями в результатах запроса отслеживания и сущностями, которые находятся в средстве отслеживания изменений.

> [!NOTE]
> [Типы сущностей без ключей](xref:core/modeling/keyless-entity-types) не отслеживаются. Каждый раз, когда в этой статье упоминаются типы сущностей, имеются ввиду типы сущностей, для которых определен ключ.

> [!TIP]  
> Для этой статьи вы можете скачать [пример](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying/Tracking) из репозитория GitHub.

## <a name="tracking-queries"></a>Отслеживания запросов

По умолчанию запросы, возвращающие типы сущностей, отслеживаются. Что означает, что вы можете внести изменения в эти экземпляры сущностей и сохранить эти изменения с помощью операции `SaveChanges()`. В следующем примере изменение рейтинга блогов будет обнаружено и сохранено в базе данных во время операции `SaveChanges()`.

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#Tracking)]

После возврата результатов в запросе отслеживания EF Core проверяет, находится ли сущность в контексте. Если EF Core находит сущность, тогда возвращается этот же экземпляр. EF Core не перезаписывает текущие и исходные значения свойств сущности в записи значениями базы данных. Если сущность еще не существует в контексте, EF Core создает новый экземпляр сущности и присоединяет его к контексту. Результаты запросов не содержат сущности, которые добавлены в контекст, но не сохранены в базе данных.

## <a name="no-tracking-queries"></a>Отключение отслеживания запросов

Никакие запросы отслеживания не полезны, когда результаты используются в сценарии только для чтения. Они быстрее выполняются, потому что нет необходимости настраивать информацию об отслеживании изменений. Если вам не нужно обновлять сущности, извлеченные из базы данных, то следует использовать запрос без отслеживания. Вы можете отключить отслеживание для отдельного запроса. Запрос на отслеживание не выдает результаты на основе содержимого в базе данных, независимо от локальных изменений и добавленных сущностей.

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#NoTracking)]

Вы также можете изменить поведение отслеживания по умолчанию на уровне экземпляра контекста:

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ContextDefaultTrackingBehavior)]

## <a name="identity-resolution"></a>Разрешение идентификатора

Поскольку запрос отслеживания использует отслеживание изменений, EF Core выполнит разрешение удостоверения в запросе отслеживания. При материализации сущности, если она уже отслеживается, EF Core вернет тот же экземпляр сущности из отслеживания изменений. Если результат содержит одну и ту же сущность несколько раз, вы получаете один и тот же экземпляр для каждого события. Запросы без отслеживания не используют отслеживание изменений и не выполняют разрешение удостоверения. Таким образом вы получаете новый экземпляр сущности, даже если одна и та же сущность содержится в результатах несколько раз. Такая реакция на событие была иной в версиях до EF Core 3.0, см. [предыдущие версии](#previous-versions).

Начиная с EF Core 5.0, эти два поведения можно комбинировать в одном запросе. Это означает, что вы можете использовать запрос без отслеживания, выполняющий в результатах разрешение идентификатора. Вместе с запрашивающим оператором `AsNoTracking()` добавлен другой оператор `AsNoTrackingWithIdentityResolution()`. Кроме того, в перечисление <xref:Microsoft.EntityFrameworkCore.QueryTrackingBehavior> добавлена связанная запись. При настройке запроса таким образом, чтобы использовать разрешение идентификатора без отслеживания, во время создания результатов запроса используется автономный механизм отслеживания изменений в фоновом режиме, что позволяет реализовать каждый экземпляр. Поскольку средство отслеживания изменений отличается от средства, которое находится в контексте, результаты не отслеживаются по контексту. После полного перечисления запроса средство отслеживания изменений выходит из области действия и при необходимости выполняется сборка мусора.

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#NoTrackingWithIdentityResolution)]

## <a name="tracking-and-custom-projections"></a>Отслеживание и пользовательские проекции

Даже если тип результата запроса не является типом сущности, EF Core будет отслеживать типы сущностей, содержащиеся в результате по умолчанию. В следующем запросе, который возвращает анонимный тип, будут отслеживаться экземпляры `Blog` в результирующем наборе.

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection1)]

Если в результирующем наборе содержатся типы сущностей, выходящие из состава LINQ, EF Core будет отслеживать их.

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection2)]

Если результирующий набор не содержит типов сущностей, то отслеживание не выполняется. В следующем запросе, мы возвратим анонимный тип с некоторыми значениями из сущности (но не экземплярами фактического типа сущности). Отслеживаемых объектов из запроса не обнаружено.

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection3)]

 EF Core поддерживает вычисление на стороне клиента в проекции верхнего уровня. Если EF Core материализует экземпляр сущности для вычисления клиента, она будет отслеживаться. Здесь, поскольку мы передаем сущности `blog` в метод клиента `StandardizeURL`, EF Core также будет отслеживать экземпляры блогов.

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ClientProjection)]

[!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ClientMethod)]

EF Core не отслеживает экземпляры сущности без ключа, содержащиеся в результате. Но EF Core отслеживает все остальные экземпляры типов сущностей с ключами в соответствии с правилами, приведенными выше.

Некоторые из вышеперечисленных правил работали по-разному до EF Core 3.0. Дополнительные сведения см. в разделе [Предыдущие версии](#previous-versions).

## <a name="previous-versions"></a>предыдущих версий

До версии 3.0 у EF Core были некоторые различия в способах отслеживания. Различия заключаются в следующем.

- Как поясняется на странице [Вычисление клиента против вычисления сервера](xref:core/querying/client-eval), до версии 3.0. EF Core поддерживал вычисление клиента в любой части запроса. Клиентское вычисление привело к материализации сущностей, которые не были частью результата. Поэтому EF Core проанализировал результат, чтобы определить, что нужно отслеживать. Эта конструкция имела следующие отличия:
  - Вычисление клиента в проекции, которое вызвало материализацию, но не вернуло материализованный экземпляр сущности, не отслеживалось. Следующий пример не отслеживает сущности `blog`.
    [!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#ClientProjection)]

  - В некоторых случаях EF Core не отслеживал объекты, выходящие из состава LINQ. Следующий пример не отслеживает `Post`.
    [!code-csharp[Main](../../../samples/core/Querying/Tracking/Program.cs#CustomProjection2)]

- Всякий раз, когда результаты запроса содержали типы сущностей без ключей, весь запрос становится неотслеживаемым. Что значит, что типы сущностей с ключами в результате тоже не отслеживались.
- EF Core было выполнено разрешение идентификатора в запросе без отслеживания. Для отслеживания сущностей, которые уже были возвращены, используются слабые ссылки. Таким образом, если набор результатов содержит одну и ту же сущность несколько раз, вы получите один и тот же экземпляр для каждого события. Хотя, если предыдущий результат с тем же идентификатором вышел за рамки видимости и был собран как мусор, EF Core возвращает новый экземпляр.
