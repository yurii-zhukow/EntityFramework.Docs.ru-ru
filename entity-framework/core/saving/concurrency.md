---
title: Обработка конфликтов параллелизма — EF Core
author: rowanmiller
ms.date: 03/03/2018
uid: core/saving/concurrency
ms.openlocfilehash: a1d1a5a11d482f9104691aa3c072dbd1c548e9f1
ms.sourcegitcommit: cc0ff36e46e9ed3527638f7208000e8521faef2e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78413651"
---
# <a name="handling-concurrency-conflicts"></a>Обработка конфликтов параллелизма

> [!NOTE]
> На этой странице описывается, как работает параллелизм в EF Core и как обрабатывать конфликты параллелизма в вашем приложении. Подробнее о том, как настроить маркеры параллелизма в вашей модели, см. в [этой статье](xref:core/modeling/concurrency).

> [!TIP]
> Для этой статьи вы можете скачать [пример](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Saving/Concurrency/) из репозитория GitHub.

_Параллелизм базы данных_ относится к ситуациям, в которых несколько процессов или пользователей получают доступ или одновременно изменяют одни и те же данные в базе данных. _Управление параллелизмом_ относится к конкретным механизмам, используемым для обеспечения согласованности данных при наличии одновременных изменений.

EF Core реализует _оптимистичный контроль параллелизма_, который позволяет нескольким процессам или пользователям самостоятельно вносить изменения без накладных расходов на синхронизацию или блокировку. В идеальной ситуации эти изменения не будут мешать друг другу и, следовательно, смогут завершиться успешно. В худшем случае два или более процесса будут пытаться вносить конфликтующие изменения, и только один из них сможет преуспеть.

## <a name="how-concurrency-control-works-in-ef-core"></a>Как работает управление параллелизмом в EF Core

Свойства, настроенные как маркеры параллелизма, используются для реализации оптимистического контроля параллелизма: всякий раз, когда операция обновления или удаления выполняется во время `SaveChanges`, значение маркера параллелизма в базе данных сравнивается с исходным значением, считанным EF Core.

- Если значения совпадают, операция может завершиться.
- Если значения не совпадают, EF Core предполагает, что другой пользователь выполнил конфликтную операцию и прервал текущую транзакцию.

Ситуация, когда другой пользователь выполнил операцию, конфликтующую с текущей операцией, называется _конфликтом параллелизма_.

Поставщики баз данных отвечают за реализацию сравнения значений маркеров параллелизма.

В реляционных базах данных EF Core включает проверку значения маркера параллелизма в предложении `WHERE` любых инструкций с `UPDATE` или `DELETE`. После выполнения операторов EF Core считывает количество затронутых строк.

Если никакие строки не затронуты, конфликт параллелизма обнаруживается и EF Core вызывает `DbUpdateConcurrencyException`.

Например, мы можем настроить `LastName` в `Person` как маркер параллелизма. Тогда любая операция обновления для пользователя будет содержать проверку параллелизма в предложении `WHERE`:

``` sql
UPDATE [Person] SET [FirstName] = @p1
WHERE [PersonId] = @p0 AND [LastName] = @p2;
```

## <a name="resolving-concurrency-conflicts"></a>Разрешение конфликтов параллелизма

Продолжая рассматривать предыдущий пример, если один пользователь пытается сохранить некоторые изменения в `Person`, но другой пользователь уже изменил `LastName`, будет вызвано исключение.

На этом этапе приложение может просто проинформировать пользователя о том, что обновление не было успешным из-за противоречивых изменений, и продолжить выполнение. Но может быть желательно запросить пользователя убедиться, что запись по-прежнему представляет одного и того же фактического пользователя, и повторить операцию.

Этот процесс является примером _разрешения конфликта параллелизма_.

Разрешение конфликта параллелизма включает в себя объединение ожидающих изменений из текущего контекста `DbContext` со значениями в базе данных. Объединяемые значения отличаются в зависимости от приложения, и их может указать пользователь, введя входные данные.

**Доступны три набора значений для разрешения конфликта параллелизма:**

- **Текущие значения** — это значения, которые приложение пыталось записать в базу данных.
- **Исходные значения** — это значения, которые изначально были получены из базы данных до того, как были сделаны какие-либо изменения.
- **Значения базы данных** — это значения, которые в настоящее время хранятся в базе данных.

Общий подход к обработке конфликтов параллелизма:

1. Получите `DbUpdateConcurrencyException` в процессе `SaveChanges`.
2. Используйте `DbUpdateConcurrencyException.Entries`, чтобы подготовить новый набор изменений для затронутых объектов.
3. Обновите исходные значения маркера параллелизма, чтобы отразить текущие значения в базе данных.
4. Повторяйте процесс, пока не возникнут конфликты.

В следующем примере `Person.FirstName` и `Person.LastName` устанавливаются как маркеры параллелизма. В месте, где вы указываете конкретную логику приложения, есть комментарий `// TODO:`, позволяющий выбрать значение, которое нужно сохранить.

[!code-csharp[Main](../../../samples/core/Saving/Concurrency/Sample.cs?name=ConcurrencyHandlingCode&highlight=34-35)]
