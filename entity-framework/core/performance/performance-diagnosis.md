---
title: Диагностика производительности — EF Core
description: Диагностика Entity Framework Core производительности и определение узких мест
author: roji
ms.date: 12/1/2020
uid: core/performance/performance-diagnosis
ms.openlocfilehash: 9416acf3326056ef7a5d732c4bd456dac751167b
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657738"
---
# <a name="performance-diagnosis"></a>Диагностика производительности

В этом разделе обсуждаются способы обнаружения проблем с производительностью в приложении EF, а также после определения проблемной области для выявления корневой проблемы. Важно тщательно диагностировать и исследовать любые проблемы, прежде чем переходить к любым переводам, и избежать появления корня проблемы.

## <a name="identifying-slow-database-commands-via-logging"></a>Определение длительных команд базы данных с помощью ведения журнала

В конце дня EF готовит и выполняет команды для выполнения в базе данных. в реляционной базе данных это означает, что инструкции SQL выполняются через API базы данных ADO.NET. Если определенный запрос занимает слишком много времени (например, из-за отсутствия индекса), его можно обнаружить, проверив журналы выполнения команд и проверяя, сколько времени они действительно делают.

EF позволяет очень легко собирать время выполнения команд с помощью [простого ведения журнала](xref:core/logging-events-diagnostics/simple-logging) или [Microsoft. Extensions. Logging](xref:core/logging-events-diagnostics/extensions-logging):

### <a name="simple-logging"></a>[Простое ведение журнала](#tab/simple-logging)

[!code-csharp[Main](../../../samples/core/Performance/BloggingContext.cs#SimpleLogging)]

### <a name="microsoftextensionslogging"></a>[Microsoft.Extensions.Logging](#tab/microsoft-extensions-logging)

[!code-csharp[Main](../../../samples/core/Performance/ExtensionsLoggingContext.cs#ExtensionsLogging)]

***

Если уровень ведения журнала задан как `LogLevel.Information` , EF выдает сообщение журнала для каждого выполнения команды с заданным временем:

```log
info: 06/12/2020 09:12:36.117 RelationalEventId.CommandExecuted[20101] (Microsoft.EntityFrameworkCore.Database.Command)
      Executed DbCommand (4ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [b].[Id], [b].[Name]
      FROM [Blogs] AS [b]
      WHERE [b].[Name] = N'foo'
```

Приведенная выше команда заняла 4 миллисекунды. Если определенная команда занимает больше времени, чем ожидалось, вы обнаружили возможную причину проблемы с производительностью и теперь можете сосредоточиться на ней, чтобы понять, почему она работает медленно. Ведение журнала команд также позволяет обнаружить случаи, в которых происходит непредвиденное время обращения к базе данных. Это будет отображаться в виде нескольких команд, где ожидается только один.

> [!WARNING]
> Включение ведения журнала выполнения команд в рабочей среде, как правило, является неправильной идеей. Собственно ведение журнала замедляет работу приложения и может быстро создавать огромные файлы журналов, которые могут заполнять диск сервера. Рекомендуется вести журнал только в течение короткого интервала времени для сбора данных. Это позволяет тщательно отслеживать работу приложения или записывать данные журнала в подготовительной системе.

## <a name="correlating-database-commands-to-linq-queries"></a>Сопоставление команд базы данных с запросами LINQ

Одна из проблем с ведением журнала выполнения команды заключается в том, что иногда трудно сопоставлять SQL-запросы и запросы LINQ: команды SQL, выполняемые EF, могут выглядеть совершенно иначе, чем запросы LINQ, из которых они были созданы. Чтобы помочь в этой сложности, можно использовать функцию " [теги запросов](xref:core/querying/tags) EF", которая позволяет внедрить небольшой, идентифицирующий комментарий в SQL-запрос:

[!code-csharp[Main](../../../samples/core/Querying/Tags/Program.cs#BasicQueryTag)]

Тег отображается в журналах:

```sql
-- This is my spatial query!

SELECT TOP(@__p_1) [p].[Id], [p].[Location]
FROM [People] AS [p]
ORDER BY [p].[Location].STDistance(@__myLocation_0) DESC
```

Часто стоит добавлять в теги основные запросы приложения таким образом, чтобы журналы выполнения команд стала более удобочитаемыми.

## <a name="other-interfaces-for-capturing-performance-data"></a>Другие интерфейсы для захвата данных о производительности

Существуют различные альтернативы функции ведения журнала EF для захвата времени выполнения команды, что может быть более мощным. Базы данных обычно поставляются с собственными средствами трассировки и анализа производительности, которые обычно предоставляют намного более широкие сведения, относящиеся к базе данных, за исключением простого времени выполнения. Фактическая настройка, возможности и использование значительно меняются в разных базах данных.

Например, [SQL Server Management Studio](/sql/ssms/download-sql-server-management-studio-ssms) является мощным клиентом, который может подключаться к экземпляру SQL Server и предоставлять ценные сведения об управлении и производительности. Этот раздел выходит за рамки этого раздела, но есть две возможности: [Монитор активности](/sql/relational-databases/performance-monitor/open-activity-monitor-sql-server-management-studio), который обеспечивает динамическую панель мониторинга активности сервера (включая наиболее ресурсоемкие запросы) и функцию [расширенных событий (XEvent)](/sql/relational-databases/extended-events/quick-start-extended-events-in-sql-server) , которая позволяет определять произвольные сеансы отслеживания данных, которые можно адаптировать к конкретным потребностям. [В SQL Server документации по мониторингу](/sql/relational-databases/performance/monitor-and-tune-for-performance) содержатся дополнительные сведения об этих функциях, а также о других.

Другим подходом к сбору данных о производительности является сбор информации, автоматически создаваемой EF или драйвером базы данных через `DiagnosticSource` интерфейс, с последующим анализом данных или отображением их на панели мониторинга. Если вы используете Azure, [azure Application Insights](https://docs.microsoft.com/azure/azure-monitor/learn/tutorial-performance) предоставляет такие мощные средства мониторинга, что позволяет интегрировать производительность базы данных и время выполнения запросов при анализе того, как быстро обслуживаются веб-запросы. Дополнительные сведения об этом доступны в [учебнике по производительности Application Insights](/azure/azure-monitor/learn/tutorial-performance)и на странице " [аналитика SQL Azure](/azure/azure-monitor/insights/azure-sql)".

## <a name="inspecting-query-execution-plans"></a>Проверка планов выполнения запросов

После определения проблемного запроса, требующего оптимизации, следующий шаг обычно анализирует *план выполнения* запроса. Когда базы данных получают инструкцию SQL, они обычно создают план выполнения этого плана. Это иногда требует сложного принятия решений в зависимости от того, какие индексы были определены, сколько данных существует в таблицах и т. д. (при этом сам план обычно должен кэшироваться на сервере для обеспечения оптимальной производительности). Реляционные базы данных обычно предоставляют пользователям способ просмотра плана запроса, а также вычисление затрат для различных частей запроса. Это не имеет ценности для улучшения запросов.

Чтобы приступить к работе с SQL Server, см. документацию по [планам выполнения запросов](/sql/relational-databases/performance/execution-plans). Типичный рабочий процесс анализа предполагает использование [SQL Server Management Studio](/sql/relational-databases/performance/display-an-actual-execution-plan), вставки SQL-запроса, определенного через одно из приведенных выше средств, и [создания графического плана выполнения](/sql/relational-databases/performance/display-an-actual-execution-plan):

![Отображение SQL Server плана выполнения](_static/actualexecplan.png)

Хотя планы выполнения могут показаться сложными, на первый взгляд стоит потратить немного времени на знакомство с ними. Особенно важно отметить затраты, связанные с каждым узлом плана, а также выяснить, как индексы используются (или не) на различных узлах.

Хотя приведенные выше сведения относятся к SQL Server, другие базы данных обычно предоставляют те же средства с аналогичной визуализацией.

> [!IMPORTANT]
> Иногда базы данных создают разные планы запросов в зависимости от фактических данных в базе данных. Например, если таблица содержит всего несколько строк, то база данных может не использовать индекс для этой таблицы, а выполнять полное сканирование таблицы. При анализе планов запросов в тестовой базе данных всегда убедитесь, что она содержит данные, аналогичные вашей рабочей системе.

## <a name="event-counters"></a>Счетчики событий

Приведенные выше разделы посвящены получению сведений о командах и способах выполнения этих команд в базе данных. Помимо этого, EF предоставляет набор *счетчиков событий* , которые предоставляют более низкую информацию о том, что происходит внутри самой EF и как приложение использует его. Эти счетчики могут оказаться очень полезными для диагностики конкретных проблем производительности и аномалий производительности, таких как [проблемы кэширования запросов](xref:core/performance/advanced-performance-topics#dynamically-constructed-queries) , которые вызывают повторную компиляцию, неосвобожденные DbContext утечки и др.

Дополнительные сведения см. в разделе [счетчики событий EF](xref:core/logging-events-diagnostics/event-counters) на выделенной странице.

## <a name="benchmarking-with-ef-core"></a>Тестирование производительности с помощью EF Core

В конце дня иногда необходимо знать, является ли определенный способ написания или выполнения запроса более быстрым, чем другой. Важно никогда не предположить и не представить ответ, и очень просто создать быстрый тест производительности, чтобы получить ответ. При написании тестов производительности настоятельно рекомендуется использовать хорошо известную библиотеку [бенчмаркдотнет](https://benchmarkdotnet.org/index.html) , которая обрабатывает множество пользователей, которые сталкиваются с проблемами при написании собственных тестов производительности: вы выполнили несколько итераций для прогрева? Сколько итераций на самом деле выполняет ваш тест производительности и почему? Давайте рассмотрим, как выглядит тест производительности с EF Core.

> [!TIP]
> Полный проект теста производительности для источника ниже доступен [здесь](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/AverageBlogRanking.cs). Рекомендуется скопировать его и использовать в качестве шаблона для собственных тестов производительности.

В качестве простого сценария тестирования можно сравнить следующие методы расчета среднего рейтинга всех блогов в нашей базе данных:

* Загрузите все сущности, суммируйте их отдельные ранжирования и Вычислите среднее значение.
* То же, что и выше, используется только неотслеживаемый запрос. Это должно быть быстрее, так как разрешение идентификации не выполняется, и сущности не снапшоттед в целях отслеживания изменений.
* Старайтесь не загружать все экземпляры сущности блога, выполняя проецирование только ранжирования. Благодаря этому нам не нужно переносить другие ненужные столбцы типа сущности блога.
* Вычислите среднее значение в базе данных, сделав его частью запроса. Это должен быть самый быстрый способ, так как все вычисляется в базе данных, и только результат передается обратно клиенту.

С помощью Бенчмаркдотнет вы пишете код для оценки производительности как простой метод, как и модульный тест, и Бенчмаркдотнет автоматически запускает каждый метод для достаточного количества итераций, надежно измеряя время и объем выделяемой памяти. Ниже приведен другой метод ([полный код теста производительности можно увидеть здесь](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/AverageBlogRanking.cs)):

### <a name="load-entities"></a>[Загрузка сущностей](#tab/load-entities)

[!code-csharp[Main](../../../samples/core/Benchmarks/AverageBlogRanking.cs?name=LoadEntities)]

### <a name="load-entities-no-tracking"></a>[Загрузка сущностей, без отслеживания](#tab/load-entities-no-tracking)

[!code-csharp[Main](../../../samples/core/Benchmarks/AverageBlogRanking.cs?name=LoadEntitiesNoTracking)]

### <a name="project-only-ranking"></a>[Ранжирование только по проекту](#tab/project-only-ranking)

[!code-csharp[Main](../../../samples/core/Benchmarks/AverageBlogRanking.cs?name=ProjectOnlyRanking)]

### <a name="calculate-in-database"></a>[Вычислить в базе данных](#tab/calculate-in-database)

[!code-csharp[Main](../../../samples/core/Benchmarks/AverageBlogRanking.cs?name=CalculateInDatabase)]

***

Ниже приведены результаты, выводимые Бенчмаркдотнет:

|                 Метод |       Среднее значение |    Ошибка |   StdDev |     Median | Соотношение | ратиосд |    Gen 0 |   Gen 1 | Gen 2 |  Allocated |
|----------------------- |-----------:|---------:|---------:|-----------:|------:|--------:|---------:|--------:|------:|-----------:|
|           лоадентитиес | 2 860,4 США | 54,31 США | 93,68 США | 2 844,5 США |  4.55 |    0,33 | 210,9375 | 70,3125 |     - | 1309,56 КБ |
| лоадентитиеснотраккинг | 1 353,0 США | 21,26 США | 18,85 США | 1 355,6 США |  2.10 |    0,14 |  87,8906 |  3,9063 |     - |  540,09 КБ |
|     прожектонлиранкинг |   910,9 США | 20,91 США | 61,65 США |   892,9 США |  1,46 |    0,14 |  41,0156 |  0,9766 |     - |  252,08 КБ |
|    калкулатеиндатабасе |   627,1 США | 14,58 США | 42,54 США |   626,4 США |  1.00 |    0,00 |   4,8828 |       - |     - |   33,27 КБ |

> [!NOTE]
> По мере того как методы создают и удаляют контекст в методе, эти операции учитываются для теста производительности, хотя и строго говоря, они не являются частью процесса запроса. Это не имеет значения, если цель состоит в сравнении двух альтернативных вариантов друг с другом (так как создание и реализация контекста одинаковы) и обеспечивает более целостное измерение для всей операции.

Одно из ограничений Бенчмаркдотнет заключается в том, что оно измеряет простую, однопотоковую производительность предоставляемых методов и поэтому не подходит для параллельных сценариев.

> [!IMPORTANT]
> Всегда убедитесь, что в базе данных есть данные, аналогичные рабочим данным, при выполнении теста производительности; в противном случае результаты теста производительности могут не представлять фактическую производительность в рабочей среде.
