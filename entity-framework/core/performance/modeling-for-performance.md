---
title: Моделирование EF Core производительности
description: Эффективное моделирование при использовании Entity Framework Core
author: roji
ms.date: 12/1/2020
uid: core/performance/modeling-for-performance
ms.openlocfilehash: 882398189cc828798c1682f849fac524d90d317f
ms.sourcegitcommit: 4798ab8d04c1fdbe6dd204d94d770fcbf309d09b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/11/2021
ms.locfileid: "103023865"
---
# <a name="modeling-for-performance"></a><span data-ttu-id="8877d-103">Моделирование производительности</span><span class="sxs-lookup"><span data-stu-id="8877d-103">Modeling for Performance</span></span>

<span data-ttu-id="8877d-104">Во многих случаях способ моделирования может иметь более глубокое воздействие на производительность приложения. Хотя правильно нормализованная и «правильная» модель обычно является хорошей отправной точкой, в реальных приложениях некоторые из практических компромиссов могут быть длительным образом для достижения хорошей производительности.</span><span class="sxs-lookup"><span data-stu-id="8877d-104">In many cases, the way you model can have a profound impact on the performance of your application; while a properly normalized and "correct" model is usually a good starting point, in real-world applications some pragmatic compromises can go a long way for achieving good performance.</span></span> <span data-ttu-id="8877d-105">Поскольку модель очень сложно изменить после того, как приложение выполняется в рабочей среде, при создании начальной модели следует помнить о снижении производительности.</span><span class="sxs-lookup"><span data-stu-id="8877d-105">Since it's quite difficult to change your model once an application is running in production, it's worth keeping performance in mind when creating the initial model.</span></span>

## <a name="denormalization-and-caching"></a><span data-ttu-id="8877d-106">Денормализация и кэширование</span><span class="sxs-lookup"><span data-stu-id="8877d-106">Denormalization and caching</span></span>

<span data-ttu-id="8877d-107">*Денормализация* — это практика добавления избыточных данных в схему, обычно для исключения соединений при выполнении запросов.</span><span class="sxs-lookup"><span data-stu-id="8877d-107">*Denormalization* is the practice of adding redundant data to your schema, usually in order to eliminate joins when querying.</span></span> <span data-ttu-id="8877d-108">Например, для модели с блогами и записями, где каждая запись имеет рейтинг, может потребоваться частое отображение средней оценки блога.</span><span class="sxs-lookup"><span data-stu-id="8877d-108">For example, for a model with Blogs and Posts, where each Post has a Rating, you may be required to frequently show the average rating of the Blog.</span></span> <span data-ttu-id="8877d-109">Простой подход к этому — Группировка записей по блогу и вычисление среднего значения в составе запроса. но для этого требуется дорогостоящая связь между двумя таблицами.</span><span class="sxs-lookup"><span data-stu-id="8877d-109">The simple approach to this would group the Posts by their Blog, and calculate the average as part of the query; but this requires a costly join between the two tables.</span></span> <span data-ttu-id="8877d-110">Денормализация приведет к добавлению вычисленного среднего значения всех записей в новый столбец блога, чтобы он был немедленно доступен без присоединения или вычисления.</span><span class="sxs-lookup"><span data-stu-id="8877d-110">Denormalization would add the calculated average of all posts to a new column on Blog, so that it is immediately accessible, without joining or calculating.</span></span>

<span data-ttu-id="8877d-111">Приведенные выше сведения можно просмотреть в виде формы *кэширования* . статистические данные из записей кэшируются в своем блоге. и, как и при любом кэшировании, проблема заключается в том, как хранить кэшированное значение в актуальном состоянии с помощью кэшированных данных.</span><span class="sxs-lookup"><span data-stu-id="8877d-111">The above can be viewed as a form of *caching* - aggregate information from the Posts is cached on their Blog; and like with any caching, the problem is how to keep the cached value up to date with the data it's caching.</span></span> <span data-ttu-id="8877d-112">Во многих случаях кэшированные данные могут задерживается в течение определенного бита. Например, в приведенном выше примере обычно целесообразно, чтобы средняя оценка блога не была полностью актуальной в любой момент времени.</span><span class="sxs-lookup"><span data-stu-id="8877d-112">In many cases, it's OK for the cached data to lag for a bit; for example, in the example above, it's usually reasonable for the blog's average rating to not be completely up to date at any given point.</span></span> <span data-ttu-id="8877d-113">Если это так, можно выполнить повторное вычисление каждого из них, а затем; в противном случае необходимо настроить более сложную систему, чтобы поддерживать кэшированные значения в актуальном состоянии.</span><span class="sxs-lookup"><span data-stu-id="8877d-113">If that's the case, you can have it recalculated every now and then; otherwise, a more elaborate system must be set up to keep the cached values up to date.</span></span>

<span data-ttu-id="8877d-114">Ниже приведены некоторые методы денормализации и кэширования в EF Core и указываются соответствующие разделы в документации.</span><span class="sxs-lookup"><span data-stu-id="8877d-114">The following details some techniques for denormalization and caching in EF Core, and points to the relevant sections in the documentation.</span></span>

### <a name="stored-computed-columns"></a><span data-ttu-id="8877d-115">Сохраненные столбцы с вычислением</span><span class="sxs-lookup"><span data-stu-id="8877d-115">Stored computed columns</span></span>

<span data-ttu-id="8877d-116">Если данные для кэширования являются продуктом других столбцов в той же таблице, то [хранимый вычисляемый столбец](xref:core/modeling/generated-properties#computed-columns) может быть идеальным решением.</span><span class="sxs-lookup"><span data-stu-id="8877d-116">If the data to be cached is a product of other columns in the same table, then a [stored computed column](xref:core/modeling/generated-properties#computed-columns) can be a perfect solution.</span></span> <span data-ttu-id="8877d-117">Например, `Customer` может иметь `FirstName` `LastName` столбцы и, но может потребоваться выполнить поиск по *полному имени* клиента.</span><span class="sxs-lookup"><span data-stu-id="8877d-117">For example, a `Customer` may have `FirstName` and `LastName` columns, but we may need to search by the customer's *full name*.</span></span> <span data-ttu-id="8877d-118">Хранимый вычисляемый столбец автоматически обслуживается базой данных, который повторно вычисляет его при каждом изменении строки. можно даже определить индекс для ускорения запросов.</span><span class="sxs-lookup"><span data-stu-id="8877d-118">A stored computed column is automatically maintained by the database - which recalculates it whenever the row is changed - and you can even define an index over it to speed up queries.</span></span>

### <a name="update-cache-columns-when-inputs-change"></a><span data-ttu-id="8877d-119">Обновлять столбцы кэша при изменении входных данных</span><span class="sxs-lookup"><span data-stu-id="8877d-119">Update cache columns when inputs change</span></span>

<span data-ttu-id="8877d-120">Если кэшированный столбец должен ссылаться на входные данные извне строки таблицы, нельзя использовать вычисляемые столбцы.</span><span class="sxs-lookup"><span data-stu-id="8877d-120">If your cached column needs to reference inputs from outside the table's row, you cannot use computed columns.</span></span> <span data-ttu-id="8877d-121">Однако по-прежнему возможно повторное вычисление столбца при изменении его входных данных. Например, можно повторно рассчитать среднюю оценку блога каждый раз при изменении, добавлении или удалении записи.</span><span class="sxs-lookup"><span data-stu-id="8877d-121">However, it is still possible to recalculate the column whenever its input changes; for example, you could recalculate the average Blog's rating every time a Post is changed, added or removed.</span></span> <span data-ttu-id="8877d-122">Не забудьте определить точные условия, когда требуется повторное вычисление, в противном случае кэшированное значение будет выходить из синхронизации.</span><span class="sxs-lookup"><span data-stu-id="8877d-122">Be sure to identify the exact conditions when recalculation is needed, otherwise your cached value will go out of sync.</span></span>

<span data-ttu-id="8877d-123">Один из способов сделать это — выполнить обновление самостоятельно с помощью регулярного EF Core API.</span><span class="sxs-lookup"><span data-stu-id="8877d-123">One way to do this, is to perform the update yourself, via the regular EF Core API.</span></span> <span data-ttu-id="8877d-124">`SaveChanges`[События](xref:core/logging-events-diagnostics/events) или [перехватчики](xref:core/logging-events-diagnostics/interceptors#savechanges-interception) можно использовать для автоматической проверки наличия обновлений записей, а также для выполнения повторного вычисления.</span><span class="sxs-lookup"><span data-stu-id="8877d-124">`SaveChanges` [Events](xref:core/logging-events-diagnostics/events) or [interceptors](xref:core/logging-events-diagnostics/interceptors#savechanges-interception) can be used to automatically check if any Posts are being updated, and to perform the recalculation that way.</span></span> <span data-ttu-id="8877d-125">Обратите внимание, что это обычно влечет за собой дополнительные обращения к базе данных, так как необходимо отправить дополнительные команды.</span><span class="sxs-lookup"><span data-stu-id="8877d-125">Note that this typically entails additional database roundtrips, as additional commands must be sent.</span></span>

<span data-ttu-id="8877d-126">Для дополнительных приложений с учетом производительности можно определить триггеры базы данных, чтобы автоматически выполнять повторное вычисление в базе данных.</span><span class="sxs-lookup"><span data-stu-id="8877d-126">For more perf-sensitive applications, database triggers can be defined to automatically perform the recalculation in the database.</span></span> <span data-ttu-id="8877d-127">Это экономит лишнюю базу данных, автоматически происходит в той же транзакции, что и основное обновление, и может быть проще в настройке.</span><span class="sxs-lookup"><span data-stu-id="8877d-127">This saves the extra database roundtrips, automatically occurs within the same transaction as the main update, and can be simpler to set up.</span></span> <span data-ttu-id="8877d-128">EF не предоставляет какой-либо конкретный API для создания или обслуживания триггеров, но вполне удобно [создать пустую миграцию и добавить определение триггера с помощью необработанного SQL](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span><span class="sxs-lookup"><span data-stu-id="8877d-128">EF doesn't provide any specific API for creating or maintaining triggers, but it's perfectly fine to [create an empty migration and add the trigger definition via raw SQL](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span></span>

### <a name="materialized-views"></a><span data-ttu-id="8877d-129">материализованные представления;</span><span class="sxs-lookup"><span data-stu-id="8877d-129">Materialized views</span></span>

<span data-ttu-id="8877d-130">Материализованные представления похожи на обычные представления, за исключением того, что их данные хранятся на диске ("материализованный"), а не рассчитываются каждый раз при запросе представления.</span><span class="sxs-lookup"><span data-stu-id="8877d-130">Materialized views are similar to regular views, except that their data is stored on disk ("materialized"), rather than calculated every time when the view is queried.</span></span> <span data-ttu-id="8877d-131">Это средство полезно, если вы не хотите просто добавить один столбец кэша в существующую базу данных, а хотите кэшировать весь набор результатов сложных и дорогостоящих результатов запроса так же, как если бы он был обычной таблицей. Эти результаты можно запрашивать очень дешево без каких бы то ни было вычислений или соединений.</span><span class="sxs-lookup"><span data-stu-id="8877d-131">This tool is useful when you don't want to simply add a single cache column to an existing database, but rather want to cache the entire resultset of a complicated and expensive query's results, just as if it were a regular table; these results can then be queried very cheaply without any computation or joins happening.</span></span> <span data-ttu-id="8877d-132">В отличие от вычисленных столбцов материализованные представления не обновляются автоматически при изменении их базовых таблиц — они должны быть обновлены вручную.</span><span class="sxs-lookup"><span data-stu-id="8877d-132">Unlike computed columns, materialized views aren't automatically updated when their underlying tables change - they must be manually refreshed.</span></span> <span data-ttu-id="8877d-133">Если кэшированные данные могут отставать, обновление представления может выполняться через таймер. другой вариант — настроить триггеры базы данных для просмотра материализованных представлений после возникновения определенных событий базы данных.</span><span class="sxs-lookup"><span data-stu-id="8877d-133">If the cached data can lag, refreshing the view can be done via a timer; another option is to set up database triggers to review a materialized view once certain database events occur.</span></span>

<span data-ttu-id="8877d-134">EF в настоящее время не предоставляет какой-либо конкретный API для создания или обслуживания представлений, материализованных или иным образом; но вполне неплохо [создать пустую миграцию и добавить определение представления с помощью необработанного SQL](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span><span class="sxs-lookup"><span data-stu-id="8877d-134">EF doesn't currently provide any specific API for creating or maintaining views, materialized or otherwise; but it's perfectly fine to [create an empty migration and add the view definition via raw SQL](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span></span>

## <a name="inheritance-mapping"></a><span data-ttu-id="8877d-135">Сопоставление наследования</span><span class="sxs-lookup"><span data-stu-id="8877d-135">Inheritance mapping</span></span>

<span data-ttu-id="8877d-136">Перед продолжением работы с этим разделом рекомендуется прочитать [выделенную страницу по наследованию](xref:core/modeling/inheritance) .</span><span class="sxs-lookup"><span data-stu-id="8877d-136">It's recommended to read [the dedicated page on inheritance](xref:core/modeling/inheritance) before continuing with this section.</span></span>

<span data-ttu-id="8877d-137">В настоящее время EF Core поддерживает два метода сопоставления модели наследования с реляционной базой данных:</span><span class="sxs-lookup"><span data-stu-id="8877d-137">EF Core currently supports two techniques for mapping an inheritance model to a relational database:</span></span>

* <span data-ttu-id="8877d-138">Одна **таблица на иерархию** , в которой вся иерархия .NET классов сопоставлена с одной таблицей базы данных</span><span class="sxs-lookup"><span data-stu-id="8877d-138">**Table-per-hierarchy** (TPH), in which an entire .NET hierarchy of classes is mapped to a single database table</span></span>
* <span data-ttu-id="8877d-139">**Тип «Таблица для каждого типа** » (TPT), в котором каждый тип в иерархии .NET сопоставляется с другой таблицей в базе данных.</span><span class="sxs-lookup"><span data-stu-id="8877d-139">**Table-per-type** (TPT), in which each type in the .NET hierarchy is mapped to a different table in the database.</span></span>

<span data-ttu-id="8877d-140">Выбранный способ сопоставления наследования может оказать значительное влияние на производительность приложения. рекомендуется тщательно оценить перед фиксацией в выборе.</span><span class="sxs-lookup"><span data-stu-id="8877d-140">The choice of inheritance mapping technique can have a considerable impact on application performance - it's recommended to carefully measure before committing to a choice.</span></span>

<span data-ttu-id="8877d-141">Иногда люди выбирают TPT, поскольку по-видимому, является методом очистки; отдельная таблица для каждого типа .NET делает схему базы данных похожей на иерархию типов .NET.</span><span class="sxs-lookup"><span data-stu-id="8877d-141">People sometimes choose TPT because it appears to be the "cleaner" technique; a separate table for each .NET type makes the database schema look similar to the .NET type hierarchy.</span></span> <span data-ttu-id="8877d-142">Кроме того, поскольку иерархия должна представлять всю иерархию в одной таблице, строки имеют *все* столбцы независимо от типа, который фактически удерживается в строке, а несвязанные столбцы всегда пусты и не используются.</span><span class="sxs-lookup"><span data-stu-id="8877d-142">In addition, since TPH must represent the entire hierarchy in a single table, rows have *all* columns regardless of the type actually being held in the row, and unrelated columns are always empty and unused.</span></span> <span data-ttu-id="8877d-143">Помимо этого, многие считают, что эти пустые столбцы занимают значительное пространство в базе данных и могут также понизить производительность.</span><span class="sxs-lookup"><span data-stu-id="8877d-143">Aside from seeming to be an "unclean" mapping technique, many believe that these empty columns take up considerable space in the database and may hurt performance as well.</span></span>

<span data-ttu-id="8877d-144">Тем не менее, измерение показывает, что TPT в большинстве случаев является методом подстановки с точки зрения производительности; Если все данные в подразделениях берутся из одной таблицы, TPT запросы должны соединяться вместе с несколькими таблицами, а объединения являются одним из основных источников проблем производительности в реляционных базах данных.</span><span class="sxs-lookup"><span data-stu-id="8877d-144">However, measuring shows that TPT is in most cases the inferior mapping technique from a performance standpoint; where all data in TPH comes from a single table, TPT queries must join together multiple tables, and joins are one of the primary sources of performance issues in relational databases.</span></span> <span data-ttu-id="8877d-145">Базы данных, как правило, хорошо работают с пустыми столбцами, а такие функции, как [SQL Server разреженные столбцы](/sql/relational-databases/tables/use-sparse-columns) , могут еще больше снизить эту нагрузку.</span><span class="sxs-lookup"><span data-stu-id="8877d-145">Databases also generally tend to deal well with empty columns, and features such as [SQL Server sparse columns](/sql/relational-databases/tables/use-sparse-columns) can reduce this overhead even further.</span></span>

<span data-ttu-id="8877d-146">Конкретный пример см. в [разделе этот тест производительности](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Benchmarks/Inheritance.cs) , который настраивает простую модель с иерархией типа 7. 5000 строки заполнены для каждого типа суммируя 35000 строк. тест производительности просто загружает все строки из базы данных:</span><span class="sxs-lookup"><span data-stu-id="8877d-146">For a concrete example, [see this benchmark](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Benchmarks/Inheritance.cs) which sets up a simple model with a 7-type hierarchy; 5000 rows are seeded for each type - totalling 35000 rows - and the benchmark simply loads all rows from the database:</span></span>

| <span data-ttu-id="8877d-147">Метод</span><span class="sxs-lookup"><span data-stu-id="8877d-147">Method</span></span> |     <span data-ttu-id="8877d-148">Среднее значение</span><span class="sxs-lookup"><span data-stu-id="8877d-148">Mean</span></span> |   <span data-ttu-id="8877d-149">Ошибка</span><span class="sxs-lookup"><span data-stu-id="8877d-149">Error</span></span> |  <span data-ttu-id="8877d-150">StdDev</span><span class="sxs-lookup"><span data-stu-id="8877d-150">StdDev</span></span> |     <span data-ttu-id="8877d-151">Gen 0</span><span class="sxs-lookup"><span data-stu-id="8877d-151">Gen 0</span></span> |     <span data-ttu-id="8877d-152">Gen 1</span><span class="sxs-lookup"><span data-stu-id="8877d-152">Gen 1</span></span> |     <span data-ttu-id="8877d-153">Gen 2</span><span class="sxs-lookup"><span data-stu-id="8877d-153">Gen 2</span></span> | <span data-ttu-id="8877d-154">Allocated</span><span class="sxs-lookup"><span data-stu-id="8877d-154">Allocated</span></span> |
|------- |---------:|--------:|--------:|----------:|----------:|----------:|----------:|
|    <span data-ttu-id="8877d-155">ПРИНЦИП</span><span class="sxs-lookup"><span data-stu-id="8877d-155">TPH</span></span> | <span data-ttu-id="8877d-156">132,3 мс</span><span class="sxs-lookup"><span data-stu-id="8877d-156">132.3 ms</span></span> | <span data-ttu-id="8877d-157">2,29 МС</span><span class="sxs-lookup"><span data-stu-id="8877d-157">2.29 ms</span></span> | <span data-ttu-id="8877d-158">2,03 мс</span><span class="sxs-lookup"><span data-stu-id="8877d-158">2.03 ms</span></span> | <span data-ttu-id="8877d-159">8000,0000</span><span class="sxs-lookup"><span data-stu-id="8877d-159">8000.0000</span></span> | <span data-ttu-id="8877d-160">3000,0000</span><span class="sxs-lookup"><span data-stu-id="8877d-160">3000.0000</span></span> | <span data-ttu-id="8877d-161">1250,0000</span><span class="sxs-lookup"><span data-stu-id="8877d-161">1250.0000</span></span> |  <span data-ttu-id="8877d-162">44,49 МБ</span><span class="sxs-lookup"><span data-stu-id="8877d-162">44.49 MB</span></span> |
|    <span data-ttu-id="8877d-163">TPT</span><span class="sxs-lookup"><span data-stu-id="8877d-163">TPT</span></span> | <span data-ttu-id="8877d-164">201,3 мс</span><span class="sxs-lookup"><span data-stu-id="8877d-164">201.3 ms</span></span> | <span data-ttu-id="8877d-165">3,32 МС</span><span class="sxs-lookup"><span data-stu-id="8877d-165">3.32 ms</span></span> | <span data-ttu-id="8877d-166">3,10 мс</span><span class="sxs-lookup"><span data-stu-id="8877d-166">3.10 ms</span></span> | <span data-ttu-id="8877d-167">9000,0000</span><span class="sxs-lookup"><span data-stu-id="8877d-167">9000.0000</span></span> | <span data-ttu-id="8877d-168">4000,0000</span><span class="sxs-lookup"><span data-stu-id="8877d-168">4000.0000</span></span> |         - |  <span data-ttu-id="8877d-169">61,84 МБ</span><span class="sxs-lookup"><span data-stu-id="8877d-169">61.84 MB</span></span> |

<span data-ttu-id="8877d-170">Как можно заметить, в этом сценарии для этой ситуации гораздо эффективнее использовать подиерархию, чем TPT.</span><span class="sxs-lookup"><span data-stu-id="8877d-170">As can be seen, TPH is considerably more efficient than TPT for this scenario.</span></span> <span data-ttu-id="8877d-171">Обратите внимание, что фактические результаты всегда зависят от выполняемого запроса и количества таблиц в иерархии, поэтому другие запросы могут показывать другой зазор производительности. рекомендуется использовать этот код теста производительности в качестве шаблона для тестирования других запросов.</span><span class="sxs-lookup"><span data-stu-id="8877d-171">Note that actual results always depend on the specific query being executed and the number of tables in the hierarchy, so other queries may show a different performance gap; you're encouraged to use this benchmark code as a template for testing other queries.</span></span>
