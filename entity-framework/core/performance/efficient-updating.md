---
title: Эффективное обновление — EF Core
description: Обзор производительности для эффективного обновления с помощью Entity Framework Core
author: roji
ms.date: 12/1/2020
uid: core/performance/efficient-updating
ms.openlocfilehash: f8e222991af52cd7cae6089e95ad6634b6b949f8
ms.sourcegitcommit: 704240349e18b6404e5a809f5b7c9d365b152e2e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/16/2021
ms.locfileid: "100543137"
---
# <a name="efficient-updating"></a>Эффективное обновление

## <a name="batching"></a>Пакетная обработка

EF Core помогает снизить объем обращений, автоматически объединяя все обновления в единый цикл. Рассмотрим следующий пример.

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#SaveChangesBatching)]

Приведенный выше элемент загружает блог из базы данных, изменяет его URL-адрес, а затем добавляет два новых блога. чтобы применить эту возможность, в базу данных отправляются две инструкции SQL INSERT и одна инструкция UPDATE. Вместо того чтобы отправлять их по одному, при добавлении экземпляров блога EF Core отслеживает эти изменения внутренне и выполняет их в одном цикле обработки при <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> вызове.

Количество инструкций, которые EF обрабатывает пакеты в одном цикле, зависит от используемого поставщика базы данных. Например, анализ производительности показывает пакетную обработку, как правило, менее эффективно для SQL Server, если задействовано менее 4 инструкций. Аналогичным образом, преимущества пакетной обработки снижаются до 40 инструкций для SQL Server, поэтому EF Core будет по умолчанию выполнять до 42 инструкций в одном пакете и выполнять дополнительные инструкции в отдельных обращениях.

Пользователи также могут настроить эти пороговые значения для достижения потенциально большей производительности, но перед изменением нужно тщательно протестировать:

[!code-csharp[Main](../../../samples/core/Performance/BatchTweakingContext.cs#BatchTweaking)]

## <a name="bulk-updates"></a>Групповые обновления

Предположим, что вы хотите дать всем своим сотрудникам возможность подняться. Типичная реализация этого метода в EF Core будет выглядеть следующим образом:

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#UpdateWithoutBulk)]

Хотя это вполне допустимый код, давайте проанализируем, что он делает с точки зрения производительности:

* Выполняется цикл обработки базы данных для загрузки всех соответствующих сотрудников. Обратите внимание, что при этом все данные строки сотрудников переносятся на клиент, даже если потребуется только заработная плата.
* Отслеживание изменений EF Core создает моментальные снимки при загрузке сущностей, а затем сравнивает эти моментальные снимки с экземплярами, чтобы определить, какие свойства изменились.
* Для сохранения всех изменений выполняется второй обмен данными с базой данных. Хотя все изменения выполняются в едином цикле благодаря пакетной обработке, EF Core по-прежнему отправляет инструкцию UPDATE для каждого сотрудника, который должен быть выполнен базой данных.

Реляционные базы данных также поддерживают *групповые обновления*, поэтому приведенные выше инструкции могут быть перезаписаны как следующая отдельная инструкция SQL:

```sql
UPDATE [Employees] SET [Salary] = [Salary] + 1000;
```

Эта операция выполняет всю операцию в едином цикле, не загружая или не отправляя фактические данные в базу данных, и не использует механизм отслеживания изменений EF, который накладывает дополнительные издержки.

Увы, EF в настоящее время не предоставляет интерфейсы API для выполнения операций обновления. Пока они не будут введены, можно использовать необработанный SQL для выполнения операции, в которой важна производительность.

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#UpdateWithBulk)]
