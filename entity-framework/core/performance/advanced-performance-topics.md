---
title: Дополнительные разделы о производительности
description: Дополнительные разделы о производительности для Entity Framework Core
author: rick-anderson
ms.author: riande
ms.date: 12/9/2020
uid: core/performance/advanced-performance-topics
ms.openlocfilehash: 3c0340e1b36cbbb96d23db0633cb2eebc04dd970
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657764"
---
# <a name="advanced-performance-topics"></a><span data-ttu-id="1f039-103">Дополнительные разделы о производительности</span><span class="sxs-lookup"><span data-stu-id="1f039-103">Advanced Performance Topics</span></span>

## <a name="dbcontext-pooling"></a><span data-ttu-id="1f039-104">Создание пулов DbContext</span><span class="sxs-lookup"><span data-stu-id="1f039-104">DbContext pooling</span></span>

<span data-ttu-id="1f039-105">`AddDbContextPool` включает создание пулов `DbContext` экземпляров.</span><span class="sxs-lookup"><span data-stu-id="1f039-105">`AddDbContextPool` enables pooling of `DbContext` instances.</span></span> <span data-ttu-id="1f039-106">Пул контекста может увеличить пропускную способность в крупномасштабных сценариях, таких как веб-серверы, путем повторного использования экземпляров контекста вместо создания новых экземпляров для каждого запроса.</span><span class="sxs-lookup"><span data-stu-id="1f039-106">Context pooling can increase throughput in high-scale scenarios such as web servers by reusing context instances, rather than creating new instances for each request.</span></span>

<span data-ttu-id="1f039-107">Типичный шаблон в ASP.NET Core приложении, использующем EF Core, включает регистрацию пользовательского <xref:Microsoft.EntityFrameworkCore.DbContext> типа в контейнер [внедрения зависимостей](/aspnet/core/fundamentals/dependency-injection) и получение экземпляров этого типа через параметры конструктора в контроллерах или Razor Pages.</span><span class="sxs-lookup"><span data-stu-id="1f039-107">The typical pattern in an ASP.NET Core app using EF Core involves registering a custom <xref:Microsoft.EntityFrameworkCore.DbContext> type into the [dependency injection](/aspnet/core/fundamentals/dependency-injection) container and obtaining instances of that type through constructor parameters in controllers or Razor Pages.</span></span> <span data-ttu-id="1f039-108">При использовании внедрения конструктора для каждого запроса создается новый экземпляр контекста.</span><span class="sxs-lookup"><span data-stu-id="1f039-108">Using constructor injection, a new context instance is created for each request.</span></span>

<span data-ttu-id="1f039-109"><xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> включает пул экземпляров контекста для повторного использования.</span><span class="sxs-lookup"><span data-stu-id="1f039-109"><xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> enables a pool of reusable context instances.</span></span> <span data-ttu-id="1f039-110">Чтобы использовать пулы контекста, используйте `AddDbContextPool` метод вместо `AddDbContext` во время регистрации службы:</span><span class="sxs-lookup"><span data-stu-id="1f039-110">To use context pooling, use the `AddDbContextPool` method instead of `AddDbContext` during service registration:</span></span>

```csharp
services.AddDbContextPool<BloggingContext>(
    options => options.UseSqlServer(connectionString));
```

<span data-ttu-id="1f039-111">Если `AddDbContextPool` используется, то при запросе экземпляра контекста EF сначала проверяет, доступен ли экземпляр в пуле.</span><span class="sxs-lookup"><span data-stu-id="1f039-111">When `AddDbContextPool` is used, at the time a context instance is requested, EF first checks if there is an instance available in the pool.</span></span> <span data-ttu-id="1f039-112">После завершения обработки запроса любое состояние экземпляра сбрасывается, а сам экземпляр возвращается в пул.</span><span class="sxs-lookup"><span data-stu-id="1f039-112">Once the request processing finalizes, any state on the instance is reset and the instance is itself returned to the pool.</span></span>

<span data-ttu-id="1f039-113">Это концептуально похоже на то, как пулы соединений работают в поставщиках ADO.NET и имеют преимущество при сохранении некоторых затрат на инициализацию экземпляра контекста.</span><span class="sxs-lookup"><span data-stu-id="1f039-113">This is conceptually similar to how connection pooling operates in ADO.NET providers and has the advantage of saving some of the cost of initialization of the context instance.</span></span>

<span data-ttu-id="1f039-114">`poolSize`Параметр <xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> задает максимальное число экземпляров, хранящихся в пуле.</span><span class="sxs-lookup"><span data-stu-id="1f039-114">The `poolSize` parameter of <xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> sets the maximum number of instances retained by the pool.</span></span> <span data-ttu-id="1f039-115">После этого `poolSize` новые экземпляры контекста не кэшируются, а EF возвращается к поведению без пула, создающего экземпляры по запросу.</span><span class="sxs-lookup"><span data-stu-id="1f039-115">Once `poolSize` is exceeded, new context instances are not cached and  EF falls back to the non-pooling behavior of creating instances on demand.</span></span>

### <a name="limitations"></a><span data-ttu-id="1f039-116">Ограничения</span><span class="sxs-lookup"><span data-stu-id="1f039-116">Limitations</span></span>

<span data-ttu-id="1f039-117">Приложения должны быть профилированы и протестированы для демонстрации того, что инициализация контекста является значительной ценой.</span><span class="sxs-lookup"><span data-stu-id="1f039-117">Apps should be profiled and tested to show that context initialization is a significant cost.</span></span>

<span data-ttu-id="1f039-118">`AddDbContextPool` имеет несколько ограничений на то, что может быть сделано в `OnConfiguring` методе контекста.</span><span class="sxs-lookup"><span data-stu-id="1f039-118">`AddDbContextPool` has a few limitations on what can be done in the `OnConfiguring` method of the context.</span></span>

> [!WARNING]
> <span data-ttu-id="1f039-119">Избегайте использования контекстного пула в приложениях, которые поддерживают состояние.</span><span class="sxs-lookup"><span data-stu-id="1f039-119">Avoid using context pooling in apps that maintain state.</span></span> <span data-ttu-id="1f039-120">Например, закрытые поля в контексте, которые не должны совместно использоваться в запросах.</span><span class="sxs-lookup"><span data-stu-id="1f039-120">For example, private fields in the context that shouldn't be shared across requests.</span></span> <span data-ttu-id="1f039-121">EF Core только сбрасывает состояние, о котором оно известно, перед добавлением экземпляра контекста в пул.</span><span class="sxs-lookup"><span data-stu-id="1f039-121">EF Core only resets the state that it is aware of before adding a context instance to the pool.</span></span>

<span data-ttu-id="1f039-122">Пул контекста работает путем повторного использования одного и того же экземпляра контекста в запросах.</span><span class="sxs-lookup"><span data-stu-id="1f039-122">Context pooling works by reusing the same context instance across requests.</span></span> <span data-ttu-id="1f039-123">Это означает, что оно эффективно регистрируется как [Singleton](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) в терминах самого экземпляра, чтобы его можно было сохранить.</span><span class="sxs-lookup"><span data-stu-id="1f039-123">This means that it's effectively registered as a [Singleton](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) in terms of the instance itself so that it's able to persist.</span></span>

<span data-ttu-id="1f039-124">Контекстное группирование предназначено для сценариев, в которых конфигурация контекста, включая разрешенные службы, фиксируется между запросами.</span><span class="sxs-lookup"><span data-stu-id="1f039-124">Context pooling is intended for scenarios where the context configuration, which includes services resolved, is fixed between requests.</span></span> <span data-ttu-id="1f039-125">Для случаев, когда требуются службы с заданной [областью](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) или необходимо изменить конфигурацию, не используйте пулы.</span><span class="sxs-lookup"><span data-stu-id="1f039-125">For cases where [Scoped](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) services are required, or configuration needs to be changed, don't use pooling.</span></span> <span data-ttu-id="1f039-126">Повышение производительности при использовании пулов обычно незначительно, за исключением сценариев с высоким уровнем оптимизации.</span><span class="sxs-lookup"><span data-stu-id="1f039-126">The performance gain from pooling is usually negligible except in highly optimized scenarios.</span></span>

## <a name="query-caching-and-parameterization"></a><span data-ttu-id="1f039-127">Кэширование запросов и параметризация</span><span class="sxs-lookup"><span data-stu-id="1f039-127">Query caching and parameterization</span></span>

<span data-ttu-id="1f039-128">Когда EF получает дерево запросов LINQ для выполнения, сначала необходимо «компилировать» это дерево в SQL-запрос.</span><span class="sxs-lookup"><span data-stu-id="1f039-128">When EF receives a LINQ query tree for execution, it must first "compile" that tree into a SQL query.</span></span> <span data-ttu-id="1f039-129">Поскольку это очень интенсивный процесс, EF кэширует запросы по *структуре дерева запросов*: запросы с одной и той же структурой повторно используют внутренние выходные данные компиляции с внутренним кэшированием и могут пропустить повторную компиляцию.</span><span class="sxs-lookup"><span data-stu-id="1f039-129">Because this is a heavy process, EF caches queries by the query tree *shape*: queries with the same structure reuse internally-cached compilation outputs, and can skip repeated compilation.</span></span> <span data-ttu-id="1f039-130">Различные запросы по-прежнему могут ссылаться на разные *значения*, но при условии, что эти значения правильно параметризованы, структура одинакова и кэширование будет работать правильно.</span><span class="sxs-lookup"><span data-stu-id="1f039-130">The different queries may still reference different *values*, but as long as these values are properly parameterized, the structure is the same and caching will function properly.</span></span>

<span data-ttu-id="1f039-131">Рассмотрим следующие два запроса:</span><span class="sxs-lookup"><span data-stu-id="1f039-131">Consider the following two queries:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#QueriesWithConstants)]

<span data-ttu-id="1f039-132">Поскольку деревья выражений содержат различные константы, дерево выражений различается, и каждый из этих запросов будет компилироваться отдельно EF Core.</span><span class="sxs-lookup"><span data-stu-id="1f039-132">Since the expression trees contains different constants, the expression tree differs and each of these queries will be compiled separately by EF Core.</span></span> <span data-ttu-id="1f039-133">Кроме того, каждый запрос создает немного другую команду SQL:</span><span class="sxs-lookup"><span data-stu-id="1f039-133">In addition, each query produces a slightly different SQL command:</span></span>

```sql
SELECT TOP(1) [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] = N'blog1'

SELECT TOP(1) [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] = N'blog2'
```

<span data-ttu-id="1f039-134">Поскольку SQL отличается, сервер базы данных, скорее всего, должен будет создать план запроса для обоих запросов, а не использовать тот же план.</span><span class="sxs-lookup"><span data-stu-id="1f039-134">Because the SQL differs, your database server will likely also need to produce a query plan for both queries, rather than reusing the same plan.</span></span>

<span data-ttu-id="1f039-135">Небольшое изменение в запросах может значительно измениться:</span><span class="sxs-lookup"><span data-stu-id="1f039-135">A small modification to your queries can change things considerably:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#QueriesWithParameterization)]

<span data-ttu-id="1f039-136">Так как имя блога теперь является *параметризованным*, оба запроса имеют одну и ту же структуру дерева, и EF нужно компилировать только один раз.</span><span class="sxs-lookup"><span data-stu-id="1f039-136">Since the blog name is now *parameterized*, both queries have the same tree shape, and EF only needs to be compiled once.</span></span> <span data-ttu-id="1f039-137">Созданный SQL также является параметризованным, что позволяет базе данных повторно использовать тот же план запроса:</span><span class="sxs-lookup"><span data-stu-id="1f039-137">The SQL produced is also parameterized, allowing the database to reuse the same query plan:</span></span>

```sql
SELECT TOP(1) [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] = @__blogName_0
```

<span data-ttu-id="1f039-138">Обратите внимание, что не нужно параметризовать каждый и каждый запрос: вполне удобно иметь некоторые запросы с константами, а в действительности базы данных (и EF) иногда могут выполнять определенную оптимизацию вокруг констант, которые невозможны при параметризации запроса.</span><span class="sxs-lookup"><span data-stu-id="1f039-138">Note that there is no need to parameterize each and every query: it's perfectly fine to have some queries with constants, and indeed, databases (and EF) can sometimes perform certain optimization around constants which aren't possible when the query is parameterized.</span></span> <span data-ttu-id="1f039-139">См. раздел, посвященный [динамически созданным запросам](#dynamically-constructed-queries) , в том случае, если Правильная параметризация имеет решающее значение.</span><span class="sxs-lookup"><span data-stu-id="1f039-139">See the section on [dynamically-constructed queries](#dynamically-constructed-queries) for an example where proper parameterization is crucial.</span></span>

> [!NOTE]
> <span data-ttu-id="1f039-140">[Счетчики событий](xref:core/logging-events-diagnostics/event-counters) EF Core отчет о доле попаданий в кэш запросов.</span><span class="sxs-lookup"><span data-stu-id="1f039-140">EF Core's [event counters](xref:core/logging-events-diagnostics/event-counters) report the Query Cache Hit Rate.</span></span> <span data-ttu-id="1f039-141">В обычном приложении этот счетчик достигает 100% вскоре после запуска программы, как только один раз выполняется большинство запросов.</span><span class="sxs-lookup"><span data-stu-id="1f039-141">In a normal application, this counter reaches 100% soon after program startup, once most queries have executed at least once.</span></span> <span data-ttu-id="1f039-142">Если значение счетчика остается стабильным ниже 100%, это указывает на то, что приложение может сделать что-то, что не нарушает кэш запросов. это хороший смысл исследовать это.</span><span class="sxs-lookup"><span data-stu-id="1f039-142">If this counter remains stable below 100%, that is an indication that your application may be doing something which defeats the query cache - it's a good idea to investigate that.</span></span>

> [!NOTE]
> <span data-ttu-id="1f039-143">Управление базой данных в кэшах планов запросов зависит от базы данных.</span><span class="sxs-lookup"><span data-stu-id="1f039-143">How the database manages caches query plans is database-dependent.</span></span> <span data-ttu-id="1f039-144">Например, SQL Server неявно поддерживает кэш планов запросов LRU, а PostgreSQL — нет (но подготовленные инструкции могут привести к очень похожему результату).</span><span class="sxs-lookup"><span data-stu-id="1f039-144">For example, SQL Server implicitly maintains an LRU query plan cache, whereas PostgreSQL does not (but prepared statements can produce a very similar end effect).</span></span> <span data-ttu-id="1f039-145">Дополнительные сведения см. в документации по базе данных.</span><span class="sxs-lookup"><span data-stu-id="1f039-145">Consult your database documentation for more details.</span></span>

## <a name="dynamically-constructed-queries"></a><span data-ttu-id="1f039-146">Динамически сконструированные запросы</span><span class="sxs-lookup"><span data-stu-id="1f039-146">Dynamically-constructed queries</span></span>

<span data-ttu-id="1f039-147">В некоторых ситуациях необходимо динамически создавать запросы LINQ, а не указывать их непосредственно в исходном коде.</span><span class="sxs-lookup"><span data-stu-id="1f039-147">In some situations, it is necessary to dynamically construct LINQ queries rather than specifying them outright in source code.</span></span> <span data-ttu-id="1f039-148">Это может произойти, например, на веб-сайте, который получает от клиента произвольные сведения о запросе с закрытыми операторами запроса (сортировка, фильтрация, разбиение на страницы...). В принципе, если это сделано правильно, динамически сконструированные запросы могут быть настолько же эффективными, как обычные (хотя нельзя использовать оптимизацию скомпилированных запросов с динамическими запросами).</span><span class="sxs-lookup"><span data-stu-id="1f039-148">This can happen, for example, in a website which receives arbitrary query details from a client, with open-ended query operators (sorting, filtering, paging...). In principle, if done correctly, dynamically-constructed queries can be just as efficient as regular ones (although it's not possible to use the compiled query optimization with dynamic queries).</span></span> <span data-ttu-id="1f039-149">Однако на практике они часто являются источником проблем с производительностью, так как легко можно случайно создать деревья выражений с фигурами, которые различаются каждый раз.</span><span class="sxs-lookup"><span data-stu-id="1f039-149">In practice, however, they are frequently the source of performance issues, since it's easy to accidentally produce expression trees with shapes that differ every time.</span></span>

<span data-ttu-id="1f039-150">В следующем примере используются два метода для динамического создания запроса. Мы добавляем `Where` оператор в запрос, только если данный параметр не равен null.</span><span class="sxs-lookup"><span data-stu-id="1f039-150">The following example uses two techniques to dynamically construct a query; we add a `Where` operator to the query only if the given parameter is not null.</span></span> <span data-ttu-id="1f039-151">Обратите внимание, что это не хороший вариант использования для динамического создания запроса, но мы используем его для простоты:</span><span class="sxs-lookup"><span data-stu-id="1f039-151">Note that this isn't a good use case for dynamically constructing a query - but we're using it for simplicity:</span></span>

### <a name="with-constant"></a>[<span data-ttu-id="1f039-152">С константой</span><span class="sxs-lookup"><span data-stu-id="1f039-152">With constant</span></span>](#tab/with-constant)

[!code-csharp[Main](../../../samples/core/Benchmarks/DynamicallyConstructedQueries.cs?name=WithConstant&highlight=14-24)]

### <a name="with-parameter"></a>[<span data-ttu-id="1f039-153">С параметром</span><span class="sxs-lookup"><span data-stu-id="1f039-153">With parameter</span></span>](#tab/with-parameter)

[!code-csharp[Main](../../../samples/core/Benchmarks/DynamicallyConstructedQueries.cs?name=WithParameter&highlight=14)]

***

<span data-ttu-id="1f039-154">Тестирование этих двух методов дает следующие результаты.</span><span class="sxs-lookup"><span data-stu-id="1f039-154">Benchmarking these two techniques gives the following results:</span></span>

|        <span data-ttu-id="1f039-155">Метод</span><span class="sxs-lookup"><span data-stu-id="1f039-155">Method</span></span> |       <span data-ttu-id="1f039-156">Среднее значение</span><span class="sxs-lookup"><span data-stu-id="1f039-156">Mean</span></span> |    <span data-ttu-id="1f039-157">Ошибка</span><span class="sxs-lookup"><span data-stu-id="1f039-157">Error</span></span> |    <span data-ttu-id="1f039-158">StdDev</span><span class="sxs-lookup"><span data-stu-id="1f039-158">StdDev</span></span> |   <span data-ttu-id="1f039-159">Gen 0</span><span class="sxs-lookup"><span data-stu-id="1f039-159">Gen 0</span></span> |  <span data-ttu-id="1f039-160">Gen 1</span><span class="sxs-lookup"><span data-stu-id="1f039-160">Gen 1</span></span> | <span data-ttu-id="1f039-161">Gen 2</span><span class="sxs-lookup"><span data-stu-id="1f039-161">Gen 2</span></span> | <span data-ttu-id="1f039-162">Allocated</span><span class="sxs-lookup"><span data-stu-id="1f039-162">Allocated</span></span> |
|-------------- |-----------:|---------:|----------:|--------:|-------:|------:|----------:|
|  <span data-ttu-id="1f039-163">висконстант</span><span class="sxs-lookup"><span data-stu-id="1f039-163">WithConstant</span></span> | <span data-ttu-id="1f039-164">1 096,7 США</span><span class="sxs-lookup"><span data-stu-id="1f039-164">1,096.7 us</span></span> | <span data-ttu-id="1f039-165">12,54 США</span><span class="sxs-lookup"><span data-stu-id="1f039-165">12.54 us</span></span> |  <span data-ttu-id="1f039-166">11,12 США</span><span class="sxs-lookup"><span data-stu-id="1f039-166">11.12 us</span></span> | <span data-ttu-id="1f039-167">13,6719</span><span class="sxs-lookup"><span data-stu-id="1f039-167">13.6719</span></span> | <span data-ttu-id="1f039-168">1,9531</span><span class="sxs-lookup"><span data-stu-id="1f039-168">1.9531</span></span> |     - |  <span data-ttu-id="1f039-169">83,91 КБ</span><span class="sxs-lookup"><span data-stu-id="1f039-169">83.91 KB</span></span> |
| <span data-ttu-id="1f039-170">виспараметер</span><span class="sxs-lookup"><span data-stu-id="1f039-170">WithParameter</span></span> |   <span data-ttu-id="1f039-171">570,8 США</span><span class="sxs-lookup"><span data-stu-id="1f039-171">570.8 us</span></span> | <span data-ttu-id="1f039-172">42,43 США</span><span class="sxs-lookup"><span data-stu-id="1f039-172">42.43 us</span></span> | <span data-ttu-id="1f039-173">124,43 США</span><span class="sxs-lookup"><span data-stu-id="1f039-173">124.43 us</span></span> |  <span data-ttu-id="1f039-174">5,8594</span><span class="sxs-lookup"><span data-stu-id="1f039-174">5.8594</span></span> |      - |     - |  <span data-ttu-id="1f039-175">37,16 КБ</span><span class="sxs-lookup"><span data-stu-id="1f039-175">37.16 KB</span></span> |

<span data-ttu-id="1f039-176">Даже если разница во вложенной миллисекунде кажется небольшой, помните, что постоянная версия постоянно засоряет кэш и вызывает повторную компиляцию других запросов, что замедляет их работу.</span><span class="sxs-lookup"><span data-stu-id="1f039-176">Even if the sub-millisecond difference seems small, keep in mind that the constant version continuously pollutes the cache and causes other queries to be re-compiled, slowing them down as well.</span></span>

> [!NOTE]
> <span data-ttu-id="1f039-177">Избегайте создания запросов с помощью API дерева выражений, если только это не требуется.</span><span class="sxs-lookup"><span data-stu-id="1f039-177">Avoid constructing queries with the expression tree API unless you really need to.</span></span> <span data-ttu-id="1f039-178">Помимо сложности API, очень просто непреднамеренно вызвать серьезные проблемы с производительностью при их использовании.</span><span class="sxs-lookup"><span data-stu-id="1f039-178">Aside from the API's complexity, it's very easy to inadvertently cause significant performance issues when using them.</span></span>
