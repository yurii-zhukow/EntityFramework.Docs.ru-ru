---
title: Дополнительные разделы о производительности
description: Дополнительные разделы о производительности для Entity Framework Core
author: rick-anderson
ms.author: riande
ms.date: 12/9/2020
uid: core/performance/advanced-performance-topics
ms.openlocfilehash: 3c0340e1b36cbbb96d23db0633cb2eebc04dd970
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657764"
---
# <a name="advanced-performance-topics"></a>Дополнительные разделы о производительности

## <a name="dbcontext-pooling"></a>Создание пулов DbContext

`AddDbContextPool` включает создание пулов `DbContext` экземпляров. Пул контекста может увеличить пропускную способность в крупномасштабных сценариях, таких как веб-серверы, путем повторного использования экземпляров контекста вместо создания новых экземпляров для каждого запроса.

Типичный шаблон в ASP.NET Core приложении, использующем EF Core, включает регистрацию пользовательского <xref:Microsoft.EntityFrameworkCore.DbContext> типа в контейнер [внедрения зависимостей](/aspnet/core/fundamentals/dependency-injection) и получение экземпляров этого типа через параметры конструктора в контроллерах или Razor Pages. При использовании внедрения конструктора для каждого запроса создается новый экземпляр контекста.

<xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> включает пул экземпляров контекста для повторного использования. Чтобы использовать пулы контекста, используйте `AddDbContextPool` метод вместо `AddDbContext` во время регистрации службы:

```csharp
services.AddDbContextPool<BloggingContext>(
    options => options.UseSqlServer(connectionString));
```

Если `AddDbContextPool` используется, то при запросе экземпляра контекста EF сначала проверяет, доступен ли экземпляр в пуле. После завершения обработки запроса любое состояние экземпляра сбрасывается, а сам экземпляр возвращается в пул.

Это концептуально похоже на то, как пулы соединений работают в поставщиках ADO.NET и имеют преимущество при сохранении некоторых затрат на инициализацию экземпляра контекста.

`poolSize`Параметр <xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> задает максимальное число экземпляров, хранящихся в пуле. После этого `poolSize` новые экземпляры контекста не кэшируются, а EF возвращается к поведению без пула, создающего экземпляры по запросу.

### <a name="limitations"></a>Ограничения

Приложения должны быть профилированы и протестированы для демонстрации того, что инициализация контекста является значительной ценой.

`AddDbContextPool` имеет несколько ограничений на то, что может быть сделано в `OnConfiguring` методе контекста.

> [!WARNING]
> Избегайте использования контекстного пула в приложениях, которые поддерживают состояние. Например, закрытые поля в контексте, которые не должны совместно использоваться в запросах. EF Core только сбрасывает состояние, о котором оно известно, перед добавлением экземпляра контекста в пул.

Пул контекста работает путем повторного использования одного и того же экземпляра контекста в запросах. Это означает, что оно эффективно регистрируется как [Singleton](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) в терминах самого экземпляра, чтобы его можно было сохранить.

Контекстное группирование предназначено для сценариев, в которых конфигурация контекста, включая разрешенные службы, фиксируется между запросами. Для случаев, когда требуются службы с заданной [областью](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) или необходимо изменить конфигурацию, не используйте пулы. Повышение производительности при использовании пулов обычно незначительно, за исключением сценариев с высоким уровнем оптимизации.

## <a name="query-caching-and-parameterization"></a>Кэширование запросов и параметризация

Когда EF получает дерево запросов LINQ для выполнения, сначала необходимо «компилировать» это дерево в SQL-запрос. Поскольку это очень интенсивный процесс, EF кэширует запросы по *структуре дерева запросов*: запросы с одной и той же структурой повторно используют внутренние выходные данные компиляции с внутренним кэшированием и могут пропустить повторную компиляцию. Различные запросы по-прежнему могут ссылаться на разные *значения*, но при условии, что эти значения правильно параметризованы, структура одинакова и кэширование будет работать правильно.

Рассмотрим следующие два запроса:

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#QueriesWithConstants)]

Поскольку деревья выражений содержат различные константы, дерево выражений различается, и каждый из этих запросов будет компилироваться отдельно EF Core. Кроме того, каждый запрос создает немного другую команду SQL:

```sql
SELECT TOP(1) [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] = N'blog1'

SELECT TOP(1) [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] = N'blog2'
```

Поскольку SQL отличается, сервер базы данных, скорее всего, должен будет создать план запроса для обоих запросов, а не использовать тот же план.

Небольшое изменение в запросах может значительно измениться:

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#QueriesWithParameterization)]

Так как имя блога теперь является *параметризованным*, оба запроса имеют одну и ту же структуру дерева, и EF нужно компилировать только один раз. Созданный SQL также является параметризованным, что позволяет базе данных повторно использовать тот же план запроса:

```sql
SELECT TOP(1) [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] = @__blogName_0
```

Обратите внимание, что не нужно параметризовать каждый и каждый запрос: вполне удобно иметь некоторые запросы с константами, а в действительности базы данных (и EF) иногда могут выполнять определенную оптимизацию вокруг констант, которые невозможны при параметризации запроса. См. раздел, посвященный [динамически созданным запросам](#dynamically-constructed-queries) , в том случае, если Правильная параметризация имеет решающее значение.

> [!NOTE]
> [Счетчики событий](xref:core/logging-events-diagnostics/event-counters) EF Core отчет о доле попаданий в кэш запросов. В обычном приложении этот счетчик достигает 100% вскоре после запуска программы, как только один раз выполняется большинство запросов. Если значение счетчика остается стабильным ниже 100%, это указывает на то, что приложение может сделать что-то, что не нарушает кэш запросов. это хороший смысл исследовать это.

> [!NOTE]
> Управление базой данных в кэшах планов запросов зависит от базы данных. Например, SQL Server неявно поддерживает кэш планов запросов LRU, а PostgreSQL — нет (но подготовленные инструкции могут привести к очень похожему результату). Дополнительные сведения см. в документации по базе данных.

## <a name="dynamically-constructed-queries"></a>Динамически сконструированные запросы

В некоторых ситуациях необходимо динамически создавать запросы LINQ, а не указывать их непосредственно в исходном коде. Это может произойти, например, на веб-сайте, который получает от клиента произвольные сведения о запросе с закрытыми операторами запроса (сортировка, фильтрация, разбиение на страницы...). В принципе, если это сделано правильно, динамически сконструированные запросы могут быть настолько же эффективными, как обычные (хотя нельзя использовать оптимизацию скомпилированных запросов с динамическими запросами). Однако на практике они часто являются источником проблем с производительностью, так как легко можно случайно создать деревья выражений с фигурами, которые различаются каждый раз.

В следующем примере используются два метода для динамического создания запроса. Мы добавляем `Where` оператор в запрос, только если данный параметр не равен null. Обратите внимание, что это не хороший вариант использования для динамического создания запроса, но мы используем его для простоты:

### <a name="with-constant"></a>[С константой](#tab/with-constant)

[!code-csharp[Main](../../../samples/core/Benchmarks/DynamicallyConstructedQueries.cs?name=WithConstant&highlight=14-24)]

### <a name="with-parameter"></a>[С параметром](#tab/with-parameter)

[!code-csharp[Main](../../../samples/core/Benchmarks/DynamicallyConstructedQueries.cs?name=WithParameter&highlight=14)]

***

Тестирование этих двух методов дает следующие результаты.

|        Метод |       Среднее значение |    Ошибка |    StdDev |   Gen 0 |  Gen 1 | Gen 2 | Allocated |
|-------------- |-----------:|---------:|----------:|--------:|-------:|------:|----------:|
|  висконстант | 1 096,7 США | 12,54 США |  11,12 США | 13,6719 | 1,9531 |     - |  83,91 КБ |
| виспараметер |   570,8 США | 42,43 США | 124,43 США |  5,8594 |      - |     - |  37,16 КБ |

Даже если разница во вложенной миллисекунде кажется небольшой, помните, что постоянная версия постоянно засоряет кэш и вызывает повторную компиляцию других запросов, что замедляет их работу.

> [!NOTE]
> Избегайте создания запросов с помощью API дерева выражений, если только это не требуется. Помимо сложности API, очень просто непреднамеренно вызвать серьезные проблемы с производительностью при их использовании.
