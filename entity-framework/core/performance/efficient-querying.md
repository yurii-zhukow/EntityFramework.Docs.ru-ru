---
title: Эффективные запросы — EF Core
description: Обзор производительности для эффективного выполнения запросов с помощью Entity Framework Core
author: roji
ms.date: 12/1/2020
uid: core/performance/efficient-querying
ms.openlocfilehash: acd5388745e74a42925c8500ce610aef83e75384
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657741"
---
# <a name="efficient-querying"></a><span data-ttu-id="25e79-103">Эффективные запросы</span><span class="sxs-lookup"><span data-stu-id="25e79-103">Efficient Querying</span></span>

<span data-ttu-id="25e79-104">Эффективный запрос — это обширная тема, охватывающая темы в виде индексов, связанных стратегий загрузки сущностей и многих других.</span><span class="sxs-lookup"><span data-stu-id="25e79-104">Querying efficiently is a vast subject, that covers subjects as wide-ranging as indexes, related entity loading strategies, and many others.</span></span> <span data-ttu-id="25e79-105">В этом разделе подробно описаны некоторые распространенные темы, позволяющие ускорить выполнение запросов, а обычно возникают ошибки, возникающие у пользователей.</span><span class="sxs-lookup"><span data-stu-id="25e79-105">This section details some common themes for making your queries faster, and pitfalls users typically encounter.</span></span>

## <a name="use-indexes-properly"></a><span data-ttu-id="25e79-106">Правильно использовать индексы</span><span class="sxs-lookup"><span data-stu-id="25e79-106">Use indexes properly</span></span>

<span data-ttu-id="25e79-107">Основной фактор, определяющий, выполняется ли запрос быстро или нет, — будет ли он правильно использовать индексы там, где это уместно: базы данных обычно используются для хранения больших объемов данных, а запросы, которые проходят по всей таблице, обычно являются источником серьезных проблем с производительностью.</span><span class="sxs-lookup"><span data-stu-id="25e79-107">The main deciding factor in whether a query runs fast or not is whether it will properly utilize indexes where appropriate: databases are typically used to hold large amounts of data, and queries which traverse entire tables are typically sources of serious performance issues.</span></span> <span data-ttu-id="25e79-108">Проблемы с индексированием легко выявить, поскольку это не просто очевидно, будет ли заданный запрос использовать индекс.</span><span class="sxs-lookup"><span data-stu-id="25e79-108">Indexing issues aren't easy to spot, because it isn't immediately obvious whether a given query will use an index or not.</span></span> <span data-ttu-id="25e79-109">Пример:</span><span class="sxs-lookup"><span data-stu-id="25e79-109">For example:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#Indexes)]

<span data-ttu-id="25e79-110">Хорошим способом выявления проблем с индексацией является то, что сначала следует определить, что запрос работает очень быстро, а затем изучить его план запроса с помощью избранного средства базы данных. Дополнительные сведения о том, как это сделать, см. на странице [Диагностика производительности](xref:core/performance/performance-diagnosis) .</span><span class="sxs-lookup"><span data-stu-id="25e79-110">A good way to spot indexing issues is to first pinpoint a slow query, and then examine its query plan via your database's favorite tool; see the [performance diagnosis](xref:core/performance/performance-diagnosis) page for more information on how to do that.</span></span> <span data-ttu-id="25e79-111">План запроса показывает, проходит ли запрос всю таблицу или использует индекс.</span><span class="sxs-lookup"><span data-stu-id="25e79-111">The query plan displays whether the query traverses the entire table, or uses an index.</span></span>

<span data-ttu-id="25e79-112">Как правило, не существует специальных знаний EF для использования индексов или диагностики проблем с производительностью. Общие базы данных, связанные с индексами, точно так же важны для приложений EF, как и приложения, не использующие EF.</span><span class="sxs-lookup"><span data-stu-id="25e79-112">As a general rule, there isn't any special EF knowledge to using indexes or diagnosing performance issues related to them; general database knowledge related to indexes is just as relevant to EF applications as to applications not using EF.</span></span> <span data-ttu-id="25e79-113">Ниже приведены некоторые общие рекомендации, которые следует учитывать при использовании индексов.</span><span class="sxs-lookup"><span data-stu-id="25e79-113">The following lists some general guidelines to keep in mind when using indexes:</span></span>

* <span data-ttu-id="25e79-114">Хотя индексы ускоряют запросы, они также замедляют работу обновлений, так как они нуждаются в актуальном состоянии.</span><span class="sxs-lookup"><span data-stu-id="25e79-114">While indexes speed up queries, they also slow down updates since they need to be kept up-to-date.</span></span> <span data-ttu-id="25e79-115">Избегайте определения ненужных индексов и рассмотрите возможность использования [фильтров индексов](xref:core/modeling/indexes#index-filter) для ограничения индекса подмножеством строк, тем самым уменьшая издержки.</span><span class="sxs-lookup"><span data-stu-id="25e79-115">Avoid defining indexes which aren't needed, and consider using [index filters](xref:core/modeling/indexes#index-filter) to limit the index to a subset of the rows, thereby reducing this overhead.</span></span>
* <span data-ttu-id="25e79-116">Составные индексы могут ускорить запросы, которые фильтруются по нескольким столбцам, но они также могут ускорить запросы, которые не фильтруют по всем столбцам индекса, в зависимости от порядка сортировки.</span><span class="sxs-lookup"><span data-stu-id="25e79-116">Composite indexes can speed up queries which filter on multiple columns, but they can also speed up queries which don't filter on all the index's columns - depending on ordering.</span></span> <span data-ttu-id="25e79-117">Например, индекс в столбцах A и B ускоряет фильтрацию запросов по A и B, а также к запросам, которые фильтруются только по, но не ускоряют фильтрацию запросов только по B.</span><span class="sxs-lookup"><span data-stu-id="25e79-117">For example, an index on columns A and B speed up queries filtering by A and B, as well as queries filtering only by A, but it does not speed up queries filtering over only by B.</span></span>
* <span data-ttu-id="25e79-118">Если запрос фильтрует по выражению для столбца (например `price / 2` ,), то простой индекс использовать нельзя.</span><span class="sxs-lookup"><span data-stu-id="25e79-118">If a query filters by an expression over a column (e.g. `price / 2`), a simple index cannot be used.</span></span> <span data-ttu-id="25e79-119">Однако можно определить [сохраненный материализованный столбец](xref:core/modeling/generated-properties#computed-columns) для выражения и создать для него индекс.</span><span class="sxs-lookup"><span data-stu-id="25e79-119">However, you can define a [stored persisted column](xref:core/modeling/generated-properties#computed-columns) for your expression, and create an index over that.</span></span> <span data-ttu-id="25e79-120">Некоторые базы данных также поддерживают индексы выражений, которые можно напрямую использовать для ускорения фильтрации запросов по любому выражению.</span><span class="sxs-lookup"><span data-stu-id="25e79-120">Some databases also support expression indexes, which can be directly used to speed up queries filtering by any expression.</span></span>
* <span data-ttu-id="25e79-121">Различные базы данных позволяют настроить индексы различными способами, и во многих случаях EF Core поставщики предоставляют их через интерфейс API Fluent.</span><span class="sxs-lookup"><span data-stu-id="25e79-121">Different databases allow indexes to be configured in various ways, and in many cases EF Core providers expose these via the Fluent API.</span></span> <span data-ttu-id="25e79-122">Например, поставщик SQL Server позволяет указать, является ли индекс [кластеризованным](xref:core/providers/sql-server/indexes#clustering), или задать его [Коэффициент заполнения](xref:core/providers/sql-server/indexes#fill-factor).</span><span class="sxs-lookup"><span data-stu-id="25e79-122">For example, the SQL Server provider allows you to configure whether an index is [clustered](xref:core/providers/sql-server/indexes#clustering), or set its [fill factor](xref:core/providers/sql-server/indexes#fill-factor).</span></span> <span data-ttu-id="25e79-123">Дополнительные сведения см. в документации поставщика.</span><span class="sxs-lookup"><span data-stu-id="25e79-123">Consult your provider's documentation for more information.</span></span>

## <a name="project-only-properties-you-need"></a><span data-ttu-id="25e79-124">Нужные свойства только для проекта</span><span class="sxs-lookup"><span data-stu-id="25e79-124">Project only properties you need</span></span>

<span data-ttu-id="25e79-125">EF Core упрощает запрос экземпляров сущностей, а затем использует эти экземпляры в коде.</span><span class="sxs-lookup"><span data-stu-id="25e79-125">EF Core makes it very easy to query out entity instances, and then use those instances in code.</span></span> <span data-ttu-id="25e79-126">Однако запросы к экземплярам сущностей часто запрашивают больше данных, чем требуется для базы данных.</span><span class="sxs-lookup"><span data-stu-id="25e79-126">However, querying entity instances can frequently pull back more data than necessary from your database.</span></span> <span data-ttu-id="25e79-127">Рассмотрим следующий пример.</span><span class="sxs-lookup"><span data-stu-id="25e79-127">Consider the following:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#ProjectEntities)]

<span data-ttu-id="25e79-128">Хотя для этого кода действительно требуется только свойство блога `Url` , вся сущность блога извлекается, а ненужные столбцы передаются из базы данных:</span><span class="sxs-lookup"><span data-stu-id="25e79-128">Although this code only actually needs each Blog's `Url` property, the entire Blog entity is fetched, and unneeded columns are transferred from the database:</span></span>

```sql
SELECT [b].[BlogId], [b].[CreationDate], [b].[Name], [b].[Rating], [b].[Url]
FROM [Blogs] AS [b]
```

<span data-ttu-id="25e79-129">Это можно оптимизировать с помощью `Select` , чтобы сообщить EF, какие столбцы следует проецировать:</span><span class="sxs-lookup"><span data-stu-id="25e79-129">This can be optimized by using `Select` to tell EF which columns to project out:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#ProjectSingleProperty)]

<span data-ttu-id="25e79-130">Результирующий SQL извлекает только необходимые столбцы:</span><span class="sxs-lookup"><span data-stu-id="25e79-130">The resulting SQL pulls back only the needed columns:</span></span>

```csharp
SELECT [b].[Url]
FROM [Blogs] AS [b]
```

<span data-ttu-id="25e79-131">Если необходимо проецировать несколько столбцов, можно проецировать проект в анонимный тип C# с нужными свойствами.</span><span class="sxs-lookup"><span data-stu-id="25e79-131">If you need to project out more than one column, project out to a C# anonymous type with the properties you want.</span></span>

<span data-ttu-id="25e79-132">Обратите внимание, что этот метод очень полезен для запросов только для чтения, но при необходимости *обновления* изученных блогов он становится более сложным, так как отслеживание изменений EF работает только с экземплярами сущностей.</span><span class="sxs-lookup"><span data-stu-id="25e79-132">Note that this technique is very useful for read-only queries, but things get more complicated if you need to *update* the fetched blogs, since EF's change tracking only works with entity instances.</span></span> <span data-ttu-id="25e79-133">Вы можете выполнять обновления, не загружая сущности целиком, подключив измененный экземпляр блога и указав EF, какие свойства изменились, но это более сложная методика, которая может быть нецелесообразна.</span><span class="sxs-lookup"><span data-stu-id="25e79-133">It's possible to perform updates without loading entire entities by attaching a modified Blog instance and telling EF which properties have changed, but that is a more advanced technique that may not be worth it.</span></span>

## <a name="limit-the-resultset-size"></a><span data-ttu-id="25e79-134">Ограничить размер результирующего набора</span><span class="sxs-lookup"><span data-stu-id="25e79-134">Limit the resultset size</span></span>

<span data-ttu-id="25e79-135">По умолчанию запрос возвращает все строки, соответствующие его фильтрам:</span><span class="sxs-lookup"><span data-stu-id="25e79-135">By default, a query returns all rows that matches its filters:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#NoLimit)]

<span data-ttu-id="25e79-136">Так как количество возвращаемых строк зависит от фактических данных в базе данных, невозможно выяснить, какой объем данных будет загружен из базы данных, сколько памяти будет выдаваться в результате и сколько дополнительной нагрузки будет создаваться при обработке этих результатов (например, путем отправки их в пользовательский браузер по сети).</span><span class="sxs-lookup"><span data-stu-id="25e79-136">Since the number of rows returned depends on actual data in your database, it's impossible to know how much data will be loaded from the database, how much memory will be taken up by the results, and how much additional load will be generated when processing these results (e.g. by sending them to a user browser over the network).</span></span> <span data-ttu-id="25e79-137">По крайней мере, тестовые базы данных часто содержат небольшие данные, так что все работает хорошо при тестировании, но проблемы с производительностью внезапно появляются, когда запрос начинает выполняться на реальных данных и возвращается много строк.</span><span class="sxs-lookup"><span data-stu-id="25e79-137">Crucially, test databases frequently contain little data, so that everything works well while testing, but performance problems suddenly appear when the query starts running on real-world data and many rows are returned.</span></span>

<span data-ttu-id="25e79-138">Как следствие, обычно стоит подумать о том, чтобы ограничить количество результатов:</span><span class="sxs-lookup"><span data-stu-id="25e79-138">As a result, it's usually worth giving thought to limiting the number of results:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#Limit25)]

<span data-ttu-id="25e79-139">Как минимум, Пользовательский интерфейс может отображать сообщение о том, что в базе данных могут существовать дополнительные строки (и разрешать их извлечение другим способом).</span><span class="sxs-lookup"><span data-stu-id="25e79-139">At a minimum, your UI could show a message indicating that more rows may exist in the database (and allow retrieving them in some other manner).</span></span> <span data-ttu-id="25e79-140">Полнофункциональное решение будет реализовывать *разбиение* на страницы, когда пользовательский интерфейс отображает определенное количество строк за раз и позволяет пользователям перейти на следующую страницу по мере необходимости. как правило, объединяет <xref:System.Linq.Enumerable.Take%2A> <xref:System.Linq.Enumerable.Skip%2A> операторы и для выбора определенного диапазона в результирующем наборе каждый раз.</span><span class="sxs-lookup"><span data-stu-id="25e79-140">A full-blown solution would implement *paging*, where your UI only shows a certain number of rows at a time, and allow users to advance to the next page as needed; this typically combines the <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> operators to select a specific range in the resultset each time.</span></span>

## <a name="avoid-cartesian-explosion-when-loading-related-entities"></a><span data-ttu-id="25e79-141">Избегайте декартового развертывания при загрузке связанных сущностей</span><span class="sxs-lookup"><span data-stu-id="25e79-141">Avoid cartesian explosion when loading related entities</span></span>

<span data-ttu-id="25e79-142">В реляционных базах данных все связанные сущности загружаются с помощью запросов JOIN в одиночном запросе.</span><span class="sxs-lookup"><span data-stu-id="25e79-142">In relational databases, all related entities are loaded by introducing JOINs in single query.</span></span>

```sql
SELECT [b].[BlogId], [b].[OwnerId], [b].[Rating], [b].[Url], [p].[PostId], [p].[AuthorId], [p].[BlogId], [p].[Content], [p].[Rating], [p].[Title]
FROM [Blogs] AS [b]
LEFT JOIN [Post] AS [p] ON [b].[BlogId] = [p].[BlogId]
ORDER BY [b].[BlogId], [p].[PostId]
```

<span data-ttu-id="25e79-143">Если в обычном блоге есть несколько связанных записей, тогда строки для этих записей будут дублировать данные блога.</span><span class="sxs-lookup"><span data-stu-id="25e79-143">If a typical blog has multiple related posts, rows for these posts will duplicate the blog's information.</span></span> <span data-ttu-id="25e79-144">Такое дублирование приводит к возникновению "картезианского взрыва" (нарушение корректности синхронизации).</span><span class="sxs-lookup"><span data-stu-id="25e79-144">This duplication leads to the so-called "cartesian explosion" problem.</span></span> <span data-ttu-id="25e79-145">Чем больше связей "один ко многим" будет загружено, тем большим будет объем дублирующихся данных, что негативно повлияет на производительность приложения.</span><span class="sxs-lookup"><span data-stu-id="25e79-145">As more one-to-many relationships are loaded, the amount of duplicated data may grow and adversely affect the performance of your application.</span></span>

<span data-ttu-id="25e79-146">EF позволяет избежать этого воздействия с помощью "разбиения запросов", которые загружают связанные сущности через отдельные запросы.</span><span class="sxs-lookup"><span data-stu-id="25e79-146">EF allows avoiding this effect via the use of "split queries", which load the related entities via separate queries.</span></span> <span data-ttu-id="25e79-147">Дополнительные сведения см. [в документации по разделению и отдельным запросам](xref:core/querying/single-split-queries).</span><span class="sxs-lookup"><span data-stu-id="25e79-147">For more information, read [the documentation on split and single queries](xref:core/querying/single-split-queries).</span></span>

> [!NOTE]
> <span data-ttu-id="25e79-148">Текущая реализация [разделенных запросов](xref:core/querying/single-split-queries) выполняет циклическое выполнение для каждого запроса.</span><span class="sxs-lookup"><span data-stu-id="25e79-148">The current implementation of [split queries](xref:core/querying/single-split-queries) executes a roundtrip for each query.</span></span> <span data-ttu-id="25e79-149">Мы планируем улучшить это в будущем и выполнить все запросы за один цикл.</span><span class="sxs-lookup"><span data-stu-id="25e79-149">We plan to improve this in the future, and execute all queries in a single roundtrip.</span></span>

## <a name="load-related-entities-eagerly-when-possible"></a><span data-ttu-id="25e79-150">Загружает связанные сущности по возможности.</span><span class="sxs-lookup"><span data-stu-id="25e79-150">Load related entities eagerly when possible</span></span>

<span data-ttu-id="25e79-151">Перед продолжением работы с этим разделом рекомендуется прочитать [выделенную страницу по связанным сущностям](xref:core/querying/related-data) .</span><span class="sxs-lookup"><span data-stu-id="25e79-151">It's recommended to read [the dedicated page on related entities](xref:core/querying/related-data) before continuing with this section.</span></span>

<span data-ttu-id="25e79-152">При работе со связанными сущностями обычно известно, что нам нужно загрузить. типичный пример — загрузка определенного набора блогов вместе со всеми записями.</span><span class="sxs-lookup"><span data-stu-id="25e79-152">When dealing with related entities, we usually know in advance what we need to load: a typical example would be loading a certain set of Blogs, along with all their Posts.</span></span> <span data-ttu-id="25e79-153">В этих сценариях всегда лучше использовать [безотлагательную загрузку](xref:core/querying/related-data/eager), чтобы EF мог извлечь все необходимые данные за один цикл.</span><span class="sxs-lookup"><span data-stu-id="25e79-153">In these scenarios, it is always better to use [eager loading](xref:core/querying/related-data/eager), so that EF can fetch all the required data in one roundtrip.</span></span> <span data-ttu-id="25e79-154">Функция [фильтрации включенных](xref:core/querying/related-data/eager#filtered-include) элементов, введенная в EF Core 5,0, также позволяет ограничить связанные сущности, которые вы хотите загрузить, сохранив процесс загрузки и, следовательно, выполнимо в одном цикле.</span><span class="sxs-lookup"><span data-stu-id="25e79-154">The [filtered include](xref:core/querying/related-data/eager#filtered-include) feature, introduced in EF Core 5.0, also allows you to limit which related entities you'd like to load, while keeping the loading process eager and therefore doable in a single roundtrip:</span></span>

[!code-csharp[Main](../../../samples/core/Querying/RelatedData/Program.cs#FilteredInclude)]

<span data-ttu-id="25e79-155">В других сценариях мы можем не знать, какая связанная сущность потребуется, прежде чем получить основную сущность.</span><span class="sxs-lookup"><span data-stu-id="25e79-155">In other scenarios, we may not know which related entity we're going to need before we get its principal entity.</span></span> <span data-ttu-id="25e79-156">Например, при загрузке какого-либо блога может потребоваться обратиться к другому источнику данных, возможно, к веб-службе, чтобы узнать, Интересует ли он записи блога.</span><span class="sxs-lookup"><span data-stu-id="25e79-156">For example, when loading some Blog, we may need to consult some other data source - possibly a webservice - in order to know whether we're interested in that Blog's Posts.</span></span> <span data-ttu-id="25e79-157">В таких случаях [явная](xref:core/querying/related-data/explicit) или [Отложенная](xref:core/querying/related-data/lazy) загрузка может использоваться для выборки связанных сущностей по отдельности и заполнения навигации по записям блога.</span><span class="sxs-lookup"><span data-stu-id="25e79-157">In these cases, [explicit](xref:core/querying/related-data/explicit) or [lazy](xref:core/querying/related-data/lazy) loading can be used to fetch related entities separately, and populate the Blog's Posts navigation.</span></span> <span data-ttu-id="25e79-158">Обратите внимание, что поскольку эти методы не готовы, они нуждаются в дополнительных обращениях к базе данных, которая является источником замедления. в зависимости от конкретного сценария может оказаться более эффективным, чтобы всегда загружать все записи, а не выполнять дополнительные обращения и выборочно получать только нужные вам записи.</span><span class="sxs-lookup"><span data-stu-id="25e79-158">Note that since these methods aren't eager, they require additional roundtrips to the database, which is source of slowdown; depending on your specific scenario, it may be more efficient to just always load all Posts, rather than to execute the additional roundtrips and selectively get only the Posts you need.</span></span>

### <a name="beware-of-lazy-loading"></a><span data-ttu-id="25e79-159">Будьте осторожны с отложенной загрузкой</span><span class="sxs-lookup"><span data-stu-id="25e79-159">Beware of lazy loading</span></span>

<span data-ttu-id="25e79-160">[Отложенная загрузка](xref:core/querying/related-data/lazy) часто кажется очень полезным способом написания логики базы данных, так как EF Core автоматически загружает связанные сущности из базы данных, так как к ним обращается ваш код.</span><span class="sxs-lookup"><span data-stu-id="25e79-160">[Lazy loading](xref:core/querying/related-data/lazy) often seems like a very useful way to write database logic, since EF Core automatically loads related entities from the database as they are accessed by your code.</span></span> <span data-ttu-id="25e79-161">Это позволяет избежать загрузки связанных сущностей, которые не нужны (например, [явная загрузка](xref:core/querying/related-data/explicit)), и, в противном случае, освобождает программиста от необходимости обращаться к связанным сущностям полностью.</span><span class="sxs-lookup"><span data-stu-id="25e79-161">This avoids loading related entities that aren't needed (like [explicit loading](xref:core/querying/related-data/explicit)), and seemingly frees the programmer from having to deal with related entities altogether.</span></span> <span data-ttu-id="25e79-162">Однако отложенная загрузка особенно уязвима для создания ненужных дополнительных обращений, которые могут замедлять работу приложения.</span><span class="sxs-lookup"><span data-stu-id="25e79-162">However, lazy loading is particularly prone for producing unneeded extra roundtrips which can slow the application.</span></span>

<span data-ttu-id="25e79-163">Рассмотрим следующий пример.</span><span class="sxs-lookup"><span data-stu-id="25e79-163">Consider the following:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#NPlusOne)]

<span data-ttu-id="25e79-164">Это, казалось бы, безобидным часть кода, которая проходит по всем блогам и их записям, распечатяя их. Включение [ведения журнала инструкции](xref:core/logging-events-diagnostics/index) EF Core открывает следующее:</span><span class="sxs-lookup"><span data-stu-id="25e79-164">This seemingly innocent piece of code iterates through all the blogs and their posts, printing them out. Turning on EF Core's [statement logging](xref:core/logging-events-diagnostics/index) reveals the following:</span></span>

```console
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [b].[BlogId], [b].[Rating], [b].[Url]
      FROM [Blogs] AS [b]
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (5ms) [Parameters=[@__p_0='1'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[@__p_0='2'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[@__p_0='3'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0

... and so on
```

<span data-ttu-id="25e79-165">В чем причина?</span><span class="sxs-lookup"><span data-stu-id="25e79-165">What's going on here?</span></span> <span data-ttu-id="25e79-166">Почему все эти запросы отправляются для простых циклов выше?</span><span class="sxs-lookup"><span data-stu-id="25e79-166">Why are all these queries being sent for the simple loops above?</span></span> <span data-ttu-id="25e79-167">При отложенной загрузке записи блога загружаются только при обращении к свойству posts (отложенно). в результате каждая итерация во внутреннем операторе foreach активирует дополнительный запрос к базе данных в отдельном цикле.</span><span class="sxs-lookup"><span data-stu-id="25e79-167">With lazy loading, a Blog's Posts are only (lazily) loaded when its Posts property is accessed; as a result, each iteration in the inner foreach triggers an additional database query, in its own roundtrip.</span></span> <span data-ttu-id="25e79-168">В результате после первоначального запроса на загрузку всех блогов у нас будет другой запрос к *блогу*, где загружаются все записи. Это иногда называется проблемой *N + 1* и может вызвать очень значительные проблемы с производительностью.</span><span class="sxs-lookup"><span data-stu-id="25e79-168">As a result, after the initial query loading all the blogs, we then have another query *per blog*, loading all its posts; this is sometimes called the *N+1* problem, and it can cause very significant performance issues.</span></span>

<span data-ttu-id="25e79-169">Предполагая, что нам нужны все записи блогов, имеет смысл использовать вместо этого безотлагательную загрузку.</span><span class="sxs-lookup"><span data-stu-id="25e79-169">Assuming we're going to need all of the blogs' posts, it makes sense to use eager loading here instead.</span></span> <span data-ttu-id="25e79-170">Для выполнения загрузки можно использовать оператор [include](xref:core/querying/related-data/eager#eager-loading) , но так как нам нужны только URL-адреса блогов (и следует [загружать только те, которые необходимы](xref:core/performance/efficient-updating#project-only-properties-you-need)).</span><span class="sxs-lookup"><span data-stu-id="25e79-170">We can use the [Include](xref:core/querying/related-data/eager#eager-loading) operator to perform the loading, but since we only need the Blogs' URLs (and we should only [load what's needed](xref:core/performance/efficient-updating#project-only-properties-you-need)).</span></span> <span data-ttu-id="25e79-171">Вместо этого мы будем использовать проекцию:</span><span class="sxs-lookup"><span data-stu-id="25e79-171">So we'll use a projection instead:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#EagerlyLoadRelatedAndProject)]

<span data-ttu-id="25e79-172">Это сделает EF Core извлекать все блоги вместе с их записями в одном запросе.</span><span class="sxs-lookup"><span data-stu-id="25e79-172">This will make EF Core fetch all the Blogs - along with their Posts - in a single query.</span></span> <span data-ttu-id="25e79-173">В некоторых случаях он также может быть полезен, чтобы избежать появления декартного развертывания с помощью [запросов Split](xref:core/querying/single-split-queries).</span><span class="sxs-lookup"><span data-stu-id="25e79-173">In some cases, it may also be useful to avoid cartesian explosion effects by using [split queries](xref:core/querying/single-split-queries).</span></span>

> [!WARNING]
> <span data-ttu-id="25e79-174">Поскольку отложенная загрузка упрощает непреднамеренное срабатывание задачи N + 1, рекомендуется избегать ее.</span><span class="sxs-lookup"><span data-stu-id="25e79-174">Because lazy loading makes it extremely easy to inadvertently trigger the N+1 problem, it is recommended to avoid it.</span></span> <span data-ttu-id="25e79-175">Упреждающая или явная загрузка делает неясной в исходном коде, когда происходит цикл обработки базы данных.</span><span class="sxs-lookup"><span data-stu-id="25e79-175">Eager or explicit loading make it very clear in the source code when a database roundtrip occurs.</span></span>

## <a name="buffering-and-streaming"></a><span data-ttu-id="25e79-176">Буферизация и потоковая передача</span><span class="sxs-lookup"><span data-stu-id="25e79-176">Buffering and streaming</span></span>

<span data-ttu-id="25e79-177">Буферизация означает загрузку всех результатов запроса в память, в то время как потоковая передача означает, что EF передает приложению один результат каждый раз, не содержащий весь набор результатов в памяти.</span><span class="sxs-lookup"><span data-stu-id="25e79-177">Buffering refers to loading all your query results into memory, whereas streaming means that that EF hands the application a single result each time, never containing the entire resultset in memory.</span></span> <span data-ttu-id="25e79-178">В принципе, требования к памяти для запроса потоковой передачи фиксированы — они одинаковы, если запрос возвращает 1 строку или 1000; для запроса буферизации, с другой стороны, требуется больше памяти, чем больше строк.</span><span class="sxs-lookup"><span data-stu-id="25e79-178">In principle, the memory requirements of a streaming query are fixed - they are the same whether the query returns 1 row or 1000; a buffering query, on the other hand, requires more memory the more rows are returned.</span></span> <span data-ttu-id="25e79-179">Для запросов, которые запрашивают большие результирующие наборы, это может быть важным фактором производительности.</span><span class="sxs-lookup"><span data-stu-id="25e79-179">For queries that result large resultsets, this can be an important performance factor.</span></span>

<span data-ttu-id="25e79-180">Зависит ли буферы или потоки запросов от того, как они оцениваются:</span><span class="sxs-lookup"><span data-stu-id="25e79-180">Whether a query buffers or streams depends on how it is evaluated:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#BufferingAndStreaming)]

<span data-ttu-id="25e79-181">Если запросы возвращают лишь несколько результатов, вам, скорее всего, не придется беспокоиться об этом.</span><span class="sxs-lookup"><span data-stu-id="25e79-181">If your queries return just a few results, then you probably don't have to worry about this.</span></span> <span data-ttu-id="25e79-182">Однако если запрос может возвращать большое количество строк, стоит подумать о потоковой передаче вместо буферизации.</span><span class="sxs-lookup"><span data-stu-id="25e79-182">However, if your query might return large numbers of rows, it's worth giving thought to streaming instead of buffering.</span></span>

> [!NOTE]
> <span data-ttu-id="25e79-183">Старайтесь не использовать <xref:System.Linq.Enumerable.ToList%2A> или, <xref:System.Linq.Enumerable.ToArray%2A> Если планируется использовать другой оператор LINQ в результате. это приведет к ненужному буферу всех результатов в памяти.</span><span class="sxs-lookup"><span data-stu-id="25e79-183">Avoid using <xref:System.Linq.Enumerable.ToList%2A> or <xref:System.Linq.Enumerable.ToArray%2A> if you intend to use another LINQ operator on the result - this will needlessly buffer all results into memory.</span></span> <span data-ttu-id="25e79-184">Взамен рекомендуется использовать <xref:System.Linq.Enumerable.AsEnumerable%2A>.</span><span class="sxs-lookup"><span data-stu-id="25e79-184">Use <xref:System.Linq.Enumerable.AsEnumerable%2A> instead.</span></span>

### <a name="internal-buffering-by-ef"></a><span data-ttu-id="25e79-185">Внутренняя буферизация EF</span><span class="sxs-lookup"><span data-stu-id="25e79-185">Internal buffering by EF</span></span>

<span data-ttu-id="25e79-186">В некоторых ситуациях EF сам сам помещает результирующий набор в буфер, независимо от того, как будет оцениваться запрос.</span><span class="sxs-lookup"><span data-stu-id="25e79-186">In certain situations, EF will itself buffer the resultset internally, regardless of how you evaluate your query.</span></span> <span data-ttu-id="25e79-187">Это происходит в двух случаях:</span><span class="sxs-lookup"><span data-stu-id="25e79-187">The two cases where this happens are:</span></span>

* <span data-ttu-id="25e79-188">При наличии стратегии повторного выполнения.</span><span class="sxs-lookup"><span data-stu-id="25e79-188">When a retrying execution strategy is in place.</span></span> <span data-ttu-id="25e79-189">Это делается для того, чтобы убедиться, что те же результаты возвращаются, если запрос повторяется позже.</span><span class="sxs-lookup"><span data-stu-id="25e79-189">This is done to make sure the same results are returned if the query is retried later.</span></span>
* <span data-ttu-id="25e79-190">Когда используется [запрос Split](xref:core/querying/single-split-queries) , результирующие наборы всех, кроме последнего запроса, буферизуются, если режим MARS не включен на SQL Server.</span><span class="sxs-lookup"><span data-stu-id="25e79-190">When [split query](xref:core/querying/single-split-queries) is used, the resultsets of all but the last query are buffered - unless MARS is enabled on SQL Server.</span></span> <span data-ttu-id="25e79-191">Это связано с тем, что обычно невозможно одновременно использовать несколько результирующих наборов запросов.</span><span class="sxs-lookup"><span data-stu-id="25e79-191">This is because it is usually impossible to have multiple query resultsets active at the same time.</span></span>

<span data-ttu-id="25e79-192">Обратите внимание, что эта внутренняя буферизация выполняется в дополнение к любой буферизации, вызванной с помощью операторов LINQ.</span><span class="sxs-lookup"><span data-stu-id="25e79-192">Note that this internal buffering occurs in addition to any buffering you cause via LINQ operators.</span></span> <span data-ttu-id="25e79-193">Например, если используется <xref:System.Linq.Enumerable.ToList%2A> для запроса и используется стратегия повторного выполнения, результирующий набор загружается в память *дважды*: один внутренне по EF и один раз в <xref:System.Linq.Enumerable.ToList%2A> .</span><span class="sxs-lookup"><span data-stu-id="25e79-193">For example, if you use <xref:System.Linq.Enumerable.ToList%2A> on a query and a retrying execution strategy is in place, the resultset is loaded into memory *twice*: once internally by EF, and once by <xref:System.Linq.Enumerable.ToList%2A>.</span></span>

## <a name="tracking-no-tracking-and-identity-resolution"></a><span data-ttu-id="25e79-194">Отслеживание, отсутствие отслеживания и разрешение идентификаторов</span><span class="sxs-lookup"><span data-stu-id="25e79-194">Tracking, no-tracking and identity resolution</span></span>

<span data-ttu-id="25e79-195">Перед продолжением работы с этим разделом рекомендуется прочитать [выделенную страницу с отслеживанием и без отслеживания](xref:core/querying/tracking) .</span><span class="sxs-lookup"><span data-stu-id="25e79-195">It's recommended to read [the dedicated page on tracking and no-tracking](xref:core/querying/tracking) before continuing with this section.</span></span>

<span data-ttu-id="25e79-196">EF отслеживает экземпляры сущностей по умолчанию, поэтому изменения в них обнаруживаются и сохраняются при <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> вызове метода.</span><span class="sxs-lookup"><span data-stu-id="25e79-196">EF tracks entity instances by default, so that changes on them are detected and persisted when <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> is called.</span></span> <span data-ttu-id="25e79-197">Еще одним результатом отслеживания запросов является то, что EF обнаруживает, что экземпляр уже загружен для ваших данных, и автоматически возвращает этот отслеживаемый экземпляр, а не возвращает новый. Это называется *разрешением идентификации*.</span><span class="sxs-lookup"><span data-stu-id="25e79-197">Another effect of tracking queries is that EF detects if an instance has already been loaded for your data, and will automatically return that tracked instance rather than returning a new one; this is called *identity resolution*.</span></span> <span data-ttu-id="25e79-198">С точки зрения производительности отслеживание изменений означает следующее:</span><span class="sxs-lookup"><span data-stu-id="25e79-198">From a performance perspective, change tracking means the following:</span></span>

* <span data-ttu-id="25e79-199">EF внутренне поддерживает словарь отслеживаний экземпляров.</span><span class="sxs-lookup"><span data-stu-id="25e79-199">EF internally maintains a dictionary of tracked instances.</span></span> <span data-ttu-id="25e79-200">При загрузке новых данных EF проверяет словарь на предмет того, что экземпляр уже зарегистрирован для ключа этой сущности (разрешение идентификаторов).</span><span class="sxs-lookup"><span data-stu-id="25e79-200">When new data is loaded, EF checks the dictionary to see if an instance is already tracked for that entity's key (identity resolution).</span></span> <span data-ttu-id="25e79-201">Обслуживание и Уточняющий запрос словаря занимают некоторое время при загрузке результатов запроса.</span><span class="sxs-lookup"><span data-stu-id="25e79-201">The dictionary maintenance and lookups take up some time when loading the query's results.</span></span>
* <span data-ttu-id="25e79-202">Перед передачей загруженного экземпляра в приложение объект EF *моментальные снимки* этого экземпляра и сохраняет моментальный снимок внутренне.</span><span class="sxs-lookup"><span data-stu-id="25e79-202">Before handing a loaded instance to the application, EF *snapshots* that instance and keeps the snapshot internally.</span></span> <span data-ttu-id="25e79-203">Когда <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> вызывается метод, экземпляр приложения сравнивается с моментальным снимком, чтобы обнаружить сохраняемые изменения.</span><span class="sxs-lookup"><span data-stu-id="25e79-203">When <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> is called, the application's instance is compared with the snapshot to discover the changes to be persisted.</span></span> <span data-ttu-id="25e79-204">Моментальный снимок занимает больше памяти, и сам процесс значит занимает некоторое время; Иногда можно указать другое, возможно более эффективное поведение значит с помощью [компараторов значений](xref:core/modeling/value-comparers)или использовать прокси-серверы отслеживания изменений, чтобы вообще обойти процесс значит (хотя это и имеет собственный набор недостатков).</span><span class="sxs-lookup"><span data-stu-id="25e79-204">The snapshot takes up more memory, and the snapshotting process itself takes time; it's sometimes possible to specify different, possibly more efficient snapshotting behavior via [value comparers](xref:core/modeling/value-comparers), or to use change-tracking proxies to bypass the snapshotting process altogether (though that comes with its own set of disadvantages).</span></span>

<span data-ttu-id="25e79-205">В сценариях только для чтения, в которых изменения не сохраняются обратно в базу данных, можно избежать приведенных выше заголовков, используя [Неотслеживаемые запросы](xref:core/querying/tracking#no-tracking-queries).</span><span class="sxs-lookup"><span data-stu-id="25e79-205">In read-only scenarios where changes aren't saved back to the database, the above overheads can be avoided by using [no-tracking queries](xref:core/querying/tracking#no-tracking-queries).</span></span> <span data-ttu-id="25e79-206">Однако, поскольку запросы без отслеживания не выполняют разрешение идентификации, строка базы данных, на которую ссылаются несколько других загруженных строк, будет материализоваться как разные экземпляры.</span><span class="sxs-lookup"><span data-stu-id="25e79-206">However, since no-tracking queries do not perform identity resolution, a database row which is referenced by multiple other loaded rows will be materialized as as different instances.</span></span>

<span data-ttu-id="25e79-207">Для иллюстрации Предположим, что мы загружаем большое количество записей из базы данных, а также блог, на который ссылается каждая запись.</span><span class="sxs-lookup"><span data-stu-id="25e79-207">To illustrate, assume we are loading a large number of Posts from the database, as well as the Blog referenced by each Post.</span></span> <span data-ttu-id="25e79-208">Если в 100 учитываются записи, ссылающиеся на один и тот же блог, запрос отслеживания обнаруживает это с помощью разрешения идентификаторов, а все экземпляры POST будут ссылаться на один и тот же недублированный экземпляр блога.</span><span class="sxs-lookup"><span data-stu-id="25e79-208">If 100 Posts happen to reference the same Blog, a tracking query detects this via identity resolution, and all Post instances will refer the same de-duplicated Blog instance.</span></span> <span data-ttu-id="25e79-209">Неотслеживаемый запрос, напротив, дублирует один и тот же блог 100 раз, и код приложения должен быть написан соответствующим образом.</span><span class="sxs-lookup"><span data-stu-id="25e79-209">A no-tracking query, in contrast, duplicates the same Blog 100 times - and application code must be written accordingly.</span></span>

<span data-ttu-id="25e79-210">Ниже приведены результаты отслеживания теста производительности и поведения без отслеживания для запроса, в котором загружаются 10 блогов с 20 записями.</span><span class="sxs-lookup"><span data-stu-id="25e79-210">Here are the results for a benchmark comparing tracking vs. no-tracking behavior for a query loading 10 Blogs with 20 Posts each.</span></span> <span data-ttu-id="25e79-211">[Исходный код доступен здесь](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/QueryTrackingBehavior.cs), поэтому вы можете использовать его в качестве основания для собственных измерений.</span><span class="sxs-lookup"><span data-stu-id="25e79-211">[The source code is available here](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/QueryTrackingBehavior.cs), feel free to use it as a basis for your own measurements.</span></span>

|       <span data-ttu-id="25e79-212">Метод</span><span class="sxs-lookup"><span data-stu-id="25e79-212">Method</span></span> | <span data-ttu-id="25e79-213">нумблогс</span><span class="sxs-lookup"><span data-stu-id="25e79-213">NumBlogs</span></span> | <span data-ttu-id="25e79-214">нумпостсперблог</span><span class="sxs-lookup"><span data-stu-id="25e79-214">NumPostsPerBlog</span></span> |       <span data-ttu-id="25e79-215">Среднее значение</span><span class="sxs-lookup"><span data-stu-id="25e79-215">Mean</span></span> |    <span data-ttu-id="25e79-216">Ошибка</span><span class="sxs-lookup"><span data-stu-id="25e79-216">Error</span></span> |   <span data-ttu-id="25e79-217">StdDev</span><span class="sxs-lookup"><span data-stu-id="25e79-217">StdDev</span></span> |     <span data-ttu-id="25e79-218">Median</span><span class="sxs-lookup"><span data-stu-id="25e79-218">Median</span></span> | <span data-ttu-id="25e79-219">Соотношение</span><span class="sxs-lookup"><span data-stu-id="25e79-219">Ratio</span></span> | <span data-ttu-id="25e79-220">ратиосд</span><span class="sxs-lookup"><span data-stu-id="25e79-220">RatioSD</span></span> |   <span data-ttu-id="25e79-221">Gen 0</span><span class="sxs-lookup"><span data-stu-id="25e79-221">Gen 0</span></span> |   <span data-ttu-id="25e79-222">Gen 1</span><span class="sxs-lookup"><span data-stu-id="25e79-222">Gen 1</span></span> | <span data-ttu-id="25e79-223">Gen 2</span><span class="sxs-lookup"><span data-stu-id="25e79-223">Gen 2</span></span> | <span data-ttu-id="25e79-224">Allocated</span><span class="sxs-lookup"><span data-stu-id="25e79-224">Allocated</span></span> |
|------------- |--------- |---------------- |-----------:|---------:|---------:|-----------:|------:|--------:|--------:|--------:|------:|----------:|
|   <span data-ttu-id="25e79-225">астраккинг</span><span class="sxs-lookup"><span data-stu-id="25e79-225">AsTracking</span></span> |       <span data-ttu-id="25e79-226">10</span><span class="sxs-lookup"><span data-stu-id="25e79-226">10</span></span> |              <span data-ttu-id="25e79-227">20</span><span class="sxs-lookup"><span data-stu-id="25e79-227">20</span></span> | <span data-ttu-id="25e79-228">1 414,7 США</span><span class="sxs-lookup"><span data-stu-id="25e79-228">1,414.7 us</span></span> | <span data-ttu-id="25e79-229">27,20 США</span><span class="sxs-lookup"><span data-stu-id="25e79-229">27.20 us</span></span> | <span data-ttu-id="25e79-230">45,44 США</span><span class="sxs-lookup"><span data-stu-id="25e79-230">45.44 us</span></span> | <span data-ttu-id="25e79-231">1 405,5 США</span><span class="sxs-lookup"><span data-stu-id="25e79-231">1,405.5 us</span></span> |  <span data-ttu-id="25e79-232">1.00</span><span class="sxs-lookup"><span data-stu-id="25e79-232">1.00</span></span> |    <span data-ttu-id="25e79-233">0,00</span><span class="sxs-lookup"><span data-stu-id="25e79-233">0.00</span></span> | <span data-ttu-id="25e79-234">60,5469</span><span class="sxs-lookup"><span data-stu-id="25e79-234">60.5469</span></span> | <span data-ttu-id="25e79-235">13,6719</span><span class="sxs-lookup"><span data-stu-id="25e79-235">13.6719</span></span> |     - | <span data-ttu-id="25e79-236">380,11 КБ</span><span class="sxs-lookup"><span data-stu-id="25e79-236">380.11 KB</span></span> |
| <span data-ttu-id="25e79-237">Asnotrackin</span><span class="sxs-lookup"><span data-stu-id="25e79-237">AsNoTracking</span></span> |       <span data-ttu-id="25e79-238">10</span><span class="sxs-lookup"><span data-stu-id="25e79-238">10</span></span> |              <span data-ttu-id="25e79-239">20</span><span class="sxs-lookup"><span data-stu-id="25e79-239">20</span></span> |   <span data-ttu-id="25e79-240">993,3 США</span><span class="sxs-lookup"><span data-stu-id="25e79-240">993.3 us</span></span> | <span data-ttu-id="25e79-241">24,04 США</span><span class="sxs-lookup"><span data-stu-id="25e79-241">24.04 us</span></span> | <span data-ttu-id="25e79-242">65,40 США</span><span class="sxs-lookup"><span data-stu-id="25e79-242">65.40 us</span></span> |   <span data-ttu-id="25e79-243">966,2 США</span><span class="sxs-lookup"><span data-stu-id="25e79-243">966.2 us</span></span> |  <span data-ttu-id="25e79-244">0,71</span><span class="sxs-lookup"><span data-stu-id="25e79-244">0.71</span></span> |    <span data-ttu-id="25e79-245">0,05</span><span class="sxs-lookup"><span data-stu-id="25e79-245">0.05</span></span> | <span data-ttu-id="25e79-246">37,1094</span><span class="sxs-lookup"><span data-stu-id="25e79-246">37.1094</span></span> |  <span data-ttu-id="25e79-247">6,8359</span><span class="sxs-lookup"><span data-stu-id="25e79-247">6.8359</span></span> |     - | <span data-ttu-id="25e79-248">232,89 КБ</span><span class="sxs-lookup"><span data-stu-id="25e79-248">232.89 KB</span></span> |

<span data-ttu-id="25e79-249">Наконец, можно выполнять обновления без дополнительных затрат на отслеживание изменений, используя неотслеживаемый запрос, а затем присоединяя возвращенный экземпляр к контексту, указывая, какие изменения следует выполнить.</span><span class="sxs-lookup"><span data-stu-id="25e79-249">Finally, it is possible to perform updates without the overhead of change tracking, by utilizing a no-tracking query and then attaching the returned instance to the context, specifying which changes are to be made.</span></span> <span data-ttu-id="25e79-250">Это позволяет переносить нагрузку по отслеживанию изменений от EF к пользователю, и ее следует выполнять только в том случае, если издержки на отслеживание изменений показаны как неприемлемые с помощью профилирования или тестирования производительности.</span><span class="sxs-lookup"><span data-stu-id="25e79-250">This transfers the burden of change tracking from EF to the user, and should only be attempted if the change tracking overhead has been shown to be unacceptable via profiling or benchmarking.</span></span>

## <a name="using-raw-sql"></a><span data-ttu-id="25e79-251">Использование необработанного SQL</span><span class="sxs-lookup"><span data-stu-id="25e79-251">Using raw SQL</span></span>

<span data-ttu-id="25e79-252">В некоторых случаях для запроса существует более оптимизированный SQL, который не создается в EF.</span><span class="sxs-lookup"><span data-stu-id="25e79-252">In some cases, more optimized SQL exists for your query, which EF does not generate.</span></span> <span data-ttu-id="25e79-253">Это может произойти, если конструкция SQL является расширением, характерным для вашей базы данных, которое не поддерживается, или просто потому, что EF не преобразует ее в эту базу.</span><span class="sxs-lookup"><span data-stu-id="25e79-253">This can happen when the SQL construct is an extension specific to your database that's unsupported, or simply because EF does not translate to it yet.</span></span> <span data-ttu-id="25e79-254">В таких случаях написание кода SQL вручную может обеспечить значительное повышение производительности, и EF поддерживает несколько способов сделать это.</span><span class="sxs-lookup"><span data-stu-id="25e79-254">In these cases, writing SQL by hand can provide a substantial performance boost, and EF supports several ways to do this.</span></span>

* <span data-ttu-id="25e79-255">Используйте необработанный SQL [непосредственно в запросе](xref:core/querying/raw-sql), например с помощью <xref:Microsoft.EntityFrameworkCore.RelationalQueryableExtensions.FromSqlRaw%2A> .</span><span class="sxs-lookup"><span data-stu-id="25e79-255">Use raw SQL [directly in your query](xref:core/querying/raw-sql), e.g. via <xref:Microsoft.EntityFrameworkCore.RelationalQueryableExtensions.FromSqlRaw%2A>.</span></span> <span data-ttu-id="25e79-256">EF даже позволяет создавать необработанные запросы SQL с помощью регулярных запросов LINQ, что позволяет выразить только часть запроса в необработанном SQL.</span><span class="sxs-lookup"><span data-stu-id="25e79-256">EF even lets you compose over the raw SQL with regular LINQ queries, allowing you to express only a part of the query in raw SQL.</span></span> <span data-ttu-id="25e79-257">Это хороший способ, когда необработанный SQL нужно использовать только в одном запросе в базе кода.</span><span class="sxs-lookup"><span data-stu-id="25e79-257">This is a good technique when the raw SQL only needs to be used in a single query in your codebase.</span></span>
* <span data-ttu-id="25e79-258">Определите [определяемую пользователем функцию](xref:core/querying/database-functions) (UDF), а затем вызовите ее из запросов.</span><span class="sxs-lookup"><span data-stu-id="25e79-258">Define a [user-defined function](xref:core/querying/database-functions) (UDF), and then call that from your queries.</span></span> <span data-ttu-id="25e79-259">Обратите внимание, что, начиная с 5,0, EF позволяет функциям UDF возвращать полные результирующие наборы — они известны как функции с табличным значением (возвращающие табличное), а также допускают сопоставление с `DbSet` функцией, делая ее так же, как и с другой таблицей.</span><span class="sxs-lookup"><span data-stu-id="25e79-259">Note that since 5.0, EF allows UDFs to return full resultsets - these are known as table-valued functions (TVFs) - and also allows mapping a `DbSet` to a function, making it look just like just another table.</span></span>
* <span data-ttu-id="25e79-260">Определите представление базы данных и запрос из него в запросах.</span><span class="sxs-lookup"><span data-stu-id="25e79-260">Define a database view and query from it in your queries.</span></span> <span data-ttu-id="25e79-261">Обратите внимание, что в отличие от функций, представления не могут принимать параметры.</span><span class="sxs-lookup"><span data-stu-id="25e79-261">Note that unlike functions, views cannot accept parameters.</span></span>

> [!NOTE]
> <span data-ttu-id="25e79-262">Необработанный SQL, как правило, следует использовать в качестве последнего средства, убедившись, что EF не может создать нужный SQL, и когда производительность достаточно важна для того, чтобы заданный запрос был оправдан.</span><span class="sxs-lookup"><span data-stu-id="25e79-262">Raw SQL should generally be used as a last resort, after making sure that EF can't generate the SQL you want, and when performance is important enough for the given query to justify it.</span></span> <span data-ttu-id="25e79-263">Использование необработанных SQL приносит значительные недостатки в обслуживании.</span><span class="sxs-lookup"><span data-stu-id="25e79-263">Using raw SQL brings considerable maintenance disadvantages.</span></span>

## <a name="asynchronous-programming"></a><span data-ttu-id="25e79-264">Асинхронное программирование</span><span class="sxs-lookup"><span data-stu-id="25e79-264">Asynchronous programming</span></span>

<span data-ttu-id="25e79-265">Как правило, для масштабирования приложения важно всегда использовать асинхронные API, а не синхронные (например, <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync%2A> вместо <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> ).</span><span class="sxs-lookup"><span data-stu-id="25e79-265">As a general rule, in order for your application to be scalable, it's important to always use asynchronous APIs rather than synchronous one (e.g. <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync%2A> rather than <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A>).</span></span> <span data-ttu-id="25e79-266">Синхронные API блокируют поток на время ввода-вывода базы данных, увеличивая потребность в потоках и число переключений контекста потоков, которые должны быть выполнены.</span><span class="sxs-lookup"><span data-stu-id="25e79-266">Synchronous APIs block the thread for the duration of database I/O, increasing the need for threads and the number of thread context switches that must occur.</span></span>

<span data-ttu-id="25e79-267">Дополнительные сведения см. на странице с [асинхронным программированием](xref:core/miscellaneous/async).</span><span class="sxs-lookup"><span data-stu-id="25e79-267">For more information, see the page on [async programming](xref:core/miscellaneous/async).</span></span>

> [!WARNING]
> <span data-ttu-id="25e79-268">Старайтесь не смешивать синхронный и асинхронный код в одном приложении — очень просто случайно запустить нехватку недостаточной работы пула потоков.</span><span class="sxs-lookup"><span data-stu-id="25e79-268">Avoid mixing synchronous and asynchronous code in the same application - it's very easy to inadvertently trigger subtle thread-pool starvation issues.</span></span>
