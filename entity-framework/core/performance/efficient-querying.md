---
title: Эффективные запросы — EF Core
description: Обзор производительности для эффективного выполнения запросов с помощью Entity Framework Core
author: roji
ms.date: 12/1/2020
uid: core/performance/efficient-querying
ms.openlocfilehash: e945a1e0f734d62ce8948904bcbe819455fcbefa
ms.sourcegitcommit: 032a1767d7a6e42052a005f660b80372c6521e7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/12/2021
ms.locfileid: "98128489"
---
# <a name="efficient-querying"></a>Эффективные запросы

Эффективный запрос — это обширная тема, охватывающая темы в виде индексов, связанных стратегий загрузки сущностей и многих других. В этом разделе подробно описаны некоторые распространенные темы, позволяющие ускорить выполнение запросов, а обычно возникают ошибки, возникающие у пользователей.

## <a name="use-indexes-properly"></a>Правильно использовать индексы

Основной фактор, определяющий, выполняется ли запрос быстро или нет, — будет ли он правильно использовать индексы там, где это уместно: базы данных обычно используются для хранения больших объемов данных, а запросы, которые проходят по всей таблице, обычно являются источником серьезных проблем с производительностью. Проблемы с индексированием легко выявить, поскольку это не просто очевидно, будет ли заданный запрос использовать индекс. Пример:

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#Indexes)]

Хорошим способом выявления проблем с индексацией является то, что сначала следует определить, что запрос работает очень быстро, а затем изучить его план запроса с помощью избранного средства базы данных. Дополнительные сведения о том, как это сделать, см. на странице [Диагностика производительности](xref:core/performance/performance-diagnosis) . План запроса показывает, проходит ли запрос всю таблицу или использует индекс.

Как правило, не существует специальных знаний EF для использования индексов или диагностики проблем с производительностью. Общие базы данных, связанные с индексами, точно так же важны для приложений EF, как и приложения, не использующие EF. Ниже приведены некоторые общие рекомендации, которые следует учитывать при использовании индексов.

* Хотя индексы ускоряют запросы, они также замедляют работу обновлений, так как они нуждаются в актуальном состоянии. Избегайте определения ненужных индексов и рассмотрите возможность использования [фильтров индексов](xref:core/modeling/indexes#index-filter) для ограничения индекса подмножеством строк, тем самым уменьшая издержки.
* Составные индексы могут ускорить запросы, которые фильтруются по нескольким столбцам, но они также могут ускорить запросы, которые не фильтруют по всем столбцам индекса, в зависимости от порядка сортировки. Например, индекс в столбцах A и B ускоряет фильтрацию запросов по A и B, а также к запросам, которые фильтруются только по, но не ускоряют фильтрацию запросов только по B.
* Если запрос фильтрует по выражению для столбца (например `price / 2` ,), то простой индекс использовать нельзя. Однако можно определить [сохраненный материализованный столбец](xref:core/modeling/generated-properties#computed-columns) для выражения и создать для него индекс. Некоторые базы данных также поддерживают индексы выражений, которые можно напрямую использовать для ускорения фильтрации запросов по любому выражению.
* Различные базы данных позволяют настроить индексы различными способами, и во многих случаях EF Core поставщики предоставляют их через интерфейс API Fluent. Например, поставщик SQL Server позволяет указать, является ли индекс [кластеризованным](xref:core/providers/sql-server/indexes#clustering), или задать его [Коэффициент заполнения](xref:core/providers/sql-server/indexes#fill-factor). Дополнительные сведения см. в документации поставщика.

## <a name="project-only-properties-you-need"></a>Нужные свойства только для проекта

EF Core упрощает запрос экземпляров сущностей, а затем использует эти экземпляры в коде. Однако запросы к экземплярам сущностей часто запрашивают больше данных, чем требуется для базы данных. Рассмотрим следующий пример.

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#ProjectEntities)]

Хотя для этого кода действительно требуется только свойство блога `Url` , вся сущность блога извлекается, а ненужные столбцы передаются из базы данных:

```sql
SELECT [b].[BlogId], [b].[CreationDate], [b].[Name], [b].[Rating], [b].[Url]
FROM [Blogs] AS [b]
```

Это можно оптимизировать с помощью `Select` , чтобы сообщить EF, какие столбцы следует проецировать:

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#ProjectSingleProperty)]

Результирующий SQL извлекает только необходимые столбцы:

```csharp
SELECT [b].[Url]
FROM [Blogs] AS [b]
```

Если необходимо проецировать несколько столбцов, можно проецировать проект в анонимный тип C# с нужными свойствами.

Обратите внимание, что этот метод очень полезен для запросов только для чтения, но при необходимости *обновления* изученных блогов он становится более сложным, так как отслеживание изменений EF работает только с экземплярами сущностей. Вы можете выполнять обновления, не загружая сущности целиком, подключив измененный экземпляр блога и указав EF, какие свойства изменились, но это более сложная методика, которая может быть нецелесообразна.

## <a name="limit-the-resultset-size"></a>Ограничить размер результирующего набора

По умолчанию запрос возвращает все строки, соответствующие его фильтрам:

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#NoLimit)]

Так как количество возвращаемых строк зависит от фактических данных в базе данных, невозможно выяснить, какой объем данных будет загружен из базы данных, сколько памяти будет выдаваться в результате и сколько дополнительной нагрузки будет создаваться при обработке этих результатов (например, путем отправки их в пользовательский браузер по сети). По крайней мере, тестовые базы данных часто содержат небольшие данные, так что все работает хорошо при тестировании, но проблемы с производительностью внезапно появляются, когда запрос начинает выполняться на реальных данных и возвращается много строк.

Как следствие, обычно стоит подумать о том, чтобы ограничить количество результатов:

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#Limit25)]

Как минимум, Пользовательский интерфейс может отображать сообщение о том, что в базе данных могут существовать дополнительные строки (и разрешать их извлечение другим способом). Полнофункциональное решение будет реализовывать *разбиение* на страницы, когда пользовательский интерфейс отображает определенное количество строк за раз и позволяет пользователям перейти на следующую страницу по мере необходимости. как правило, объединяет <xref:System.Linq.Enumerable.Take%2A> <xref:System.Linq.Enumerable.Skip%2A> операторы и для выбора определенного диапазона в результирующем наборе каждый раз.

## <a name="avoid-cartesian-explosion-when-loading-related-entities"></a>Избегайте декартового развертывания при загрузке связанных сущностей

В реляционных базах данных все связанные сущности загружаются с помощью запросов JOIN в одиночном запросе.

```sql
SELECT [b].[BlogId], [b].[OwnerId], [b].[Rating], [b].[Url], [p].[PostId], [p].[AuthorId], [p].[BlogId], [p].[Content], [p].[Rating], [p].[Title]
FROM [Blogs] AS [b]
LEFT JOIN [Post] AS [p] ON [b].[BlogId] = [p].[BlogId]
ORDER BY [b].[BlogId], [p].[PostId]
```

Если в обычном блоге есть несколько связанных записей, тогда строки для этих записей будут дублировать данные блога. Такое дублирование приводит к возникновению "картезианского взрыва" (нарушение корректности синхронизации). Чем больше связей "один ко многим" будет загружено, тем большим будет объем дублирующихся данных, что негативно повлияет на производительность приложения.

EF позволяет избежать этого воздействия с помощью "разбиения запросов", которые загружают связанные сущности через отдельные запросы. Дополнительные сведения см. [в документации по разделению и отдельным запросам](xref:core/querying/single-split-queries).

> [!NOTE]
> Текущая реализация [разделенных запросов](xref:core/querying/single-split-queries) выполняет циклическое выполнение для каждого запроса. Мы планируем улучшить это в будущем и выполнить все запросы за один цикл.

## <a name="load-related-entities-eagerly-when-possible"></a>Загружает связанные сущности по возможности.

Перед продолжением работы с этим разделом рекомендуется прочитать [выделенную страницу по связанным сущностям](xref:core/querying/related-data) .

При работе со связанными сущностями обычно известно, что нам нужно загрузить. типичный пример — загрузка определенного набора блогов вместе со всеми записями. В этих сценариях всегда лучше использовать [безотлагательную загрузку](xref:core/querying/related-data/eager), чтобы EF мог извлечь все необходимые данные за один цикл. Функция [фильтрации включенных](xref:core/querying/related-data/eager#filtered-include) элементов, введенная в EF Core 5,0, также позволяет ограничить связанные сущности, которые вы хотите загрузить, сохранив процесс загрузки и, следовательно, выполнимо в одном цикле.

[!code-csharp[Main](../../../samples/core/Querying/RelatedData/Program.cs#FilteredInclude)]

В других сценариях мы можем не знать, какая связанная сущность потребуется, прежде чем получить основную сущность. Например, при загрузке какого-либо блога может потребоваться обратиться к другому источнику данных, возможно, к веб-службе, чтобы узнать, Интересует ли он записи блога. В таких случаях [явная](xref:core/querying/related-data/explicit) или [Отложенная](xref:core/querying/related-data/lazy) загрузка может использоваться для выборки связанных сущностей по отдельности и заполнения навигации по записям блога. Обратите внимание, что поскольку эти методы не готовы, они нуждаются в дополнительных обращениях к базе данных, которая является источником замедления. в зависимости от конкретного сценария может оказаться более эффективным, чтобы всегда загружать все записи, а не выполнять дополнительные обращения и выборочно получать только нужные вам записи.

### <a name="beware-of-lazy-loading"></a>Будьте осторожны с отложенной загрузкой

[Отложенная загрузка](xref:core/querying/related-data/lazy) часто кажется очень полезным способом написания логики базы данных, так как EF Core автоматически загружает связанные сущности из базы данных, так как к ним обращается ваш код. Это позволяет избежать загрузки связанных сущностей, которые не нужны (например, [явная загрузка](xref:core/querying/related-data/explicit)), и, в противном случае, освобождает программиста от необходимости обращаться к связанным сущностям полностью. Однако отложенная загрузка особенно уязвима для создания ненужных дополнительных обращений, которые могут замедлять работу приложения.

Рассмотрим следующий пример.

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#NPlusOne)]

Это, казалось бы, безобидным часть кода, которая проходит по всем блогам и их записям, распечатяя их. Включение [ведения журнала инструкции](xref:core/logging-events-diagnostics/index) EF Core открывает следующее:

```console
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [b].[BlogId], [b].[Rating], [b].[Url]
      FROM [Blogs] AS [b]
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (5ms) [Parameters=[@__p_0='1'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[@__p_0='2'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[@__p_0='3'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0

... and so on
```

В чем причина? Почему все эти запросы отправляются для простых циклов выше? При отложенной загрузке записи блога загружаются только при обращении к свойству posts (отложенно). в результате каждая итерация во внутреннем операторе foreach активирует дополнительный запрос к базе данных в отдельном цикле. В результате после первоначального запроса на загрузку всех блогов у нас будет другой запрос к *блогу*, где загружаются все записи. Это иногда называется проблемой *N + 1* и может вызвать очень значительные проблемы с производительностью.

Предполагая, что нам нужны все записи блогов, имеет смысл использовать вместо этого безотлагательную загрузку. Для выполнения загрузки можно использовать оператор [include](xref:core/querying/related-data/eager#eager-loading) , но так как нам нужны только URL-адреса блогов (и следует [загружать только те, которые необходимы](xref:core/performance/efficient-querying#project-only-properties-you-need)). Вместо этого мы будем использовать проекцию:

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#EagerlyLoadRelatedAndProject)]

Это сделает EF Core извлекать все блоги вместе с их записями в одном запросе. В некоторых случаях он также может быть полезен, чтобы избежать появления декартного развертывания с помощью [запросов Split](xref:core/querying/single-split-queries).

> [!WARNING]
> Поскольку отложенная загрузка упрощает непреднамеренное срабатывание задачи N + 1, рекомендуется избегать ее. Упреждающая или явная загрузка делает неясной в исходном коде, когда происходит цикл обработки базы данных.

## <a name="buffering-and-streaming"></a>Буферизация и потоковая передача

Буферизация означает загрузку всех результатов запроса в память, в то время как потоковая передача означает, что EF передает приложению один результат каждый раз, не содержащий весь набор результатов в памяти. В принципе, требования к памяти для запроса потоковой передачи фиксированы — они одинаковы, если запрос возвращает 1 строку или 1000; для запроса буферизации, с другой стороны, требуется больше памяти, чем больше строк. Для запросов, которые запрашивают большие результирующие наборы, это может быть важным фактором производительности.

Зависит ли буферы или потоки запросов от того, как они оцениваются:

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#BufferingAndStreaming)]

Если запросы возвращают лишь несколько результатов, вам, скорее всего, не придется беспокоиться об этом. Однако если запрос может возвращать большое количество строк, стоит подумать о потоковой передаче вместо буферизации.

> [!NOTE]
> Старайтесь не использовать <xref:System.Linq.Enumerable.ToList%2A> или, <xref:System.Linq.Enumerable.ToArray%2A> Если планируется использовать другой оператор LINQ в результате. это приведет к ненужному буферу всех результатов в памяти. Взамен рекомендуется использовать <xref:System.Linq.Enumerable.AsEnumerable%2A>.

### <a name="internal-buffering-by-ef"></a>Внутренняя буферизация EF

В некоторых ситуациях EF сам сам помещает результирующий набор в буфер, независимо от того, как будет оцениваться запрос. Это происходит в двух случаях:

* При наличии стратегии повторного выполнения. Это делается для того, чтобы убедиться, что те же результаты возвращаются, если запрос повторяется позже.
* Когда используется [запрос Split](xref:core/querying/single-split-queries) , результирующие наборы всех, кроме последнего запроса, буферизуются, если режим MARS не включен на SQL Server. Это связано с тем, что обычно невозможно одновременно использовать несколько результирующих наборов запросов.

Обратите внимание, что эта внутренняя буферизация выполняется в дополнение к любой буферизации, вызванной с помощью операторов LINQ. Например, если используется <xref:System.Linq.Enumerable.ToList%2A> для запроса и используется стратегия повторного выполнения, результирующий набор загружается в память *дважды*: один внутренне по EF и один раз в <xref:System.Linq.Enumerable.ToList%2A> .

## <a name="tracking-no-tracking-and-identity-resolution"></a>Отслеживание, отсутствие отслеживания и разрешение идентификаторов

Перед продолжением работы с этим разделом рекомендуется прочитать [выделенную страницу с отслеживанием и без отслеживания](xref:core/querying/tracking) .

EF отслеживает экземпляры сущностей по умолчанию, поэтому изменения в них обнаруживаются и сохраняются при <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> вызове метода. Еще одним результатом отслеживания запросов является то, что EF обнаруживает, что экземпляр уже загружен для ваших данных, и автоматически возвращает этот отслеживаемый экземпляр, а не возвращает новый. Это называется *разрешением идентификации*. С точки зрения производительности отслеживание изменений означает следующее:

* EF внутренне поддерживает словарь отслеживаний экземпляров. При загрузке новых данных EF проверяет словарь на предмет того, что экземпляр уже зарегистрирован для ключа этой сущности (разрешение идентификаторов). Обслуживание и Уточняющий запрос словаря занимают некоторое время при загрузке результатов запроса.
* Перед передачей загруженного экземпляра в приложение объект EF *моментальные снимки* этого экземпляра и сохраняет моментальный снимок внутренне. Когда <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> вызывается метод, экземпляр приложения сравнивается с моментальным снимком, чтобы обнаружить сохраняемые изменения. Моментальный снимок занимает больше памяти, и сам процесс значит занимает некоторое время; Иногда можно указать другое, возможно более эффективное поведение значит с помощью [компараторов значений](xref:core/modeling/value-comparers)или использовать прокси-серверы отслеживания изменений, чтобы вообще обойти процесс значит (хотя это и имеет собственный набор недостатков).

В сценариях только для чтения, в которых изменения не сохраняются обратно в базу данных, можно избежать приведенных выше заголовков, используя [Неотслеживаемые запросы](xref:core/querying/tracking#no-tracking-queries). Однако, поскольку запросы без отслеживания не выполняют разрешение идентификации, строка базы данных, на которую ссылаются несколько других загруженных строк, будет материализоваться как разные экземпляры.

Для иллюстрации Предположим, что мы загружаем большое количество записей из базы данных, а также блог, на который ссылается каждая запись. Если в 100 учитываются записи, ссылающиеся на один и тот же блог, запрос отслеживания обнаруживает это с помощью разрешения идентификаторов, а все экземпляры POST будут ссылаться на один и тот же недублированный экземпляр блога. Неотслеживаемый запрос, напротив, дублирует один и тот же блог 100 раз, и код приложения должен быть написан соответствующим образом.

Ниже приведены результаты отслеживания теста производительности и поведения без отслеживания для запроса, в котором загружаются 10 блогов с 20 записями. [Исходный код доступен здесь](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/QueryTrackingBehavior.cs), поэтому вы можете использовать его в качестве основания для собственных измерений.

|       Метод | нумблогс | нумпостсперблог |       Среднее значение |    Ошибка |   StdDev |     Median | Соотношение | ратиосд |   Gen 0 |   Gen 1 | Gen 2 | Allocated |
|------------- |--------- |---------------- |-----------:|---------:|---------:|-----------:|------:|--------:|--------:|--------:|------:|----------:|
|   астраккинг |       10 |              20 | 1 414,7 США | 27,20 США | 45,44 США | 1 405,5 США |  1.00 |    0,00 | 60,5469 | 13,6719 |     - | 380,11 КБ |
| Asnotrackin |       10 |              20 |   993,3 США | 24,04 США | 65,40 США |   966,2 США |  0,71 |    0,05 | 37,1094 |  6,8359 |     - | 232,89 КБ |

Наконец, можно выполнять обновления без дополнительных затрат на отслеживание изменений, используя неотслеживаемый запрос, а затем присоединяя возвращенный экземпляр к контексту, указывая, какие изменения следует выполнить. Это позволяет переносить нагрузку по отслеживанию изменений от EF к пользователю, и ее следует выполнять только в том случае, если издержки на отслеживание изменений показаны как неприемлемые с помощью профилирования или тестирования производительности.

## <a name="using-raw-sql"></a>Использование необработанного SQL

В некоторых случаях для запроса существует более оптимизированный SQL, который не создается в EF. Это может произойти, если конструкция SQL является расширением, характерным для вашей базы данных, которое не поддерживается, или просто потому, что EF не преобразует ее в эту базу. В таких случаях написание кода SQL вручную может обеспечить значительное повышение производительности, и EF поддерживает несколько способов сделать это.

* Используйте необработанный SQL [непосредственно в запросе](xref:core/querying/raw-sql), например с помощью <xref:Microsoft.EntityFrameworkCore.RelationalQueryableExtensions.FromSqlRaw%2A> . EF даже позволяет создавать необработанные запросы SQL с помощью регулярных запросов LINQ, что позволяет выразить только часть запроса в необработанном SQL. Это хороший способ, когда необработанный SQL нужно использовать только в одном запросе в базе кода.
* Определите [определяемую пользователем функцию](xref:core/querying/database-functions) (UDF), а затем вызовите ее из запросов. Обратите внимание, что, начиная с 5,0, EF позволяет функциям UDF возвращать полные результирующие наборы — они известны как функции с табличным значением (возвращающие табличное), а также допускают сопоставление с `DbSet` функцией, делая ее так же, как и с другой таблицей.
* Определите представление базы данных и запрос из него в запросах. Обратите внимание, что в отличие от функций, представления не могут принимать параметры.

> [!NOTE]
> Необработанный SQL, как правило, следует использовать в качестве последнего средства, убедившись, что EF не может создать нужный SQL, и когда производительность достаточно важна для того, чтобы заданный запрос был оправдан. Использование необработанных SQL приносит значительные недостатки в обслуживании.

## <a name="asynchronous-programming"></a>Асинхронное программирование

Как правило, для масштабирования приложения важно всегда использовать асинхронные API, а не синхронные (например, <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync%2A> вместо <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> ). Синхронные API блокируют поток на время ввода-вывода базы данных, увеличивая потребность в потоках и число переключений контекста потоков, которые должны быть выполнены.

Дополнительные сведения см. на странице с [асинхронным программированием](xref:core/miscellaneous/async).

> [!WARNING]
> Старайтесь не смешивать синхронный и асинхронный код в одном приложении — очень просто случайно запустить нехватку недостаточной работы пула потоков.

## <a name="additional-resources"></a>Дополнительные ресурсы

Рекомендации по сравнению значений, допускающих значения NULL, см. в [разделе "производительность](xref:core/querying/null-comparisons#writing-performant-queries) " на странице документации по сравнению со значением NULL.
