---
title: EF Core — общие сведения о производительности
description: Руководство по обеспечению оптимальной производительности для эффективного использования Entity Framework Core
author: roji
ms.date: 12/1/2020
uid: core/miscellaneous/performance/index
ms.openlocfilehash: 14400d81ea3c93e2ebf40e8e585a457abf31478f
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657690"
---
# <a name="introduction-to-performance"></a><span data-ttu-id="ab023-103">Общие сведения о производительности</span><span class="sxs-lookup"><span data-stu-id="ab023-103">Introduction to Performance</span></span>

<span data-ttu-id="ab023-104">Производительность базы данных — это обширная и сложная тема, охватывающая весь стек компонентов: базу данных, сетевые подключения, драйвер базы данных и уровни доступа к данным, такие как EF Core.</span><span class="sxs-lookup"><span data-stu-id="ab023-104">Database performance is a vast and complex topic, spanning an entire stack of components: the database, networking, the database driver, and data access layers such as EF Core.</span></span> <span data-ttu-id="ab023-105">Хотя слои высокого уровня и технологии ORM, такие как EF Core значительно упрощают разработку приложений и повышают удобство сопровождения, они могут быть непрозрачными, скрывая внутренние данные, которые критически важны с точки зрения производительности, например, выполняемые SQL-запросы.</span><span class="sxs-lookup"><span data-stu-id="ab023-105">While high-level layers and O/RMs such as EF Core considerably simplify application development and improve maintainability, they can sometimes be opaque, hiding performance-critical internal details such as the SQL being executed.</span></span> <span data-ttu-id="ab023-106">В этом разделе приводятся общие сведения о том, как обеспечить высокую производительность с помощью EF Core и как избежать распространенных ошибок, которые могут снизить производительность приложения.</span><span class="sxs-lookup"><span data-stu-id="ab023-106">This section attempts to provide an overview of how to achieve good performance with EF Core, and how to avoid common pitfalls which can degrade application performance.</span></span>

## <a name="identify-bottlenecks-and-measure-measure-measure"></a><span data-ttu-id="ab023-107">Выявление узких мест и принятие мер для их устранения</span><span class="sxs-lookup"><span data-stu-id="ab023-107">Identify bottlenecks and measure, measure, measure</span></span>

<span data-ttu-id="ab023-108">Как и в случае с производительностью, важно не стремиться выполнять оптимизацию без наличия данных, свидетельствующих о проблеме; как однажды заметил великий Дональд Кнут, "Преждевременная оптимизация — корень всех зол".</span><span class="sxs-lookup"><span data-stu-id="ab023-108">As always with performance, it's important not to rush into optimization without data showing a problem; as the great Donald Knuth once said, "Premature optimization is the root of all evil".</span></span> <span data-ttu-id="ab023-109">В разделе [Диагностика производительности](xref:core/performance/performance-diagnosis) обсуждаются различные способы определения того, на что именно приложение тратит время в логике работы с базой данных и как именно выявить конкретные проблемные области.</span><span class="sxs-lookup"><span data-stu-id="ab023-109">The [performance diagnosis](xref:core/performance/performance-diagnosis) section discusses various ways to understand where your application is spending time in database logic, and how to pinpoint specific problematic areas.</span></span> <span data-ttu-id="ab023-110">После выявления запроса, который выполняется длительное время, можно предложить различные варианты решения проблемы. Есть ли в вашей базе данных индекс?</span><span class="sxs-lookup"><span data-stu-id="ab023-110">Once a slow query has been identified, solutions can be considered: is your database missing an index?</span></span> <span data-ttu-id="ab023-111">Следует ли попробовать другие шаблоны запросов?</span><span class="sxs-lookup"><span data-stu-id="ab023-111">Should you try out other querying patterns?</span></span>

<span data-ttu-id="ab023-112">Всегда проверяйте производительность кода и возможные альтернативы самостоятельно. В разделе "Диагностика производительности" есть пример тестирования производительности с использованием BenchmarkDotNet, который можно использовать в качестве шаблона для собственных тестов производительности.</span><span class="sxs-lookup"><span data-stu-id="ab023-112">Always benchmark your code and possible alternatives yourself - the performance diagnosis section contains a sample benchmark with BenchmarkDotNet, which you can use as a template for your own benchmarks.</span></span> <span data-ttu-id="ab023-113">Не думайте, что универсальные и общедоступные тесты производительности могут быть применены к вашему решению как есть; на выбор оптимального решения могут значительно влиять самые разные факторы, такие как задержка базы данных, сложность запросов и фактические объемы данных в таблицах.</span><span class="sxs-lookup"><span data-stu-id="ab023-113">Don't assume that general, public benchmarks apply as-is to your specific use-case; a variety of factors such as database latency, query complexity and actual data amounts in your tables can have a profound effect on which solution is best.</span></span> <span data-ttu-id="ab023-114">Например, многие общедоступные тесты производительности выполняются в идеальных сетевых условиях, в которых задержка базы данных практически равна нулю, и с очень легкими запросами, которые не требуют почти никакой обработки (или дисковых операций ввода-вывода) на стороне базы данных.</span><span class="sxs-lookup"><span data-stu-id="ab023-114">For example, many public benchmarks are carried out in ideal networking conditions, where latency to the database is almost zero, and with extremely light queries which hardly require any processing (or disk I/O) on the database side.</span></span> <span data-ttu-id="ab023-115">Несмотря на то, что такие тесты производительности полезны для сравнения издержек во время выполнения для различных уровней доступа к данным, различия, которые позволяют выявить эти тесты, обычно незаметны в реальных приложениях, в которых на базу данных ложится настоящая нагрузка, а задержка базы данных представляет собой значительный фактор, влияющий на производительность.</span><span class="sxs-lookup"><span data-stu-id="ab023-115">While these are valuable for comparing the runtime overheads of different data access layers, the differences they reveal usually prove to be negligible in a real-world application, where the database performs actual work and latency to the database is a significant perf factor.</span></span>

## <a name="aspects-of-data-access-performance"></a><span data-ttu-id="ab023-116">Аспекты производительности при доступе к данным</span><span class="sxs-lookup"><span data-stu-id="ab023-116">Aspects of data access performance</span></span>

<span data-ttu-id="ab023-117">Общую производительность при доступе к данным можно разделить на следующие обширные категории:</span><span class="sxs-lookup"><span data-stu-id="ab023-117">Overall data access performance can be broken down into the following broad categories:</span></span>

* <span data-ttu-id="ab023-118">**Чистая производительность базы данных**.</span><span class="sxs-lookup"><span data-stu-id="ab023-118">**Pure database performance**.</span></span> <span data-ttu-id="ab023-119">В реляционной базе данных EF преобразует запросы LINQ приложения в инструкции SQL, выполняемые базой данных; эти инструкции SQL могут выполняться более или менее эффективно.</span><span class="sxs-lookup"><span data-stu-id="ab023-119">With relational database, EF translates the application's LINQ queries into the SQL statements getting executed by the database; these SQL statements themselves can run more or less efficiently.</span></span> <span data-ttu-id="ab023-120">Нужный индекс в нужном месте может существенно увеличить производительность при выполнении инструкций SQL, а перезапись запроса LINQ может привести к улучшению SQL-запроса, создаваемого EF.</span><span class="sxs-lookup"><span data-stu-id="ab023-120">The right index in the right place can make a world of difference in SQL performance, or rewriting your LINQ query may make EF generate a better SQL query.</span></span>
* <span data-ttu-id="ab023-121">**Передача данных по сети**.</span><span class="sxs-lookup"><span data-stu-id="ab023-121">**Network data transfer**.</span></span> <span data-ttu-id="ab023-122">Как и в случае любой сетевой системы, важно ограничить объем данных, передаваемых по сети.</span><span class="sxs-lookup"><span data-stu-id="ab023-122">As with any networking system, it's important to limit the amount of data going back and forth on the wire.</span></span> <span data-ttu-id="ab023-123">Ограничение объема данных означает, что вы не только отправляете и загружаете только те данные, которые действительно необходимы, но и избегаете так называемого эффекта "картезианского взрыва" при загрузке связанных сущностей.</span><span class="sxs-lookup"><span data-stu-id="ab023-123">This covers making sure that you only send and load data which you're actually going to need, but also avoiding the so-called "cartesian explosion" effect when loading related entities.</span></span>
* <span data-ttu-id="ab023-124">**Сетевые циклы**.</span><span class="sxs-lookup"><span data-stu-id="ab023-124">**Network roundtrips**.</span></span> <span data-ttu-id="ab023-125">Помимо объема данных, передаваемых по сети, свой вклад вносят и сетевые циклы, так как время, необходимое для выполнения запроса в базе данных, может быть увеличено на время, требуемое для передачи пакетов между приложением и базой данных.</span><span class="sxs-lookup"><span data-stu-id="ab023-125">Beyond the amount of data going back and forth, the network roundtrips, since the time taken for a query to execute in the database can be dwarfed by the time packets travel back and forth between your application and your database.</span></span> <span data-ttu-id="ab023-126">Дополнительные затраты на сетевые циклы в значительной степени зависят от среды; чем дальше расположен сервер базы данных, тем выше задержка и тем больший вклад вносит каждый цикл.</span><span class="sxs-lookup"><span data-stu-id="ab023-126">Roundtrip overhead heavily depends on your environment; the further away your database server is, the high the latency and the costlier each roundtrip.</span></span> <span data-ttu-id="ab023-127">С появлением облака приложения все чаще находятся далеко от базы данных, и "общительные" приложения, которые выполняют слишком много циклов, испытывают снижение производительности.</span><span class="sxs-lookup"><span data-stu-id="ab023-127">With the advent of the cloud, applications increasingly find themselves further away from the database, and "chatty" applications which perform too many roundtrips experience degraded performance.</span></span> <span data-ttu-id="ab023-128">Таким образом, важно понимать, когда именно ваше приложение обращается к базе данных, сколько обращений выполняется и можно ли уменьшить это число.</span><span class="sxs-lookup"><span data-stu-id="ab023-128">Therefore, it's important to understand exactly when your application contacts the database, how many roundtrips it performs, and whether that number can be minimized them.</span></span>
* <span data-ttu-id="ab023-129">**Накладные расходы среды выполнения EF**.</span><span class="sxs-lookup"><span data-stu-id="ab023-129">**EF runtime overhead**.</span></span> <span data-ttu-id="ab023-130">Наконец, сама EF добавляет некоторые затраты времени выполнения к операциям базы данных: EF необходимо компилировать запросы из LINQ в SQL (хотя такая компиляция обычно выполняется только один раз), некоторые задержки возникают из-за отслеживания изменений (его можно отключить) и т. д. На практике накладные расходы EF для реальных приложений, скорее всего, будут незначительными в большинстве случаев, так как время выполнения запроса в базе данных и задержка сети оказывают основное влияние на суммарное время. При этом важно понимать, какие варианты действий у вас есть и как избежать некоторых ловушек.</span><span class="sxs-lookup"><span data-stu-id="ab023-130">Finally, EF itself adds some runtime overhead to database operations: EF needs to compile your queries from LINQ to SQL (although that should normally be done only once), change tracking adds some overhead (but can be disabled), etc. In practice, the EF overhead for real-world applications is likely to be negligible in most cases, as query execution time in the database and network latency dominate the total time; but it's important to understand what your options are and how to avoid some pitfalls.</span></span>

## <a name="know-whats-happening-under-the-hood"></a><span data-ttu-id="ab023-131">Узнайте, что происходит внутри</span><span class="sxs-lookup"><span data-stu-id="ab023-131">Know what's happening under the hood</span></span>

<span data-ttu-id="ab023-132">EF позволяет разработчикам сосредоточиться на бизнес-логике путем создания SQL-запросов, материализации результатов и выполнения других задач.</span><span class="sxs-lookup"><span data-stu-id="ab023-132">EF allows developers to concentrate on business logic by generating SQL, materializing results, and performing other tasks.</span></span> <span data-ttu-id="ab023-133">Как и любой другой слой или абстракция, EF также позволяет скрыть то, что происходит внутри, например, выполнение фактических SQL-запросов.</span><span class="sxs-lookup"><span data-stu-id="ab023-133">Like any layer or abstraction, it also tends to hide what's happening under-the-hood, such as the actual SQL queries being executed.</span></span> <span data-ttu-id="ab023-134">Производительность не обязательно является критически важным аспектом каждого существующего приложения, но в приложениях, в которых она имеет значение, крайне важно, чтобы разработчик понимал, что именно делает EF, и проверял получающиеся SQL-запросы, соблюдал циклы, чтобы не допустить появления проблемы N+1 и т. д.</span><span class="sxs-lookup"><span data-stu-id="ab023-134">Performance isn't necessarily a critical aspect of every application out there, but in applications where it is, it is vital that the developer understand what EF is doing for them: inspect outgoing SQL queries, follow roundtrips to make sure the N+1 problem isn't occurring, etc.</span></span>

## <a name="cache-outside-the-database"></a><span data-ttu-id="ab023-135">Кэш за пределами базы данных</span><span class="sxs-lookup"><span data-stu-id="ab023-135">Cache outside the database</span></span>

<span data-ttu-id="ab023-136">Наконец, самый эффективный способ взаимодействия с базой данных — не взаимодействовать с ней совсем.</span><span class="sxs-lookup"><span data-stu-id="ab023-136">Finally, the most efficient way to interact with a database, is to not interact with it at all.</span></span> <span data-ttu-id="ab023-137">Другими словами, если доступ к базе данных является узким местом производительности в приложении, может быть целесообразно кэшировать определенные результаты за пределами базы данных, чтобы максимально сократить время выполнения запросов.</span><span class="sxs-lookup"><span data-stu-id="ab023-137">In other words, if database access shows up as a performance bottleneck in your application, it may be worthwhile to cache certain results outside of the database, so as to minimize requests.</span></span> <span data-ttu-id="ab023-138">Хотя кэширование увеличивает сложность, это особенно важный компонент любого масштабируемого приложения: хотя уровень приложения можно легко масштабировать путем добавления дополнительных серверов для обработки повышенной нагрузки, масштабирование уровня базы данных обычно осуществляется намного сложнее.</span><span class="sxs-lookup"><span data-stu-id="ab023-138">Although caching adds complexity, it is an especially crucial part of any scalable application: while the application tier can be easy scaled by adding additional servers to handle increased load, scaling the database tier is usually far more complicated.</span></span>
