---
title: Реконструирование — EF Core
author: bricelam
ms.author: bricelam
ms.date: 11/13/2018
ms.assetid: 6263EF7D-4989-42E6-BDEE-45DA770342FB
uid: core/managing-schemas/scaffolding
ms.openlocfilehash: 2422e7455dc4ef52f0a9d3bdaebfa02f62e6d50f
ms.sourcegitcommit: ebfd3382fc583bc90f0da58e63d6e3382b30aa22
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/25/2020
ms.locfileid: "85370605"
---
# <a name="reverse-engineering"></a> Реконструирование

Реконструирование — это процесс формирования шаблонов классов типов сущностей и класса DbContext на основе схемы базы данных. Его можно выполнить с помощью `Scaffold-DbContext` команды EF Core инструментов консоли диспетчера пакетов или `dotnet ef dbcontext scaffold` команды интерфейса командной строки (CLI) .NET.

## <a name="installing"></a>Установка

Перед реконструированием необходимо установить либо [средства PMC](xref:core/miscellaneous/cli/powershell) (только Visual Studio), либо [средства CLI](xref:core/miscellaneous/cli/dotnet). Дополнительные сведения см. в ссылках.

Вам также потребуется установить соответствующий [поставщик базы данных](xref:core/providers/index) для схемы базы данных, которую необходимо реконструировать.

## <a name="connection-string"></a>Строка подключения

Первым аргументом команды является строка подключения к базе данных. Эти средства будут использовать эту строку соединения для чтения схемы базы данных.

Способ заключения и экранирования строки подключения зависит от того, какая оболочка используется для выполнения команды. Дополнительные сведения см. в документации по оболочке. Например, PowerShell требует экранирования `$` символа, но не `\` .

### <a name="net-core-cli"></a>[Интерфейс командной строки .NET Core](#tab/dotnet-core-cli)

```dotnetcli
dotnet ef dbcontext scaffold "Data Source=(localdb)\MSSQLLocalDB;Initial Catalog=Chinook" Microsoft.EntityFrameworkCore.SqlServer
```

### <a name="visual-studio"></a>[Visual Studio](#tab/vs)

``` powershell
Scaffold-DbContext 'Data Source=(localdb)\MSSQLLocalDB;Initial Catalog=Chinook' Microsoft.EntityFrameworkCore.SqlServer
```

***

### <a name="configuration-and-user-secrets"></a>Конфигурация и секреты пользователя

При наличии проекта ASP.NET Core можно использовать `Name=<connection-string>` синтаксис для считывания строки подключения из конфигурации.

Это хорошо работает со [средством диспетчера секретов](https://docs.microsoft.com/aspnet/core/security/app-secrets#secret-manager) , чтобы пароль базы данных не оставался в своей базе кода.

```dotnetcli
dotnet user-secrets set ConnectionStrings.Chinook "Data Source=(localdb)\MSSQLLocalDB;Initial Catalog=Chinook"
dotnet ef dbcontext scaffold Name=Chinook Microsoft.EntityFrameworkCore.SqlServer
```

## <a name="provider-name"></a>Имя поставщика

Вторым аргументом является имя поставщика. Имя поставщика обычно совпадает с именем пакета NuGet поставщика.

## <a name="specifying-tables"></a>Указание таблиц

По умолчанию все таблицы в схеме базы данных реконструированы в типы сущностей. Можно ограничить, какие таблицы реконструировать реконструирование, указав схемы и таблицы.

### <a name="net-core-cli"></a>[Интерфейс командной строки .NET Core](#tab/dotnet-core-cli)

`--schema`Параметр может использоваться для включения каждой таблицы в схему, в то время как `--table` может использоваться для включения конкретных таблиц.

Чтобы включить несколько таблиц, укажите параметр несколько раз:

```dotnetcli
dotnet ef dbcontext scaffold ... --table Artist --table Album
```

### <a name="visual-studio"></a>[Visual Studio](#tab/vs)

`-Schemas`Параметр может использоваться для включения каждой таблицы в схему, в то время как `-Tables` может использоваться для включения конкретных таблиц.

Чтобы включить несколько таблиц, используйте массив:

``` powershell
Scaffold-DbContext ... -Tables Artist, Album
```

***

## <a name="preserving-names"></a>Сохранение имен

Имена таблиц и столбцов устраняются, чтобы лучше соответствовать соглашениям об именовании .NET для типов и свойств по умолчанию. При указании параметра `-UseDatabaseNames` в PMC или `--use-database-names` в .NET Core CLI будет отключено это поведение по мере возможности. Недопустимые идентификаторы .NET по-прежнему будут исправлены, а синтезированные имена, такие как свойства навигации, по-прежнему будут соответствовать соглашениям об именовании .NET.

## <a name="fluent-api-or-data-annotations"></a>API Fluent или заметки к данным

Типы сущностей настраиваются с помощью API Fluent по умолчанию. Укажите `-DataAnnotations` вместо них (PMC) или `--data-annotations` (.NET Core CLI) использование заметок к данным, если это возможно.

Например, с помощью API Fluent будет сформирован шаблон:

``` csharp
entity.Property(e => e.Title)
    .IsRequired()
    .HasMaxLength(160);
```

При использовании заметок к данным будет сформировано следующее:

``` csharp
[Required]
[StringLength(160)]
public string Title { get; set; }
```

## <a name="dbcontext-name"></a>Имя DbContext

Шаблонное имя класса DbContext по умолчанию будет именем базы данных с суффиксом *context* . Чтобы указать другую, используйте `-Context` в PMC и `--context` в .NET Core CLI.

## <a name="directories-and-namespaces"></a>Каталоги и пространства имен

Классы сущностей и класс DbContext обрабатываются в корневом каталоге проекта и используют пространство имен по умолчанию проекта.

### <a name="net-core-cli"></a>[Интерфейс командной строки .NET Core](#tab/dotnet-core-cli)

Можно указать каталог, в котором разрабатываются классы с помощью `--output-dir` , и `--context-dir` можно использовать для формирования шаблона класса DbContext в отдельный каталог из классов типов сущностей:

```dotnetcli
dotnet ef dbcontext scaffold ... --context-dir Data --output-dir Models
```

По умолчанию пространством имен будет корневое пространство имен и имена всех подкаталогов в корневом каталоге проекта. Однако из Ефкоре 5,0 можно переопределить пространство имен для всех выходных классов с помощью `--namespace` . Также можно переопределить пространство имен только для класса DbContext, используя `--context-namespace` :

```dotnetcli
dotnet ef dbcontext scaffold ... --namespace Your.Namespace --context-namespace Your.DbContext.Namespace
```

### <a name="visual-studio"></a>[Visual Studio](#tab/vs)

Можно указать каталог, в котором разрабатываются классы с помощью `-OutputDir` , и `-ContextDir` можно использовать для формирования шаблона класса DbContext в отдельный каталог из классов типов сущностей:

``` powershell
Scaffold-DbContext ... -ContextDir Data -OutputDir Models
```

По умолчанию пространством имен будет корневое пространство имен и имена всех подкаталогов в корневом каталоге проекта. Однако из Ефкоре 5,0 можно переопределить пространство имен для всех выходных классов с помощью `-Namespace` . Также можно переопределить пространство имен только для класса DbContext с помощью `-ContextNamespace` .

``` powershell
Scaffold-DbContext ... -Namespace Your.Namespace -ContextNamespace Your.DbContext.Namespace
```

***

## <a name="how-it-works"></a>Принцип работы

Реконструирование начинается с считывания схемы базы данных. Он считывает сведения о таблицах, столбцах, ограничениях и индексах.

Затем он использует сведения о схеме для создания модели EF Core. Таблицы используются для создания типов сущностей. столбцы используются для создания свойств; и внешние ключи используются для создания связей.

Наконец, модель используется для создания кода. Для повторного создания той же модели из приложения создаются шаблоны соответствующих классов, API Fluent и заметок к данным.

## <a name="limitations"></a>Ограничения

* Не все сведения о модели можно представить с помощью схемы базы данных. Например, сведения о [**иерархиях наследования**](../modeling/inheritance.md), [**принадлежащих типах**](../modeling/owned-entities.md)и [**разбиении таблиц**](../modeling/table-splitting.md) отсутствуют в схеме базы данных. По этой причине эти конструкции никогда не будут обрабатываться в обратном порядке.
* Кроме того, **некоторые типы столбцов** могут не поддерживаться поставщиком EF Core. Эти столбцы не будут включаться в модель.
* В модели EF Core можно определить [**маркеры параллелизма**](../modeling/concurrency.md), чтобы запретить двум пользователям одновременно обновлять одну и ту же сущность. Некоторые базы данных имеют специальный тип для представления этого типа столбца (например, rowversion в SQL Server). в этом случае мы можем реконструировать эту информацию. Однако другие маркеры параллелизма не будут реконструированы.
* [Функция ссылочного типа C# 8 Nullable](/dotnet/csharp/tutorials/nullable-reference-types) в настоящее время не поддерживается в обратном проектировании: EF Core всегда создает код C#, который предполагает, что функция отключена. Например, столбцы с текстом, допускающими значение null, будут формироваться в виде свойства с типом `string` , а не `string?` с помощью API-интерфейса Fluent или заметок к данным, используемых для настройки того, является ли свойство обязательным. Вы можете изменить сформированный код и заменить их на метки допустимости значений NULL в C#. Поддержка формирования шаблонов для ссылочных типов, допускающих значения NULL, ведется по выпуску [#15520](https://github.com/aspnet/EntityFrameworkCore/issues/15520).

## <a name="customizing-the-model"></a>Настройка модели

Кодом, созданным EF Core, является ваш код. Вы можете изменить его. Он будет создан повторно только в том случае, если реконструировать ту же модель снова. Шаблонный код представляет *одну* модель, которую можно использовать для доступа к базе данных, но, конечно, не *единственная* модель, которую можно использовать.

Настройте классы типов сущностей и класс DbContext в соответствии с вашими потребностями. Например, можно переименовать типы и свойства, ввести иерархии наследования или разделить таблицу на несколько сущностей. Можно также удалить Неуникальные индексы, неиспользуемые последовательности и свойства навигации, необязательные скалярные свойства и имена ограничений из модели.

Можно также добавить дополнительные конструкторы, методы, свойства и т. д. Использование другого разделяемого класса в отдельном файле. Этот подход работает даже в том случае, если планируется реконструировать модель снова.

## <a name="updating-the-model"></a>Обновление модели

После внесения изменений в базу данных может потребоваться обновить модель EF Core, чтобы отразить эти изменения. Если изменения базы данных просты, возможно, проще всего вручную внести изменения в модель EF Core. Например, переименование таблицы или столбца, удаление столбца или обновление типа столбца являются тривиальными изменениями для внесения в код.

Однако более существенные изменения не так просто выполнять вручную. Один из распространенных рабочих процессов — реконструирование модели из базы данных с помощью `-Force` (PMC) или `--force` (CLI) для перезаписи существующей модели обновленной.

Еще одна часто запрашиваемая функция — возможность обновления модели из базы данных с сохранением настроек, таких как переименование, иерархии типов и т. д. Чтобы отслеживать ход выполнения этой функции, используйте [#831](https://github.com/aspnet/EntityFrameworkCore/issues/831) выдача.

> [!WARNING]
> При повторном конструировании модели из базы данных все изменения, внесенные в файлы, будут потеряны.
