---
title: Индексы — EF Core
author: roji
ms.date: 12/16/2019
ms.assetid: 85b92003-b692-417d-ac1d-76d40dce664b
uid: core/modeling/indexes
ms.openlocfilehash: 810fccc0c6b035f515107601b245811f7b4118a6
ms.sourcegitcommit: 32c51c22988c6f83ed4f8e50a1d01be3f4114e81
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/27/2019
ms.locfileid: "75502140"
---
# <a name="indexes"></a>Индексы

Индексы являются распространенной концепцией для многих хранилищ данных. Хотя их реализация в хранилище данных может различаться, они используются для выполнения уточняющих запросов, основанных на столбце (или наборе столбцов), которые более эффективны.

Индексы нельзя создавать с помощью заметок к данным. API-интерфейс Fluent можно использовать для указания индекса в одном столбце следующим образом:

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Index.cs?name=Index&highlight=4)]

Кроме того, можно указать индекс более чем для одного столбца:

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/IndexComposite.cs?name=Composite&highlight=4)]

> [!NOTE]
> По соглашению индекс создается в каждом свойстве (или наборе свойств), используемом в качестве внешнего ключа.
>
> EF Core поддерживает только один индекс для каждого отдельного набора свойств. Если вы используете API Fluent для настройки индекса для набора свойств, в котором уже определен индекс, либо в соответствии с соглашением, либо с помощью предыдущей конфигурации, вы измените определение этого индекса. Это полезно, если необходимо дополнительно настроить индекс, созданный по соглашению.

## <a name="index-uniqueness"></a>Уникальность индекса

По умолчанию индексы не являются уникальными: несколько строк могут иметь одинаковые значения для набора столбцов индекса. Уникальный индекс можно сделать следующим образом:

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/IndexUnique.cs?name=IndexUnique&highlight=5)]

Попытка вставить более одной сущности с одинаковыми значениями для набора столбцов индекса приведет к возникновению исключения.

## <a name="index-name"></a>Имя индекса

По соглашению индексы, создаваемые в реляционной базе данных, называются `IX_<type name>_<property name>`. Для составных индексов `<property name>` преобразуется в список имен свойств с разделителями подчеркивания.

Для задания имени индекса, созданного в базе данных, можно использовать API-интерфейс Fluent.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/IndexName.cs?name=IndexName&highlight=5)]

## <a name="index-filter"></a>Фильтр индекса

Некоторые реляционные базы данных позволяют указать отфильтрованный или частичный индекс. Это позволяет индексировать только подмножество значений столбца, уменьшая размер индекса и повышая производительность и использование дискового пространства. Дополнительные сведения об SQL Server фильтруемых индексах [см. в документации](https://docs.microsoft.com/sql/relational-databases/indexes/create-filtered-indexes).

API-интерфейс Fluent можно использовать для указания фильтра по индексу, который указывается в виде выражения SQL:

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/IndexFilter.cs?name=IndexFilter&highlight=5)]

При использовании поставщика SQL Server EF добавляет фильтр `'IS NOT NULL'` для всех столбцов, допускающих значение null, которые являются частью уникального индекса. Чтобы переопределить это соглашение, можно указать значение `null`.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/IndexNoFilter.cs?name=IndexNoFilter&highlight=6)]

## <a name="included-columns"></a>Включенные столбцы

Некоторые реляционные базы данных позволяют настроить набор столбцов, которые будут включены в индекс, но не являются частью ключа. Это может значительно повысить производительность запросов, если все столбцы в запросе включены в индекс как ключевые или неключевые столбцы, так как к самой таблице не требуется доступ. Дополнительные сведения о SQL Server включенных столбцах [см. в документации](https://docs.microsoft.com/sql/relational-databases/indexes/create-indexes-with-included-columns).

В следующем примере столбец `Url` является частью ключа индекса, поэтому для любой фильтрации запросов в этом столбце может использоваться индекс. Кроме того, запросы, обращающиеся только к столбцам `Title` и `PublishedOn`, не требуют доступа к таблице и будут работать более эффективно:

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/IndexInclude.cs?name=IndexInclude&highlight=5-9)]
