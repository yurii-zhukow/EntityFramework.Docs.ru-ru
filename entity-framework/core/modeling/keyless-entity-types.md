---
title: Типы сущностей без ключей - EF Core
description: Как настроить типы сущностей без бесключевого ключа с помощью Core Entity Framework
author: AndriySvyryd
ms.author: ansvyryd
ms.date: 9/13/2019
uid: core/modeling/keyless-entity-types
ms.openlocfilehash: 496e1e8983ba2d5e15dbee02607ea3f2c861503e
ms.sourcegitcommit: 144edccf9b29a7ffad119c235ac9808ec1a46193
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/16/2020
ms.locfileid: "81434218"
---
# <a name="keyless-entity-types"></a>Типы сущностей без ключей

> [!NOTE]
> Эта функция была добавлена в EF Core 2.1 под названием типов запросов. В EF Core 3.0 концепция была переименована в типы бесключевого сущности.

В дополнение к обычным типам сущностей модель EF Core может содержать _типы сущностей без бесключевого,_ которые могут использоваться для выполнения запросов баз данных в отношении данных, не содержащих ключевых значений.

## <a name="defining-keyless-entity-types"></a>Определение типов сущностей Keyless

Типы сущности Keyless могут быть определены с помощью аннотации данных или API Fluent:

### <a name="data-annotations"></a>[Аннотации данных](#tab/data-annotations)

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/Keyless.cs?Name=Keyless&highlight=1)]

### <a name="fluent-api"></a>[Текучий API](#tab/fluent-api)

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Keyless.cs?Name=Keyless&highlight=4)]

***

## <a name="keyless-entity-types-characteristics"></a>Характеристики типов бесключевых сущностей

Типы сущности Keyless поддерживают многие из тех же возможностей отображения, что и обычные типы сущности, такие как отображение наследования и свойства навигации. В реляционных хранилищах они могут настраивать объекты и столбцы целевой базы данных с помощью свободно используемых методов API или аннотаций данных.

Тем не менее, они отличаются от обычных типов сущности в том, что они:

- Не удается определить ключ.
- Никогда не отслеживаются для изменений в _DbContext_ и, следовательно, никогда не вставляются, обновляются или удаляются в базу данных.
- Никогда не обнаруживаются конвенцией.
- Только поддержка подмножество навигационных возможностей отображения, в частности:
  - Они никогда не могут выступать в качестве основного конца отношений.
  - Они могут не иметь навигации для принадлежащих организаций
  - Они могут содержать только ориентировостые навигационные свойства, указывающие на обычные объекты.
  - Сущности не могут содержать навигационные свойства к типам бесключевого объекта.
- Необходимо настроить с аннотацией `[Keyless]` данных или вызовом метода. `.HasNoKey()`
- Может быть отображены к _определяющему запросу._ Определяющим запросом является запрос, объявленный в модели, который действует как источник данных для типа бесключевого объекта.

## <a name="usage-scenarios"></a>Сценарии использования

Некоторые из основных сценариев использования для типов бесключевого сущности:

- Обслуживание в качестве типа возврата для [необработанных запросов S'L.](xref:core/querying/raw-sql)
- Отображение представлений баз данных, не содержащих основной ключ.
- Отображение к таблицам, которые не имеют основного ключа определены.
- Отображение запросов, определенных в модели.

## <a name="mapping-to-database-objects"></a>Отображение к объектам базы данных

Отображение типа бесключевой сущности `ToTable` для `ToView` объекта базы данных достигается с помощью или свободного API. С точки зрения EF Core объект базы данных, указанный в этом методе, представляет собой _представление,_ означающее, что он рассматривается как источник запроса только для чтения и не может быть целью обновления, вставки или удаления операций. Однако это не означает, что объект базы данных на самом деле должен быть представлением базы данных. В качестве альтернативы это может быть таблица баз данных, которая будет рассматриваться как только для чтения. И наоборот, для обычных типов сущностей EF Core `ToTable` предполагает, что объект базы данных, указанный в методе, может рассматриваться как _таблица,_ что означает, что он может быть использован в качестве источника запроса, но также ориентирован на обновление, удаление и вставки операций. На самом деле, можно указать имя `ToTable` представления базы данных, и все должно работать нормально, пока представление настроено для updatable в базе данных.

> [!NOTE]
> `ToView`предполагает, что объект уже существует в базе данных и не будет создан миграциями.

## <a name="example"></a>Пример

В следующем примере показано, как использовать типы сущности без ключа для запроса представления базы данных.

> [!TIP]
> Вы можете просмотреть [пример](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/KeylessEntityTypes) этой статьи на GitHub.

Во-первых, мы определяем простую модель блога и поста:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#Entities)]

Далее мы определяем простое представление базы данных, которое позволит нам задать вопрос о количестве сообщений, связанных с каждым блогом:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#View)]

Далее мы определяем класс для удержания результата из представления базы данных:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#KeylessEntityType)]

Далее мы настраиваем тип бесключевой сущности `HasNoKey` в _OnModelCreating_ с помощью API.
Мы используем свободно настроенный API конфигурации для настройки отображения для типа бесключевого объекта:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#Configuration)]

Далее мы настраиваем, `DbContext` `DbSet<T>`чтобы включить:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#DbSet)]

Наконец, мы можем задавить представление базы данных стандартным способом:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#Query)]

> [!TIP]
> Обратите внимание, что мы также определили свойство запроса контекстного уровня (DbSet) для того, чтобы служить корнем для запросов против этого типа.
