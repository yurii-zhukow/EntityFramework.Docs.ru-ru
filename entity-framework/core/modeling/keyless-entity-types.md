---
title: Типы сущностей без ключей — EF Core
description: Настройка типов сущностей без ключей с помощью Entity Framework Core
author: AndriySvyryd
ms.date: 9/13/2019
uid: core/modeling/keyless-entity-types
ms.openlocfilehash: 488b21767993474d3e90677ee1e480a970b09edb
ms.sourcegitcommit: 4798ab8d04c1fdbe6dd204d94d770fcbf309d09b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/11/2021
ms.locfileid: "103023943"
---
# <a name="keyless-entity-types"></a>Типы сущностей без ключей

> [!NOTE]
> Эта функция была добавлена под именем типов запросов. В EF Core 3,0 концепция была переименована в типы сущностей без ключей. `[Keyless]`Аннотация данных стала доступной в ефкоре 5,0.

В дополнение к обычным типам сущностей модель EF Core может содержать незашифрованные _типы сущностей_, которые можно использовать для выполнения запросов к базе данных, не содержащей значений ключей.

## <a name="defining-keyless-entity-types"></a>Определение типов сущностей без ключей

Типы сущностей без ключей можно определить с помощью аннотации данных или API-интерфейса Fluent:

### <a name="data-annotations"></a>[Заметки к данным](#tab/data-annotations)

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/Keyless.cs?Name=Keyless&highlight=1)]

### <a name="fluent-api"></a>[Текучий API](#tab/fluent-api)

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Keyless.cs?Name=Keyless&highlight=4)]

***

## <a name="keyless-entity-types-characteristics"></a>Характеристики типов сущностей без ключей

Типы сущностей без ключей поддерживают многие из тех же возможностей сопоставления, что и обычные типы сущностей, такие как сопоставление наследования и свойства навигации. В реляционных хранилищах они могут настраивать объекты и столбцы целевой базы данных с помощью методов API Fluent или заметок к данным.

Однако они отличаются от обычных типов сущностей тем, что они:

- Ключ не может быть определен.
- Никогда не отправляются для изменений в _DbContext_ , поэтому они никогда не вставляются, не обновляются или не удаляются в базе данных.
- Никогда не обнаруживаются по соглашению.
- Поддерживаются только подмножество возможностей сопоставления навигации, в частности:
  - Они не могут действовать в качестве основного элемента связи.
  - Они не могут иметь переходы к собственным сущностям
  - Они могут содержать только свойства навигации по ссылке, указывающие на обычные сущности.
  - Сущности не могут содержать свойства навигации для неключейых типов сущностей.
- Необходимо настроить с `[Keyless]` заметкой данных или `.HasNoKey()` вызовом метода.
- Может быть сопоставлен с _определяющим запросом_. Определяющий запрос — это запрос, объявленный в модели, который выступает в качестве источника данных для типа сущности без ключей.

## <a name="usage-scenarios"></a>Сценарии использования

Ниже приведены некоторые основные сценарии использования для типов сущностей без ключей:

- Служит типом возвращаемого значения для [необработанных запросов SQL](xref:core/querying/raw-sql).
- Сопоставление с представлениями базы данных, которые не содержат первичный ключ.
- Сопоставление с таблицами, для которых не определен первичный ключ.
- Сопоставление с запросами, определенными в модели.

## <a name="mapping-to-database-objects"></a>Сопоставление с объектами базы данных

Сопоставление типа сущности без ключей с объектом базы данных достигается с помощью `ToTable` `ToView` API-интерфейса или Fluent. С точки зрения EF Core, объект базы данных, указанный в этом методе, является _представлением_, то есть он обрабатывается как источник запроса только для чтения и не может быть целевым объектом операций обновления, вставки или удаления. Однако это не означает, что объект базы данных действительно должен быть представлением базы данных. В качестве альтернативы можно использовать таблицу базы данных, которая будет рассматриваться как доступная только для чтения. И наоборот, для обычных типов сущностей EF Core предполагается, что объект базы данных, указанный в `ToTable` методе, может рассматриваться как _Таблица_, что означает, что он может использоваться в качестве источника запроса, но также предназначен для операций обновления, удаления и вставки. На самом деле можно указать имя представления базы данных в `ToTable` , и все должно работать правильно, пока представление настроено для обновления в базе данных.

> [!NOTE]
> `ToView` Предполагается, что объект уже существует в базе данных и не создается при миграции.

## <a name="example"></a>Пример

В следующем примере показано, как использовать типы сущностей без ключей для запроса представления базы данных.

> [!TIP]
> Для этой статьи вы можете скачать [пример](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/KeylessEntityTypes) из репозитория GitHub.

Во-первых, мы определим простой блог и модель Post:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#Entities)]

Далее мы определим простое представление базы данных, которое позволит запросить число записей, связанных с каждым блогом:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#View)]

Далее мы определим класс для хранения результатов из представления базы данных:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#KeylessEntityType)]

Далее мы настроим тип сущности без ключей в _OnModelCreating_ с помощью `HasNoKey` API.
Мы используем API-интерфейс конфигурации Fluent для настройки сопоставления для типа сущности без ключей:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#Configuration)]

Далее мы настроим `DbContext` для включения `DbSet<T>` :

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#DbSet)]

Наконец, можно запрашивать представление базы данных стандартным образом:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#Query)]

> [!TIP]
> Обратите внимание, что мы также определили свойство запроса уровня контекста (DbSet), которое будет использоваться в качестве корневого для запросов к этому типу.

> [!TIP]
> Чтобы протестировать типы сущностей без ключей, сопоставленные с представлениями с помощью поставщика в памяти, сопоставьте их с запросом через `ToInMemoryQuery` . Дополнительные сведения см. в разделе [готовый к запуску пример](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Miscellaneous/Testing/ItemsWebApi/) с использованием этого метода.
