---
title: Собственные типы сущностей — EF Core
description: Настройка собственных типов сущностей или статистических выражений при использовании Entity Framework Core
author: AndriySvyryd
ms.date: 11/06/2019
uid: core/modeling/owned-entities
ms.openlocfilehash: 4175c281254c25e957fd701c671f2d75c7789aab
ms.sourcegitcommit: 4798ab8d04c1fdbe6dd204d94d770fcbf309d09b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/11/2021
ms.locfileid: "103023956"
---
# <a name="owned-entity-types"></a>Принадлежащие типы сущностей

EF Core позволяет моделировать типы сущностей, которые могут отображаться только в свойствах навигации других типов сущностей. Они называются _типами собственных сущностей_. Сущность, содержащая принадлежащий тип сущности, является ее _владельцем_.

Собственные сущности по сути являются частью владельца и не могут существовать без них, они похожи на [статистические выражения](https://martinfowler.com/bliki/DDD_Aggregate.html). Это означает, что принадлежащая сущность является определением на зависимой стороне связи с владельцем.

## <a name="explicit-configuration"></a>Явная конфигурация

Собственные типы сущностей никогда не включаются в EF Core в модели по соглашению. `OwnsOne` `OnModelCreating` `OwnedAttribute` Для настройки типа в качестве принадлежащего типа можно использовать метод в или добавить аннотацию к типу с помощью метода.

В этом примере `StreetAddress` — это тип без свойства Identity. Он используется как свойство сущности Order для указания адреса доставки конкретного заказа.

Мы можем использовать, `OwnedAttribute` чтобы интерпретировать его как принадлежащую сущность при ссылке из другого типа сущности:

[!code-csharp[StreetAddress](../../../samples/core/Modeling/OwnedEntities/StreetAddress.cs?name=StreetAddress)]

[!code-csharp[Order](../../../samples/core/Modeling/OwnedEntities/Order.cs?name=Order)]

Можно также использовать `OwnsOne` метод в, `OnModelCreating` чтобы указать, что `ShippingAddress` свойство является владельцем сущности `Order` типа сущности, и настроить дополнительные аспекты при необходимости.

[!code-csharp[OwnsOne](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsOne)]

Если `ShippingAddress` свойство является частным в `Order` типе, можно использовать строковую версию `OwnsOne` метода:

[!code-csharp[OwnsOneString](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsOneString)]

Приведенная выше модель сопоставлена со следующей схемой базы данных:

![Сцееншот модели базы данных для сущности, содержащей собственную ссылку](_static/owned-entities-ownsone.png)

См. [полный пример проекта](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Modeling/OwnedEntities) для получения дополнительных контекстов.

> [!TIP]
> Тип принадлежащей сущности можно пометить как обязательный. Дополнительные сведения см. в разделе [обязательные зависимости "один к одному](xref:core/modeling/relationships#one-to-one) ".

## <a name="implicit-keys"></a>Неявные ключи

Принадлежащие типы, настроенные `OwnsOne` или обнаруженные с помощью навигации по ссылке, всегда имеют связь «один к одному» с владельцем, поэтому им не нужны собственные значения ключей, так как значения внешних ключей уникальны. В предыдущем примере `StreetAddress` тип не требует определения ключевого свойства.

Чтобы понять, как EF Core отслеживает эти объекты, полезно знать, что первичный ключ создается как [свойство теневого копирования](xref:core/modeling/shadow-properties) для принадлежащего типа. Значение ключа экземпляра принадлежащего типа будет таким же, как и значение ключа экземпляра Owner.

## <a name="collections-of-owned-types"></a>Коллекции принадлежащих типов

Чтобы настроить коллекцию принадлежащих типов, используйте `OwnsMany` в `OnModelCreating` .

Принадлежащие типы должны иметь первичный ключ. Если в типе .NET нет хороших свойств кандидатов, EF Core может попытаться создать его. Однако если собственные типы определяются через коллекцию, достаточно просто создать свойство теневой копии, которое будет действовать как внешний ключ в качестве внешнего ключа владельца и первичный ключ принадлежащего экземпляра, как мы делаем `OwnsOne` : для каждого владельца может существовать несколько экземпляров принадлежащих типов, поэтому ключ владельца недостаточно, чтобы предоставить уникальный идентификатор для каждого принадлежащего экземпляра.

Вот два самых простых решения:

- Определение первичного ключа суррогата для нового свойства независимо от внешнего ключа, указывающего на владельца. Содержащиеся значения должны быть уникальными для всех владельцев (например, если у родителя {1} есть дочерний элемент {1} , а родительский элемент {2} не может быть дочерним {1} ), поэтому значение не имеет какого-либо значения. Так как внешний ключ не является частью первичного ключа, его значения можно изменить, поэтому дочерний элемент можно переместить из одного родителя в другой, однако это обычно происходит по семантике агрегата.
- Использование внешнего ключа и дополнительного свойства в качестве составного ключа. Значение дополнительного свойства теперь должно быть уникальным только для данного родителя (поэтому, если родитель {1} имеет дочерний элемент, {1,1} родительский элемент {2} может по-прежнему иметь дочерний элемент {2,1} ). Делая внешний ключ частью первичного ключа, связь между владельцем и собственной сущностью становится неизменяемой и в большей мере отражает семантику агрегата. По умолчанию это EF Core.

В этом примере мы будем использовать `Distributor` класс.

[!code-csharp[Distributor](../../../samples/core/Modeling/OwnedEntities/Distributor.cs?name=Distributor)]

По умолчанию первичным ключом, используемым для принадлежащего типа, на который ссылается `ShippingCenters` свойство навигации, будет, `("DistributorId", "Id")` где `"DistributorId"` — FK, а `"Id"` — уникальное `int` значение.

Для настройки другого вызова первичного ключа `HasKey` .

[!code-csharp[OwnsMany](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsMany)]

Приведенная выше модель сопоставлена со следующей схемой базы данных:

![Сцееншот модели базы данных для сущности, содержащей собственную коллекцию](_static/owned-entities-ownsmany.png)

## <a name="mapping-owned-types-with-table-splitting"></a>Сопоставление принадлежащих типов с разделением таблицы

При использовании реляционных баз данных ссылочные типы, принадлежащие по умолчанию, сопоставляются с той же таблицей, что и владелец. Для этого требуется разделение таблицы двумя столбцами: некоторые столбцы будут использоваться для хранения данных владельца, а некоторые столбцы будут использоваться для хранения данных собственной сущности. Это обычная функция, известная как [Разбиение таблицы](xref:core/modeling/table-splitting).

По умолчанию EF Core будет наименовать столбцы базы данных для свойств собственного типа сущности после _Navigation_OwnedEntityProperty_ шаблона. Поэтому `StreetAddress` свойства будут отображаться в таблице "Orders" с именами "ShippingAddress_Street" и "ShippingAddress_City".

`HasColumnName`Для переименования этих столбцов можно использовать метод.

[!code-csharp[ColumnNames](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=ColumnNames)]

> [!NOTE]
> Большинство обычных методов настройки типа сущности, таких как [Ignore](/dotnet/api/microsoft.entityframeworkcore.metadata.builders.ownednavigationbuilder.ignore) , можно вызывать одинаковым образом.

## <a name="sharing-the-same-net-type-among-multiple-owned-types"></a>Совместное использование одного типа .NET между несколькими принадлежащими типами

Принадлежащий тип сущности может иметь тот же тип .NET, что и другой принадлежащий тип сущности, поэтому тип .NET может быть недостаточно для обнаружения принадлежащего типа.

В таких случаях свойство, указывающее из владельца на принадлежащую сущность, превращается в _определяющую навигацию_ для принадлежит к типу сущности. С точки зрения EF Core, определяющая Навигация является частью удостоверения типа, рядом с типом .NET.

Например, в следующем классе `ShippingAddress` и `BillingAddress` оба имеют одинаковый тип .NET `StreetAddress` .

[!code-csharp[OrderDetails](../../../samples/core/Modeling/OwnedEntities/OrderDetails.cs?name=OrderDetails)]

Чтобы понять, как EF Core различает отслеживание экземпляров этих объектов, можно подумать, что определяющая Навигация стала частью ключа экземпляра наряду со значением ключа владельца и типом .NET принадлежащего типа.

## <a name="nested-owned-types"></a>Вложенные принадлежащие типы

В этом примере `OrderDetails` принадлежат `BillingAddress` и `ShippingAddress` , которые являются `StreetAddress` типами. А `OrderDetails`, в свою очередь, принадлежит типу `DetailedOrder`.

[!code-csharp[DetailedOrder](../../../samples/core/Modeling/OwnedEntities/DetailedOrder.cs?name=DetailedOrder)]

[!code-csharp[OrderStatus](../../../samples/core/Modeling/OwnedEntities/OrderStatus.cs?name=OrderStatus)]

Каждый переход к принадлежащему типу определяет отдельный тип сущности с полностью независимой конфигурацией.

Помимо вложенных принадлежащих типов, принадлежащие типы могут ссылаться на обычную сущность, которая может быть либо владельцем, либо другой сущностью при условии, что принадлежащая сущность находится на зависимой стороне. Эта возможность задает собственные типы сущностей, кроме сложных типов в EF6.

[!code-csharp[OrderDetails](../../../samples/core/Modeling/OwnedEntities/OrderDetails.cs?name=OrderDetails)]

## <a name="configuring-owned-types"></a>Настройка принадлежащих типов

Можно связать `OwnsOne` метод в вызове Fluent, чтобы настроить эту модель:

[!code-csharp[OwnsOneNested](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsOneNested)]

Обратите внимание на `WithOwner` вызов, используемый для определения свойства навигации, указывающего назад у владельца. Чтобы определить навигацию для типа сущности владельца, которая не является частью отношения владения, `WithOwner()` следует вызывать без аргументов.

Этот результат также можно достичь с помощью `OwnedAttribute` как для, так `OrderDetails` и для `StreetAddress` .

Кроме того, обратите внимание на `Navigation` вызов. В Ефкоре 5,0 свойства навигации для собственных типов можно настроить [так же, как для несобственных свойств навигации](xref:core/modeling/relationships#configuring-navigation-properties).

Приведенная выше модель сопоставлена со следующей схемой базы данных:

![Снимок экрана модели базы данных для сущности, содержащей вложенные собственные ссылки](_static/owned-entities-nested.png)

## <a name="storing-owned-types-in-separate-tables"></a>Хранение принадлежащих типов в отдельных таблицах

Кроме того, в отличие от сложных типов EF6, принадлежащие типы могут храниться в отдельной таблице от владельца. Чтобы переопределить соглашение, которое сопоставляет принадлежащий тип с той же таблицей, что и владелец, можно просто вызвать метод `ToTable` и указать другое имя таблицы. В следующем примере сопоставляется `OrderDetails` и его два адреса в отдельную таблицу из `DetailedOrder` :

[!code-csharp[OwnsOneTable](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsOneTable)]

Можно также использовать `TableAttribute` для решения этой задачи, но обратите внимание, что это приведет к сбою, если существует несколько переходов к принадлежащему типу, так как в этом случае несколько типов сущностей будут сопоставлены с одной и той же таблицей.

## <a name="querying-owned-types"></a>Запросы к собственным типам

При запросе владельца принадлежащие типы включаются по умолчанию. Не обязательно использовать `Include` метод, даже если принадлежащие типы хранятся в отдельной таблице. В зависимости от модели, описанной ранее, следующий запрос получает `Order` `OrderDetails` и два, принадлежащие `StreetAddresses` базе данных:

[!code-csharp[DetailedOrderQuery](../../../samples/core/Modeling/OwnedEntities/Program.cs?name=DetailedOrderQuery)]

## <a name="limitations"></a>Ограничения

Некоторые из этих ограничений основаны на принципах работы собственных типов сущностей, но некоторые другие являются ограничениями, которые можно удалить в следующих выпусках:

### <a name="by-design-restrictions"></a>Ограничения по проектированию

- Нельзя создать `DbSet<T>` для принадлежащего типа.
- Нельзя вызвать `Entity<T>()` с собственным типом в `ModelBuilder` .
- Экземпляры собственных типов сущностей не могут совместно использоваться несколькими владельцами (это хорошо известный сценарий для объектов значений, которые не могут быть реализованы с помощью собственных типов сущностей).

### <a name="current-shortcomings"></a>Текущие недостатки

- Собственные типы сущностей не могут иметь иерархии наследования

### <a name="shortcomings-in-previous-versions"></a>Недостатки в предыдущих версиях

- В EF Core 2. x навигационные ссылки на типы собственных сущностей не могут иметь значение null, если они явно не сопоставлены с отдельной таблицей от владельца.
- В EF Core 3. x столбцы для собственных типов сущностей, сопоставленные с той же таблицей, что и владелец, всегда помечаются как допускающие значение null.
