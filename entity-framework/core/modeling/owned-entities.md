---
title: Собственные типы сущностей — EF Core
description: Настройка собственных типов сущностей или статистических выражений при использовании Entity Framework Core
author: AndriySvyryd
ms.author: ansvyryd
ms.date: 11/06/2019
uid: core/modeling/owned-entities
ms.openlocfilehash: da4a459fbc40010fc14190204c8ed66fe0495b84
ms.sourcegitcommit: cc0ff36e46e9ed3527638f7208000e8521faef2e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78413987"
---
# <a name="owned-entity-types"></a>Принадлежащие типы сущностей

EF Core позволяет моделировать типы сущностей, которые могут отображаться только в свойствах навигации других типов сущностей. Они называются _типами собственных сущностей_. Сущность, содержащая принадлежащий тип сущности, является ее _владельцем_.

Собственные сущности по сути являются частью владельца и не могут существовать без них, они похожи на [статистические выражения](https://martinfowler.com/bliki/DDD_Aggregate.html). Это означает, что принадлежащая сущность является определением на зависимой стороне связи с владельцем.

## <a name="explicit-configuration"></a>Явная конфигурация

Собственные типы сущностей никогда не включаются в EF Core в модели по соглашению. Можно использовать метод `OwnsOne` в `OnModelCreating` или добавить аннотацию к типу с помощью `OwnedAttribute` (New в EF Core 2,1), чтобы настроить тип в качестве принадлежащего типа.

В этом примере `StreetAddress` является типом без свойства Identity. Он используется как свойство сущности Order для указания адреса доставки конкретного заказа.

Можно использовать `OwnedAttribute`, чтобы интерпретировать его как принадлежащую сущность при ссылке из другого типа сущности:

[!code-csharp[StreetAddress](../../../samples/core/Modeling/OwnedEntities/StreetAddress.cs?name=StreetAddress)]

[!code-csharp[Order](../../../samples/core/Modeling/OwnedEntities/Order.cs?name=Order)]

Можно также использовать метод `OwnsOne` в `OnModelCreating`, чтобы указать, что свойство `ShippingAddress` является владельцем сущности `Order` типа сущности и настроить дополнительные аспекты при необходимости.

[!code-csharp[OwnsOne](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsOne)]

Если свойство `ShippingAddress` является частным в типе `Order`, можно использовать строковую версию метода `OwnsOne`:

[!code-csharp[OwnsOneString](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsOneString)]

См. [полный пример проекта](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Modeling/OwnedEntities) для получения дополнительных контекстов.

## <a name="implicit-keys"></a>Неявные ключи

Принадлежащие типы, настроенные с `OwnsOne` или обнаруженные с помощью навигации по ссылке, всегда имеют связь «один к одному» с владельцем, поэтому им не нужны свои значения ключей, так как значения внешних ключей уникальны. В предыдущем примере типу `StreetAddress` не нужно определять ключевое свойство.  

Чтобы понять, как EF Core отслеживает эти объекты, полезно знать, что первичный ключ создается как [свойство теневого копирования](xref:core/modeling/shadow-properties) для принадлежащего типа. Значение ключа экземпляра принадлежащего типа будет таким же, как и значение ключа экземпляра Owner.

## <a name="collections-of-owned-types"></a>Коллекции принадлежащих типов

> [!NOTE]
> Это новая функция в EF Core 2.2.

Чтобы настроить коллекцию принадлежащих типов, используйте `OwnsMany` в `OnModelCreating`.

Принадлежащие типы должны иметь первичный ключ. Если в типе .NET нет хороших свойств кандидатов, EF Core может попытаться создать его. Однако, если собственные типы определяются через коллекцию, достаточно просто создать свойство теневой копии, которое будет действовать как внешний ключ владельца и первичный ключ принадлежащего экземпляра, как мы делаем для `OwnsOne`: для каждого владельца может существовать несколько экземпляров принадлежащих типов, поэтому ключ владельца недостаточно, чтобы предоставить уникальный идентификатор для каждого принадлежащего экземпляра.

Вот два самых простых решения:

- Определение первичного ключа суррогата для нового свойства независимо от внешнего ключа, указывающего на владельца. Содержащиеся значения должны быть уникальными для всех владельцев (например, если родительский {1} имеет дочерний {1}, родительский {2} не может иметь дочерний {1}), поэтому значение не имеет ни одного значения. Так как внешний ключ не является частью первичного ключа, его значения можно изменить, поэтому дочерний элемент можно переместить из одного родителя в другой, однако это обычно происходит по семантике агрегата.
- Использование внешнего ключа и дополнительного свойства в качестве составного ключа. Значение дополнительного свойства теперь должно быть уникальным только для данного родителя (если родительский {1} имеет дочерний {1,1} родительский {2} может по-прежнему иметь дочерний {2,1}). Делая внешний ключ частью первичного ключа, связь между владельцем и собственной сущностью становится неизменяемой и в большей мере отражает семантику агрегата. По умолчанию это EF Core.

В этом примере мы будем использовать класс `Distributor`:

[!code-csharp[Distributor](../../../samples/core/Modeling/OwnedEntities/Distributor.cs?name=Distributor)]

По умолчанию первичный ключ, используемый для принадлежащего типа, на который ссылается свойство навигации `ShippingCenters`, будет `("DistributorId", "Id")`, где `"DistributorId"` — FK, а `"Id"` — уникальное `int` значение.

Чтобы настроить другой `HasKey`вызова PK:

[!code-csharp[OwnsMany](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsMany)]

> [!NOTE]
> До EF Core 3,0 метод `WithOwner()` не существовал, поэтому этот вызов следует удалить. Кроме того, первичный ключ не был обнаружен автоматически, поэтому он всегда был указан.

## <a name="mapping-owned-types-with-table-splitting"></a>Сопоставление принадлежащих типов с разделением таблицы

При использовании реляционных баз данных ссылочные типы, принадлежащие по умолчанию, сопоставляются с той же таблицей, что и владелец. Для этого требуется разделение таблицы двумя столбцами: некоторые столбцы будут использоваться для хранения данных владельца, а некоторые столбцы будут использоваться для хранения данных собственной сущности. Это обычная функция, известная как [Разбиение таблицы](table-splitting.md).

По умолчанию EF Core будет наименовать столбцы базы данных для свойств собственного типа сущности после _Navigation_OwnedEntityProperty_шаблона. Поэтому свойства `StreetAddress` будут отображаться в таблице "Orders" с именами "ShippingAddress_Street" и "ShippingAddress_City".

Для переименования этих столбцов можно использовать метод `HasColumnName`:

[!code-csharp[ColumnNames](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=ColumnNames)]

> [!NOTE]
> Большинство обычных методов настройки типа сущности, таких как [Ignore](/dotnet/api/microsoft.entityframeworkcore.metadata.builders.ownednavigationbuilder.ignore) , можно вызывать одинаковым образом.

## <a name="sharing-the-same-net-type-among-multiple-owned-types"></a>Совместное использование одного типа .NET между несколькими принадлежащими типами

Принадлежащий тип сущности может иметь тот же тип .NET, что и другой принадлежащий тип сущности, поэтому тип .NET может быть недостаточно для обнаружения принадлежащего типа.

В таких случаях свойство, указывающее из владельца на принадлежащую сущность, превращается в _определяющую навигацию_ для принадлежит к типу сущности. С точки зрения EF Core, определяющая Навигация является частью удостоверения типа, рядом с типом .NET.

Например, в следующем классе `ShippingAddress` и `BillingAddress` имеют одинаковый тип .NET `StreetAddress`:

[!code-csharp[OrderDetails](../../../samples/core/Modeling/OwnedEntities/OrderDetails.cs?name=OrderDetails)]

Чтобы понять, как EF Core различает отслеживание экземпляров этих объектов, можно подумать, что определяющая Навигация стала частью ключа экземпляра наряду со значением ключа владельца и типом .NET принадлежащего типа.

## <a name="nested-owned-types"></a>Вложенные принадлежащие типы

В этом примере `OrderDetails` владеет `BillingAddress` и `ShippingAddress`, которые являются типами `StreetAddress`. А `OrderDetails`, в свою очередь, принадлежит типу `DetailedOrder`.

[!code-csharp[DetailedOrder](../../../samples/core/Modeling/OwnedEntities/DetailedOrder.cs?name=DetailedOrder)]

[!code-csharp[OrderStatus](../../../samples/core/Modeling/OwnedEntities/OrderStatus.cs?name=OrderStatus)]

Каждый переход к принадлежащему типу определяет отдельный тип сущности с полностью независимой конфигурацией.

Помимо вложенных принадлежащих типов, принадлежащий тип может ссылаться на обычную сущность, он может быть либо владельцем, либо другой сущностью при условии, что принадлежащая сущность находится на зависимой стороне. Эта возможность задает собственные типы сущностей, кроме сложных типов в EF6.

[!code-csharp[OrderDetails](../../../samples/core/Modeling/OwnedEntities/OrderDetails.cs?name=OrderDetails)]

Можно связать метод `OwnsOne` в вызове Fluent, чтобы настроить эту модель:

[!code-csharp[OwnsOneNested](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsOneNested)]

Обратите внимание на `WithOwner` вызов, используемый для настройки свойства навигации, указывающего на владельца. Чтобы настроить навигацию на тип сущности Owner, не являющийся частью отношения владения, `WithOwner()` следует вызывать без аргументов.

Результат можно получить с помощью `OwnedAttribute` как в `OrderDetails`, так и в `StreetAddress`.

## <a name="storing-owned-types-in-separate-tables"></a>Хранение принадлежащих типов в отдельных таблицах

Кроме того, в отличие от сложных типов EF6, принадлежащие типы могут храниться в отдельной таблице от владельца. Чтобы переопределить соглашение, которое сопоставляет принадлежащий тип с той же таблицей, что и владелец, можно просто вызвать `ToTable` и указать другое имя таблицы. В следующем примере сопоставляется `OrderDetails` и его два адреса в отдельную таблицу из `DetailedOrder`:

[!code-csharp[OwnsOneTable](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsOneTable)]

Можно также использовать `TableAttribute` для выполнения этой задачи, но обратите внимание, что это приведет к сбою, если существует несколько переходов к принадлежащему типу, так как в этом случае несколько типов сущностей будут сопоставлены с одной и той же таблицей.

## <a name="querying-owned-types"></a>Запросы к собственным типам

При запросе владельца принадлежащие типы включаются по умолчанию. Не обязательно использовать метод `Include`, даже если принадлежащие типы хранятся в отдельной таблице. В зависимости от модели, описанной ранее, следующий запрос получит `Order`, `OrderDetails` и два принадлежащих `StreetAddresses` из базы данных:

[!code-csharp[DetailedOrderQuery](../../../samples/core/Modeling/OwnedEntities/Program.cs?name=DetailedOrderQuery)]

## <a name="limitations"></a>Ограничения

Некоторые из этих ограничений основаны на принципах работы собственных типов сущностей, но некоторые другие являются ограничениями, которые можно удалить в следующих выпусках:

### <a name="by-design-restrictions"></a>Ограничения по проектированию

- Нельзя создать `DbSet<T>` для принадлежащего типа
- Нельзя вызвать `Entity<T>()` с собственным типом в `ModelBuilder`

### <a name="current-shortcomings"></a>Текущие недостатки

- Собственные типы сущностей не могут иметь иерархии наследования
- Ссылки на навигационные типы сущностей не могут иметь значение null, если они явно не сопоставлены с отдельной таблицей от владельца
- Экземпляры собственных типов сущностей не могут совместно использоваться несколькими владельцами (это хорошо известный сценарий для объектов значений, которые не могут быть реализованы с помощью собственных типов сущностей).

### <a name="shortcomings-in-previous-versions"></a>Недостатки в предыдущих версиях

- В EF Core 2,0 переходы к собственным типам сущностей не могут быть объявлены в производных типах сущностей, если только принадлежащие сущности не были явно сопоставлены с отдельной таблицей из иерархии владельца. Это ограничение было удалено в EF Core 2,1
- В EF Core 2,0 и 2,1 поддерживались только навигационные ссылки на собственные типы. Это ограничение было удалено в EF Core 2,2
