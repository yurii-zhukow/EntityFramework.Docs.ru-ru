---
title: Связи — EF Core
description: Настройка связей между типами сущностей при использовании Entity Framework Core
author: AndriySvyryd
ms.date: 10/01/2020
uid: core/modeling/relationships
ms.openlocfilehash: 93d129435a3583ac5f741cc27952fb702f415a01
ms.sourcegitcommit: 7700840119b1639275f3b64836e7abb59103f2e7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/28/2021
ms.locfileid: "98983473"
---
# <a name="relationships"></a>Отношения

Связь определяет, как две сущности связаны друг с другом. В реляционной базе данных это представление представляется ограничением внешнего ключа.

> [!NOTE]
> Большинство примеров в этой статье используют связь «один ко многим» для демонстрации концепций. Примеры связей "один к одному" и "многие ко многим" см. в разделе [другие шаблоны связей](#other-relationship-patterns) в конце статьи.

## <a name="definition-of-terms"></a>Определение терминов

Существует ряд терминов, используемых для описания связей.

* **Зависимая сущность:** Это сущность, содержащая свойства внешнего ключа. Иногда называется "дочерним" отношением.

* **Сущность субъекта:** Это сущность, содержащая свойства первичного или альтернативного ключа. Иногда называется "родителем" связи.

* **Основной ключ:** Свойства, однозначно идентифицирующие сущность Principal. Это может быть первичный ключ или альтернативный ключ.

* **Внешний ключ:** Свойства в зависимой сущности, используемые для хранения значений основных ключей для связанной сущности.

* **Свойство навигации:** Свойство, определенное для основной и (или) зависимой сущности, ссылающейся на связанную сущность.

  * **Свойство навигации коллекции:** Свойство навигации, содержащее ссылки на множество связанных сущностей.

  * **Свойство навигации по ссылке:** Свойство навигации, содержащее ссылку на одну связанную сущность.

  * **Обратное свойство навигации:** При обсуждении определенного свойства навигации этот термин относится к свойству навигации на другом конце связи.

* **Связь, ссылающаяся на себя:** Связь, в которой зависимые и основные типы сущностей совпадают.

В следующем коде показана связь «один ко многим» между `Blog` и `Post`

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/Relationships/Full.cs#Full)]

* `Post` является зависимой сущностью

* `Blog` является основной сущностью

* `Blog.BlogId` является основным ключом (в данном случае это первичный ключ, а не альтернативный ключ);

* `Post.BlogId` является внешним ключом

* `Post.Blog` является свойством навигации по ссылке

* `Blog.Posts` — Это свойство навигации коллекции

* `Post.Blog` Свойство обратной навигации `Blog.Posts` (и наоборот)

## <a name="conventions"></a>Соглашения

По умолчанию связь будет создана при обнаружении свойства навигации для типа. Свойство считается свойством навигации, если тип, на который он указывает, не может быть сопоставлен с текущим поставщиком базы данных как скалярный тип.

> [!NOTE]
> Связи, обнаруженные соглашением, всегда будут указывать первичный ключ основной сущности. Чтобы выбрать альтернативный ключ, необходимо выполнить дополнительную настройку с помощью API Fluent.

### <a name="fully-defined-relationships"></a>Полностью определенные связи

Наиболее распространенным шаблоном для связей является наличие свойств навигации, определенных на обоих концах связи, и свойства внешнего ключа, определенного в зависимом классе сущности.

* Если между двумя типами обнаружена пара свойств навигации, они будут настроены как обратные свойства навигации одной и той же связи.

* Если зависимая сущность содержит свойство с именем, соответствующим одному из этих шаблонов, оно будет настроено как внешний ключ:
  * `<navigation property name><principal key property name>`
  * `<navigation property name>Id`
  * `<principal entity name><principal key property name>`
  * `<principal entity name>Id`

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/Relationships/Full.cs?name=Full&highlight=6,15-16)]

В этом примере выделенные свойства будут использоваться для настройки связи.

> [!NOTE]
> Если свойство является первичным ключом или имеет тип, несовместимый с ключом субъекта, он не будет настроен в качестве внешнего ключа.

> [!NOTE]
> До EF Core 3,0 свойство с именем, точно совпадающее со свойством ключа субъекта, [также было сопоставлено с внешним ключом](https://github.com/dotnet/efcore/issues/13274) .

### <a name="no-foreign-key-property"></a>Нет свойства внешнего ключа

Хотя рекомендуется использовать свойство внешнего ключа, определенное в зависимом классе сущности, оно не является обязательным. Если свойство внешнего ключа не найдено, [свойство теневого внешнего ключа](xref:core/modeling/shadow-properties) будет вводиться с именем или, `<navigation property name><principal key property name>` `<principal entity name><principal key property name>` Если в зависимом типе отсутствует Навигация.

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/Relationships/NoForeignKey.cs?name=NoForeignKey&highlight=6,15)]

В этом примере теневым внешним ключом является то, `BlogId` что предожидание имени навигации будет избыточным.

> [!NOTE]
> Если свойство с таким именем уже существует, имя теневого свойства будет суффиксом с номером.

### <a name="single-navigation-property"></a>Одно свойство навигации

Включение только одного свойства навигации (без обратной навигации и свойства внешнего ключа) достаточно для того, чтобы иметь связь, определенную по соглашению. Можно также иметь одно свойство навигации и внешнее ключевое свойство.

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/Relationships/OneNavigation.cs?name=OneNavigation&highlight=6)]

### <a name="limitations"></a>Ограничения

Если между двумя типами определено несколько свойств навигации (то есть более одной пары переходов, которые указывают друг на друга), связи, представленные свойствами навигации, являются неоднозначными. Их необходимо настроить вручную для устранения неоднозначности.

### <a name="cascade-delete"></a>Каскадное удаление

По соглашению каскадное удаление будет установлено в *CASCADE* для требуемых связей и *клиентсетнулл* для необязательных связей. *CASCADE* означает также удаление зависимых сущностей. *Клиентсетнулл* означает, что зависимые сущности, которые не загружены в память, останутся неизменными и должны быть удалены вручную или обновлены, чтобы они указывали на действительную сущность Principal. Для сущностей, загруженных в память, EF Core попытается установить свойства внешнего ключа в значение null.

Различия между обязательными и дополнительными связями см. в разделе [обязательные и дополнительные связи](#required-and-optional-relationships) .

Дополнительные сведения о различных поведениях при удалении и значения по умолчанию, используемые по соглашению, см. в разделе [каскадное удаление](xref:core/saving/cascade-delete) .

## <a name="manual-configuration"></a>Настройка вручную

### <a name="fluent-api"></a>[Текучий API](#tab/fluent-api)

Чтобы настроить связь в API Fluent, начните с определения свойств навигации, составляющих связь. `HasOne` или `HasMany` определяет свойство навигации для типа сущности, на котором начинается настройка. Затем вы позвоните в цепочку `WithOne` или `WithMany` для поиска обратной навигации. `HasOne`/`WithOne`используются для свойств навигации по ссылке и `HasMany` / `WithMany` используются для свойств навигации по коллекциям.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/NoForeignKey.cs?name=NoForeignKey&highlight=8-10)]

### <a name="data-annotations"></a>[Заметки к данным](#tab/data-annotations)

Заметки к данным можно использовать для настройки способа связывания свойств навигации в зависимых и субъектах сущностей. Обычно это делается при наличии более одной пары свойств навигации между двумя типами сущностей.

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/Relationships/InverseProperty.cs?name=InverseProperty&highlight=20,23)]

> [!NOTE]
> [Обязательное значение] можно использовать только для свойств зависимой сущности, чтобы повлиять на требуемую связь. [Обязательное значение] в переходе от основной сущности обычно игнорируется, но может привести к тому, что сущность будет зависимой от нее.

> [!NOTE]
> Заметки к данным `[ForeignKey]` и `[InverseProperty]` доступны в `System.ComponentModel.DataAnnotations.Schema` пространстве имен. `[Required]` доступен в `System.ComponentModel.DataAnnotations` пространстве имен.

---

### <a name="single-navigation-property"></a>Одно свойство навигации

Если у вас есть только одно свойство навигации, то существуют перегрузки без параметров `WithOne` и `WithMany` . Это указывает на то, что на другом конце связи имеется концептуальная ссылка или коллекция, но в классе сущностей не содержится свойство навигации.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/OneNavigation.cs?name=OneNavigation&highlight=8-10)]

---

### <a name="configuring-navigation-properties"></a>Настройка свойств навигации

> [!NOTE]
> Эта возможность появилась в EF Core 5.0.

После создания свойства навигации может потребоваться его дальнейшая настройка.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/NavigationConfiguration.cs?name=NavigationConfiguration&highlight=7-9)]

> [!NOTE]
> Этот вызов нельзя использовать для создания свойства навигации. Он используется только для настройки свойства навигации, которое было ранее создано путем определения связи или соглашения.

### <a name="foreign-key"></a>Внешний ключ

#### <a name="fluent-api-simple-key"></a>[API Fluent (простой ключ)](#tab/fluent-api-simple-key)

API-интерфейс Fluent можно использовать для настройки того, какое свойство должно использоваться в качестве свойства внешнего ключа для данной связи:

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/ForeignKey.cs?name=ForeignKey&highlight=11)]

#### <a name="fluent-api-composite-key"></a>[API Fluent (составной ключ)](#tab/fluent-api-composite-key)

API-интерфейс Fluent можно использовать для настройки свойств, которые должны использоваться в качестве свойств составного внешнего ключа для данной связи.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/CompositeForeignKey.cs?name=CompositeForeignKey&highlight=13)]

#### <a name="data-annotations-simple-key"></a>[Заметки к данным (простой ключ)](#tab/data-annotations-simple-key)

Заметки к данным можно использовать для настройки того, какое свойство должно использоваться в качестве свойства внешнего ключа для данной связи. Обычно это делается, когда свойство внешнего ключа не обнаруживается по соглашению:

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/Relationships/ForeignKey.cs?name=ForeignKey&highlight=17)]

> [!TIP]
> `[ForeignKey]`Заметку можно поместить в любое свойство навигации в связи. Не требуется переходить к свойству навигации в классе зависимой сущности.

> [!NOTE]
> Свойство, указанное с помощью `[ForeignKey]` в свойстве навигации, не обязательно должно существовать в зависимом типе. В этом случае для создания теневого внешнего ключа будет использоваться указанное имя.

---

#### <a name="shadow-foreign-key"></a>Теневой внешний ключ

`HasForeignKey(...)`Чтобы настроить свойство теневого копирования в качестве внешнего ключа, можно использовать строку перегрузки в. Дополнительные сведения см. в разделе [Свойства тени](xref:core/modeling/shadow-properties) . Рекомендуется явно добавить свойство Shadow в модель, прежде чем использовать ее как внешний ключ (как показано ниже).

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/ShadowForeignKey.cs?name=ShadowForeignKey&highlight=10,16)]

#### <a name="foreign-key-constraint-name"></a>Имя ограничения внешнего ключа

По соглашению при нацеливании на реляционную базу данных ограничения внешнего ключа называются FK \_ \<dependent type name> \_ \<principal type name> \_ \<foreign key property name> . Для составных внешних ключей \<foreign key property name> преобразуется в список имен свойств внешнего ключа с разделителями подчеркивания.

Имя ограничения также можно настроить следующим образом:

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/ConstraintName.cs?name=ConstraintName&highlight=6-7)]

### <a name="without-navigation-property"></a>Без свойства навигации

Указывать свойство навигации не обязательно. Можно просто предоставить внешний ключ на одной стороне связи.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/NoNavigation.cs?name=NoNavigation&highlight=8-11)]

### <a name="principal-key"></a>Основной ключ

Если требуется, чтобы внешний ключ ссылался на свойство, отличное от первичного ключа, можно использовать API Fluent, чтобы настроить свойство ключа субъекта для связи. Свойство, настраиваемое в качестве ключа участника, будет автоматически настроено в качестве [альтернативного ключа](xref:core/modeling/keys#alternate-keys).

#### <a name="simple-key"></a>[Простой ключ](#tab/simple-key)

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/PrincipalKey.cs?name=PrincipalKey&highlight=11)]

#### <a name="composite-key"></a>[Составной ключ](#tab/composite-key)

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/CompositePrincipalKey.cs?name=CompositePrincipalKey&highlight=11)]

> [!WARNING]
> Порядок указания свойств ключа субъекта должен совпадать с порядком, в котором они указаны для внешнего ключа.

---

### <a name="required-and-optional-relationships"></a>Обязательные и необязательные связи

С помощью API-интерфейса Fluent можно настроить, является ли связь обязательной или необязательной. В конечном итоге это определяет, является ли свойство внешнего ключа обязательным или необязательным. Это наиболее полезно при использовании внешнего ключа теневого состояния. Если у вас есть свойство внешнего ключа в классе сущностей, обязательность связи определяется на основе того, является ли свойство внешнего ключа обязательным или необязательным (Дополнительные сведения см. в разделе [обязательные и необязательные свойства](xref:core/modeling/entity-properties#required-and-optional-properties) ).

Свойства внешнего ключа размещаются на зависимом типе сущности, поэтому, если они настроены как обязательные, то каждая зависимая сущность должна иметь соответствующую основную сущность.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/Required.cs?name=Required&highlight=6)]

> [!NOTE]
> Вызов `IsRequired(false)` также делает свойство внешнего ключа необязательным, если оно не настроено в противном случае.

### <a name="cascade-delete"></a>Каскадное удаление

Для явной настройки поведения каскадного удаления для данной связи можно использовать API Fluent.

Подробное описание каждого варианта см. в разделе [каскадное удаление](xref:core/saving/cascade-delete) .

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/CascadeDelete.cs?name=CascadeDelete&highlight=6)]

## <a name="other-relationship-patterns"></a>Другие шаблоны отношений

### <a name="one-to-one"></a>"Одна к одной"

Связь «один к одному» имеет свойство навигации «ссылка» на обеих сторонах. Они следуют тем же соглашениям, что и отношения "один ко многим", но уникальный индекс вводится в свойство внешнего ключа, чтобы гарантировать, что только один зависимый объект связан с каждым участником.

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/Relationships/OneToOne.cs?name=OneToOne&highlight=6,15-16)]

> [!NOTE]
> EF выберет одну из сущностей, которая будет зависимой, исходя из возможности обнаружения свойства внешнего ключа. Если в качестве зависимого объекта выбрана неверная сущность, можно исправить это с помощью API-интерфейса Fluent.

При настройке связи с помощью API-интерфейса Fluent вы используете `HasOne` методы и `WithOne` .

При настройке внешнего ключа необходимо указать тип зависимой сущности — Обратите внимание на универсальный параметр, предоставленный `HasForeignKey` в приведенном ниже списке. В связи «один ко многим» ясно, что сущность с навигацией по ссылке является зависимой, а она является участником коллекции. Но это не так в связи «один к одному», поэтому необходимо явно определить его.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/OneToOne.cs?name=OneToOne&highlight=11)]

Зависимая сторона считается необязательной по умолчанию, но может быть настроена в соответствии с требованиями. Однако EF не будет проверять, предоставлена ли зависимая сущность, поэтому эта конфигурация будет иметь различие, только если сопоставление базы данных допускает принудительное применение. Распространенный сценарий для этого — принадлежащие типам ссылки, которые по умолчанию используют Разбиение таблицы.

[!code-csharp[Main](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=Required&highlight=11-12)]

В этой конфигурации столбцы, соответствующие, `ShippingAddress` будут помечены в базе данных как не допускающие значения NULL.

> [!NOTE]
> При использовании [ссылочных типов, не допускающих значения NULL](/dotnet/csharp/nullable-references) , вызов `IsRequired` не требуется.

> [!NOTE]
> Возможность настройки того, является ли зависимый объект обязательным, появился в EF Core 5,0.

### <a name="many-to-many"></a>"Много ко многим"

Для связи "многие ко многим" требуется свойство навигации коллекции на обеих сторонах. Они будут обнаружены по соглашению, как и другие типы отношений.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/ManyToManyShared.cs?name=ManyToManyShared)]

Способ реализации этой связи в базе данных заключается в таблице JOIN, содержащей внешние ключи и в, и в `Post` `Tag` . Например, это то, что EF будет создаваться в реляционной базе данных для указанной выше модели.

```sql
CREATE TABLE [Posts] (
    [PostId] int NOT NULL IDENTITY,
    [Title] nvarchar(max) NULL,
    [Content] nvarchar(max) NULL,
    CONSTRAINT [PK_Posts] PRIMARY KEY ([PostId])
);

CREATE TABLE [Tags] (
    [TagId] nvarchar(450) NOT NULL,
    CONSTRAINT [PK_Tags] PRIMARY KEY ([TagId])
);

CREATE TABLE [PostTag] (
    [PostsId] int NOT NULL,
    [TagsId] nvarchar(450) NOT NULL,
    CONSTRAINT [PK_PostTag] PRIMARY KEY ([PostsId], [TagsId]),
    CONSTRAINT [FK_PostTag_Posts_PostsId] FOREIGN KEY ([PostsId]) REFERENCES [Posts] ([PostId]) ON DELETE CASCADE,
    CONSTRAINT [FK_PostTag_Tags_TagsId] FOREIGN KEY ([TagsId]) REFERENCES [Tags] ([TagId]) ON DELETE CASCADE
);
```

На внутреннем уровне EF создает тип сущности для представления соединяемой таблицы, которая будет называться типом сущности JOIN. `Dictionary<string, object>` в настоящее время используется для управления любым сочетанием свойств внешнего ключа. Дополнительные сведения см. в разделе [типы сущностей контейнера свойств](shadow-properties.md#property-bag-entity-types) . В модели может существовать несколько связей "многие-ко-многим", поэтому в этом случае типу сущности JOIN должно быть присвоено уникальное имя `PostTag` . Функция, которая разрешает это, называется типом сущности общего типа.

> [!IMPORTANT]
> Тип CLR, используемый для объединения типов сущностей по соглашению, может измениться в будущих выпусках для повышения производительности. Не зависят от типа объединения, `Dictionary<string, object>` если он не был явно настроен, как описано в следующем разделе.

Многие ко многим переходам называются пропустить навигацию, так как они фактически пропускают тип сущности JOIN. При использовании групповой конфигурации все переходы по пропустить можно получить из <xref:Microsoft.EntityFrameworkCore.Metadata.IEntityType.GetSkipNavigations%2A> .

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/ManyToManyShared.cs?name=Metadata)]

#### <a name="join-entity-type-configuration"></a>Соединение конфигурации типа сущности

Обычно конфигурация применяется к типу сущности JOIN. Это действие можно выполнить с помощью `UsingEntity` .

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/ManyToManyShared.cs?name=SharedConfiguration)]

[Данные начального значения модели](xref:core/modeling/data-seeding) могут быть предоставлены для типа сущности JOIN с помощью анонимных типов. Можно проверить представление Отладка модели, чтобы определить имена свойств, созданных по соглашению.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/ManyToManyShared.cs?name=Seeding)]

Дополнительные данные могут храниться в типе сущности JOIN, но для этого лучше создать собственный тип CLR. При настройке связи с типом сущности пользовательского объединения необходимо явно указать оба внешних ключа.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/ManyToManyPayload.cs?name=ManyToManyPayload)]

#### <a name="joining-relationships-configuration"></a>Настройка связей соединения

EF использует связи 2 1-ко-многим в типе сущности Join для представления связи «многие ко многим». Эти связи можно настроить в `UsingEntity` аргументах.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/ManyToManyShared.cs?name=Components)]

> [!NOTE]
> Возможность настройки связей "многие ко многим" появилась в EF Core 5,0, для предыдущей версии используется следующий подход.

#### <a name="indirect-many-to-many-relationships"></a>Косвенные связи "многие ко многим"

Можно также представить связь «многие ко многим», просто добавив тип сущности «соединение» и сопоставив две отдельные связи «один ко многим».

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/ManyToMany.cs?name=ManyToMany&highlight=16-19,21-24)]

> [!NOTE]
> Поддержка формирования шаблонов для связей "многие ко многим" из базы данных еще не добавлена. Отслеживайте решение этого вопроса [здесь](https://github.com/dotnet/efcore/issues/22475).

## <a name="additional-resources"></a>Дополнительные ресурсы

* [EF Core сеансе сообщества standup](https://www.youtube.com/watch?v=W1sxepfIMRM&list=PLdo4fOcmZ0oX-DBuRG4u58ZTAJgBAeQ-t&index=32), в котором подробно рассматриваются многие ко многим и инфраструктуре лежащая ИТ.
