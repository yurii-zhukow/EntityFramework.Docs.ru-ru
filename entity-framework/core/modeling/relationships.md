---
title: Связи — EF Core
description: Настройка связей между типами сущностей при использовании Entity Framework Core
author: AndriySvyryd
ms.date: 11/21/2019
uid: core/modeling/relationships
ms.openlocfilehash: 927457c2a5b5ef4a5061fe2e5d28f864eb95c55f
ms.sourcegitcommit: 949faaba02e07e44359e77d7935f540af5c32093
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/03/2020
ms.locfileid: "87526736"
---
# <a name="relationships"></a>Отношения

Связь определяет, как две сущности связаны друг с другом. В реляционной базе данных это представление представляется ограничением внешнего ключа.

> [!NOTE]  
> Большинство примеров в этой статье используют связь «один ко многим» для демонстрации концепций. Примеры связей "один к одному" и "многие ко многим" см. в разделе [другие шаблоны связей](#other-relationship-patterns) в конце статьи.

## <a name="definition-of-terms"></a>Определение терминов

Существует ряд терминов, используемых для описания связей.

* **Зависимая сущность:** Это сущность, содержащая свойства внешнего ключа. Иногда называется "дочерним" отношением.

* **Сущность субъекта:** Это сущность, содержащая свойства первичного или альтернативного ключа. Иногда называется "родителем" связи.

* **Основной ключ:** Свойства, однозначно идентифицирующие сущность Principal. Это может быть первичный ключ или альтернативный ключ.

* **Внешний ключ:** Свойства в зависимой сущности, используемые для хранения значений основных ключей для связанной сущности.

* **Свойство навигации:** Свойство, определенное для основной и (или) зависимой сущности, ссылающейся на связанную сущность.

  * **Свойство навигации коллекции:** Свойство навигации, содержащее ссылки на множество связанных сущностей.

  * **Свойство навигации по ссылке:** Свойство навигации, содержащее ссылку на одну связанную сущность.

  * **Обратное свойство навигации:** При обсуждении определенного свойства навигации этот термин относится к свойству навигации на другом конце связи.
  
* **Связь, ссылающаяся на себя:** Связь, в которой зависимые и основные типы сущностей совпадают.

В следующем коде показана связь «один ко многим» между `Blog` и`Post`

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/Relationships/Full.cs#Full)]

* `Post`является зависимой сущностью

* `Blog`является основной сущностью

* `Blog.BlogId`является основным ключом (в данном случае это первичный ключ, а не альтернативный ключ);

* `Post.BlogId`является внешним ключом

* `Post.Blog`является свойством навигации по ссылке

* `Blog.Posts`— Это свойство навигации коллекции

* `Post.Blog`Свойство обратной навигации `Blog.Posts` (и наоборот)

## <a name="conventions"></a>Соглашения

По умолчанию связь будет создана при обнаружении свойства навигации для типа. Свойство считается свойством навигации, если тип, на который он указывает, не может быть сопоставлен с текущим поставщиком базы данных как скалярный тип.

> [!NOTE]  
> Связи, обнаруженные соглашением, всегда будут указывать первичный ключ основной сущности. Чтобы выбрать альтернативный ключ, необходимо выполнить дополнительную настройку с помощью API Fluent.

### <a name="fully-defined-relationships"></a>Полностью определенные связи

Наиболее распространенным шаблоном для связей является наличие свойств навигации, определенных на обоих концах связи, и свойства внешнего ключа, определенного в зависимом классе сущности.

* Если между двумя типами обнаружена пара свойств навигации, они будут настроены как обратные свойства навигации одной и той же связи.

* Если зависимая сущность содержит свойство с именем, соответствующим одному из этих шаблонов, оно будет настроено как внешний ключ:
  * `<navigation property name><principal key property name>`
  * `<navigation property name>Id`
  * `<principal entity name><principal key property name>`
  * `<principal entity name>Id`

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/Relationships/Full.cs?name=Full&highlight=6,15-16)]

В этом примере выделенные свойства будут использоваться для настройки связи.

> [!NOTE]
> Если свойство является первичным ключом или имеет тип, несовместимый с ключом субъекта, он не будет настроен в качестве внешнего ключа.

> [!NOTE]
> До EF Core 3,0 свойство с именем, точно совпадающее со свойством ключа субъекта, [также было сопоставлено с внешним ключом](https://github.com/aspnet/EntityFrameworkCore/issues/13274) .

### <a name="no-foreign-key-property"></a>Нет свойства внешнего ключа

Хотя рекомендуется использовать свойство внешнего ключа, определенное в зависимом классе сущности, оно не является обязательным. Если свойство внешнего ключа не найдено, [свойство теневого внешнего ключа](shadow-properties.md) будет вводиться с именем или, `<navigation property name><principal key property name>` `<principal entity name><principal key property name>` Если в зависимом типе отсутствует Навигация.

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/Relationships/NoForeignKey.cs?name=NoForeignKey&highlight=6,15)]

В этом примере теневым внешним ключом является то, `BlogId` что предожидание имени навигации будет избыточным.

> [!NOTE]
> Если свойство с таким именем уже существует, имя теневого свойства будет суффиксом с номером.

### <a name="single-navigation-property"></a>Одно свойство навигации

Включение только одного свойства навигации (без обратной навигации и свойства внешнего ключа) достаточно для того, чтобы иметь связь, определенную по соглашению. Можно также иметь одно свойство навигации и внешнее ключевое свойство.

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/Relationships/OneNavigation.cs?name=OneNavigation&highlight=6)]

### <a name="limitations"></a>Ограничения

Если между двумя типами определено несколько свойств навигации (то есть более одной пары переходов, которые указывают друг на друга), связи, представленные свойствами навигации, являются неоднозначными. Их необходимо настроить вручную для устранения неоднозначности.

### <a name="cascade-delete"></a>Каскадное удаление

По соглашению каскадное удаление будет установлено в *CASCADE* для требуемых связей и *клиентсетнулл* для необязательных связей. *CASCADE* означает также удаление зависимых сущностей. *Клиентсетнулл* означает, что зависимые сущности, которые не загружены в память, останутся неизменными и должны быть удалены вручную или обновлены, чтобы они указывали на действительную сущность Principal. Для сущностей, загруженных в память, EF Core попытается установить свойства внешнего ключа в значение null.

Различия между обязательными и дополнительными связями см. в разделе [обязательные и дополнительные связи](#required-and-optional-relationships) .

Дополнительные сведения о различных поведениях при удалении и значения по умолчанию, используемые по соглашению, см. в разделе [каскадное удаление](../saving/cascade-delete.md) .

## <a name="manual-configuration"></a>Настройка вручную

### <a name="fluent-api"></a>[Текучий API](#tab/fluent-api)

Чтобы настроить связь в API Fluent, начните с определения свойств навигации, составляющих связь. `HasOne`или `HasMany` определяет свойство навигации для типа сущности, на котором начинается настройка. Затем вы позвоните в цепочку `WithOne` или `WithMany` для поиска обратной навигации. `HasOne`/`WithOne`используются для свойств навигации по ссылке и `HasMany` / `WithMany` используются для свойств навигации по коллекциям.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/NoForeignKey.cs?name=NoForeignKey&highlight=8-10)]

### <a name="data-annotations"></a>[Заметки к данным](#tab/data-annotations)

Заметки к данным можно использовать для настройки способа связывания свойств навигации в зависимых и субъектах сущностей. Обычно это делается при наличии более одной пары свойств навигации между двумя типами сущностей.

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/Relationships/InverseProperty.cs?name=InverseProperty&highlight=20,23)]

> [!NOTE]
> [Обязательное значение] можно использовать только для свойств зависимой сущности, чтобы повлиять на требуемую связь. [Обязательное значение] в переходе от основной сущности обычно игнорируется, но может привести к тому, что сущность будет зависимой от нее.

> [!NOTE]
> Заметки к данным `[ForeignKey]` и `[InverseProperty]` доступны в `System.ComponentModel.DataAnnotations.Schema` пространстве имен. `[Required]`доступен в `System.ComponentModel.DataAnnotations` пространстве имен.

---

### <a name="single-navigation-property"></a>Одно свойство навигации

Если у вас есть только одно свойство навигации, то существуют перегрузки без параметров `WithOne` и `WithMany` . Это указывает на то, что на другом конце связи имеется концептуальная ссылка или коллекция, но в классе сущностей не содержится свойство навигации.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/OneNavigation.cs?name=OneNavigation&highlight=8-10)]

---

### <a name="configuring-navigation-properties"></a>Настройка свойств навигации

После создания свойства навигации может потребоваться его дальнейшая настройка. В Ефкоре 5,0 добавлен новый API-интерфейс Fluent, позволяющий выполнить эту настройку.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/NavigationConfiguration.cs?name=NavigationConfiguration&highlight=7-9)]

> [!NOTE]
> Этот вызов нельзя использовать для создания свойства навигации. Он используется только для настройки свойства навигации, которое было ранее создано путем определения связи или соглашения.

### <a name="foreign-key"></a>Внешний ключ

#### <a name="fluent-api-simple-key"></a>[API Fluent (простой ключ)](#tab/fluent-api-simple-key)

API-интерфейс Fluent можно использовать для настройки того, какое свойство должно использоваться в качестве свойства внешнего ключа для данной связи:

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/ForeignKey.cs?name=ForeignKey&highlight=11)]

#### <a name="fluent-api-composite-key"></a>[API Fluent (составной ключ)](#tab/fluent-api-composite-key)

API-интерфейс Fluent можно использовать для настройки свойств, которые должны использоваться в качестве свойств составного внешнего ключа для данной связи.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/CompositeForeignKey.cs?name=CompositeForeignKey&highlight=13)]

#### <a name="data-annotations-simple-key"></a>[Заметки к данным (простой ключ)](#tab/data-annotations-simple-key)

Заметки к данным можно использовать для настройки того, какое свойство должно использоваться в качестве свойства внешнего ключа для данной связи. Обычно это делается, когда свойство внешнего ключа не обнаруживается по соглашению:

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/Relationships/ForeignKey.cs?name=ForeignKey&highlight=17)]

> [!TIP]  
> `[ForeignKey]`Заметку можно поместить в любое свойство навигации в связи. Не требуется переходить к свойству навигации в классе зависимой сущности.

> [!NOTE]
> Свойство, указанное с помощью `[ForeignKey]` в свойстве навигации, не обязательно должно существовать в зависимом типе. В этом случае для создания теневого внешнего ключа будет использоваться указанное имя.

---

#### <a name="shadow-foreign-key"></a>Теневой внешний ключ

`HasForeignKey(...)`Чтобы настроить свойство теневого копирования в качестве внешнего ключа, можно использовать строку перегрузки в. Дополнительные сведения см. в разделе [Свойства тени](shadow-properties.md) . Рекомендуется явно добавить свойство Shadow в модель, прежде чем использовать ее как внешний ключ (как показано ниже).

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/ShadowForeignKey.cs?name=ShadowForeignKey&highlight=10,16)]

#### <a name="foreign-key-constraint-name"></a>Имя ограничения внешнего ключа

По соглашению при нацеливании на реляционную базу данных ограничения внешнего ключа именуются FK_ <dependent type name> _<principal type name>_ <foreign key property name> . Для составных внешних ключей <foreign key property name> преобразуется в список имен свойств внешнего ключа с разделителями подчеркивания.

Имя ограничения также можно настроить следующим образом:

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/ConstraintName.cs?name=ConstraintName&highlight=6-7)]

### <a name="without-navigation-property"></a>Без свойства навигации

Указывать свойство навигации не обязательно. Можно просто предоставить внешний ключ на одной стороне связи.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/NoNavigation.cs?name=NoNavigation&highlight=8-11)]

### <a name="principal-key"></a>Основной ключ

Если требуется, чтобы внешний ключ ссылался на свойство, отличное от первичного ключа, можно использовать API Fluent, чтобы настроить свойство ключа субъекта для связи. Свойство, настраиваемое в качестве ключа участника, будет автоматически настроено в качестве [альтернативного ключа](alternate-keys.md).

#### <a name="simple-key"></a>[Простой ключ](#tab/simple-key)

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/PrincipalKey.cs?name=PrincipalKey&highlight=11)]

#### <a name="composite-key"></a>[Составной ключ](#tab/composite-key)

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/CompositePrincipalKey.cs?name=CompositePrincipalKey&highlight=11)]

> [!WARNING]  
> Порядок указания свойств ключа субъекта должен совпадать с порядком, в котором они указаны для внешнего ключа.

---

### <a name="required-and-optional-relationships"></a>Обязательные и необязательные связи

С помощью API-интерфейса Fluent можно настроить, является ли связь обязательной или необязательной. В конечном итоге это определяет, является ли свойство внешнего ключа обязательным или необязательным. Это наиболее полезно при использовании внешнего ключа теневого состояния. Если у вас есть свойство внешнего ключа в классе сущностей, обязательность связи определяется на основе того, является ли свойство внешнего ключа обязательным или необязательным (Дополнительные сведения см. в разделе [обязательные и необязательные свойства](required-optional.md) ).

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/Required.cs?name=Required&highlight=6)]

> [!NOTE]
> Вызов `IsRequired(false)` также делает свойство внешнего ключа необязательным, если оно не настроено в противном случае.

### <a name="cascade-delete"></a>Каскадное удаление

Для явной настройки поведения каскадного удаления для данной связи можно использовать API Fluent.

Подробное описание каждого варианта см. в разделе [каскадное удаление](../saving/cascade-delete.md) .

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/CascadeDelete.cs?name=CascadeDelete&highlight=6)]

## <a name="other-relationship-patterns"></a>Другие шаблоны отношений

### <a name="one-to-one"></a>Один к одному

Связь «один к одному» имеет свойство навигации «ссылка» на обеих сторонах. Они следуют тем же соглашениям, что и отношения "один ко многим", но уникальный индекс вводится в свойство внешнего ключа, чтобы гарантировать, что только один зависимый объект связан с каждым участником.

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/Relationships/OneToOne.cs?name=OneToOne&highlight=6,15-16)]

> [!NOTE]  
> EF выберет одну из сущностей, которая будет зависимой, исходя из возможности обнаружения свойства внешнего ключа. Если в качестве зависимого объекта выбрана неверная сущность, можно исправить это с помощью API-интерфейса Fluent.

При настройке связи с помощью API-интерфейса Fluent вы используете `HasOne` методы и `WithOne` .

При настройке внешнего ключа необходимо указать тип зависимой сущности — Обратите внимание на универсальный параметр, предоставленный `HasForeignKey` в приведенном ниже списке. В связи «один ко многим» ясно, что сущность с навигацией по ссылке является зависимой, а она является участником коллекции. Но это не так в связи «один к одному», поэтому необходимо явно определить его.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/OneToOne.cs?name=OneToOne&highlight=11)]

### <a name="many-to-many"></a>"Многие ко многим"

Связи «многие ко многим» без класса сущности для представления таблицы соединений пока не поддерживаются. Однако можно представить связь «многие ко многим», включив класс сущности для таблицы Join и составляя две отдельные связи «один ко многим».

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/ManyToMany.cs?name=ManyToMany&highlight=11-14,16-19,39-46)]
