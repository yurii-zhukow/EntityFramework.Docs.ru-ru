---
title: Связи — EF Core
description: Настройка связей между типами сущностей при использовании Entity Framework Core
author: AndriySvyryd
ms.date: 11/21/2019
uid: core/modeling/relationships
ms.openlocfilehash: 6d68e813cec6c989e8e4cb848f8740489645c65c
ms.sourcegitcommit: 89567d08c9d8bf9c33bb55a62f17067094a4065a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/06/2020
ms.locfileid: "77051411"
---
# <a name="relationships"></a>Связи

Связь определяет, как две сущности связаны друг с другом. В реляционной базе данных это представление представляется ограничением внешнего ключа.

> [!NOTE]  
> Большинство примеров в этой статье используют связь «один ко многим» для демонстрации концепций. Примеры связей "один к одному" и "многие ко многим" см. в разделе [другие шаблоны связей](#other-relationship-patterns) в конце статьи.

## <a name="definition-of-terms"></a>Определение терминов

Существует ряд терминов, используемых для описания связей.

* **Зависимая сущность:** Это сущность, содержащая свойства внешнего ключа. Иногда называется "дочерним" отношением.

* **Сущность субъекта:** Это сущность, содержащая свойства первичного или альтернативного ключа. Иногда называется "родителем" связи.

* **Основной ключ:** Свойства, однозначно идентифицирующие сущность Principal. Это может быть первичный ключ или альтернативный ключ.

* **Внешний ключ:** Свойства в зависимой сущности, используемые для хранения значений основных ключей для связанной сущности.

* **Свойство навигации:** Свойство, определенное для основной и (или) зависимой сущности, ссылающейся на связанную сущность.

  * **Свойство навигации коллекции:** Свойство навигации, содержащее ссылки на множество связанных сущностей.

  * **Свойство навигации по ссылке:** Свойство навигации, содержащее ссылку на одну связанную сущность.

  * **Обратное свойство навигации:** При обсуждении определенного свойства навигации этот термин относится к свойству навигации на другом конце связи.
  
* **Связь, ссылающаяся на себя:** Связь, в которой зависимые и основные типы сущностей совпадают.

В следующем коде показана связь «один ко многим» между `Blog` и `Post`

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/Relationships/Full.cs#Full)]

* `Post` является зависимой сущностью

* `Blog` является субъектом-участником

* `Blog.BlogId` является основным ключом (в данном случае это первичный ключ, а не альтернативный ключ);

* `Post.BlogId` является внешним ключом

* `Post.Blog` является свойством навигации по ссылке

* `Blog.Posts` является свойством навигации коллекции

* `Post.Blog` является свойством обратной навигации `Blog.Posts` (и наоборот)

## <a name="conventions"></a>Соглашения

По умолчанию связь будет создана при обнаружении свойства навигации для типа. Свойство считается свойством навигации, если тип, на который он указывает, не может быть сопоставлен с текущим поставщиком базы данных как скалярный тип.

> [!NOTE]  
> Связи, обнаруженные соглашением, всегда будут указывать первичный ключ основной сущности. Чтобы выбрать альтернативный ключ, необходимо выполнить дополнительную настройку с помощью API Fluent.

### <a name="fully-defined-relationships"></a>Полностью определенные связи

Наиболее распространенным шаблоном для связей является наличие свойств навигации, определенных на обоих концах связи, и свойства внешнего ключа, определенного в зависимом классе сущности.

* Если между двумя типами обнаружена пара свойств навигации, они будут настроены как обратные свойства навигации одной и той же связи.

* Если зависимая сущность содержит свойство с именем, соответствующим одному из этих шаблонов, оно будет настроено как внешний ключ:
  * `<navigation property name><principal key property name>`
  * `<navigation property name>Id`
  * `<principal entity name><principal key property name>`
  * `<principal entity name>Id`

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/Relationships/Full.cs?name=Full&highlight=6,15-16)]

В этом примере выделенные свойства будут использоваться для настройки связи.

> [!NOTE]
> Если свойство является первичным ключом или имеет тип, несовместимый с ключом субъекта, он не будет настроен в качестве внешнего ключа.

> [!NOTE]
> До EF Core 3,0 свойство с именем, точно совпадающее со свойством ключа субъекта, [также было сопоставлено с внешним ключом](https://github.com/aspnet/EntityFrameworkCore/issues/13274) .

### <a name="no-foreign-key-property"></a>Нет свойства внешнего ключа

Хотя рекомендуется использовать свойство внешнего ключа, определенное в зависимом классе сущности, оно не является обязательным. Если свойство внешнего ключа не найдено, [свойство теневого внешнего ключа](shadow-properties.md) будет введено с именем `<navigation property name><principal key property name>` или `<principal entity name><principal key property name>`, если в зависимом типе отсутствует Навигация.

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/Relationships/NoForeignKey.cs?name=NoForeignKey&highlight=6,15)]

В этом примере теневым внешним ключом является `BlogId`, так как имя навигации должно быть избыточным.

> [!NOTE]
> Если свойство с таким именем уже существует, имя теневого свойства будет суффиксом с номером.

### <a name="single-navigation-property"></a>Одно свойство навигации

Включение только одного свойства навигации (без обратной навигации и свойства внешнего ключа) достаточно для того, чтобы иметь связь, определенную по соглашению. Можно также иметь одно свойство навигации и внешнее ключевое свойство.

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/Relationships/OneNavigation.cs?name=OneNavigation&highlight=6)]

### <a name="limitations"></a>Ограничения

Если между двумя типами определено несколько свойств навигации (то есть более одной пары переходов, которые указывают друг на друга), связи, представленные свойствами навигации, являются неоднозначными. Их необходимо настроить вручную для устранения неоднозначности.

### <a name="cascade-delete"></a>Каскадное удаление

По соглашению каскадное удаление будет установлено в *CASCADE* для требуемых связей и *клиентсетнулл* для необязательных связей. *CASCADE* означает также удаление зависимых сущностей. *Клиентсетнулл* означает, что зависимые сущности, которые не загружены в память, останутся неизменными и должны быть удалены вручную или обновлены, чтобы они указывали на действительную сущность Principal. Для сущностей, загруженных в память, EF Core попытается установить свойства внешнего ключа в значение null.

Различия между обязательными и дополнительными связями см. в разделе [обязательные и дополнительные связи](#required-and-optional-relationships) .

Дополнительные сведения о различных поведениях при удалении и значения по умолчанию, используемые по соглашению, см. в разделе [каскадное удаление](../saving/cascade-delete.md) .

## <a name="manual-configuration"></a>Настройка вручную

### <a name="fluent-apitabfluent-api"></a>[API Fluent](#tab/fluent-api)

Чтобы настроить связь в API Fluent, начните с определения свойств навигации, составляющих связь. `HasOne` или `HasMany` определяет свойство навигации для типа сущности, на котором начинается настройка. Затем можно связать вызов `WithOne` или `WithMany`, чтобы обозначить обратную навигацию. `HasOne`/`WithOne` используются для свойств навигации по ссылке и `HasMany`/`WithMany` используются для свойств навигации по коллекциям.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/NoForeignKey.cs?name=NoForeignKey&highlight=8-10)]

### <a name="data-annotationstabdata-annotations"></a>[Заметки к данным](#tab/data-annotations)

Заметки к данным можно использовать для настройки способа связывания свойств навигации в зависимых и субъектах сущностей. Обычно это делается при наличии более одной пары свойств навигации между двумя типами сущностей.

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/Relationships/InverseProperty.cs?name=InverseProperty&highlight=20,23)]

> [!NOTE]
> [Обязательное значение] можно использовать только для свойств зависимой сущности, чтобы повлиять на требуемую связь. [Обязательное значение] в переходе от основной сущности обычно игнорируется, но может привести к тому, что сущность будет зависимой от нее.

> [!NOTE]
> Заметки к данным `[ForeignKey]` и `[InverseProperty]` доступны в пространстве имен `System.ComponentModel.DataAnnotations.Schema`. `[Required]` доступен в пространстве имен `System.ComponentModel.DataAnnotations`.

---

### <a name="single-navigation-property"></a>Одно свойство навигации

Если у вас есть только одно свойство навигации, то существуют перегрузки без параметров `WithOne` и `WithMany`. Это указывает на то, что на другом конце связи имеется концептуальная ссылка или коллекция, но в классе сущностей не содержится свойство навигации.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/OneNavigation.cs?name=OneNavigation&highlight=8-10)]

### <a name="foreign-key"></a>Внешний ключ

#### <a name="fluent-api-simple-keytabfluent-api-simple-key"></a>[API Fluent (простой ключ)](#tab/fluent-api-simple-key)

API-интерфейс Fluent можно использовать для настройки того, какое свойство должно использоваться в качестве свойства внешнего ключа для данной связи:

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/ForeignKey.cs?name=ForeignKey&highlight=11)]

#### <a name="fluent-api-composite-keytabfluent-api-composite-key"></a>[API Fluent (составной ключ)](#tab/fluent-api-composite-key)

API-интерфейс Fluent можно использовать для настройки свойств, которые должны использоваться в качестве свойств составного внешнего ключа для данной связи.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/CompositeForeignKey.cs?name=CompositeForeignKey&highlight=13)]

#### <a name="data-annotations-simple-keytabdata-annotations-simple-key"></a>[Заметки к данным (простой ключ)](#tab/data-annotations-simple-key)

Заметки к данным можно использовать для настройки того, какое свойство должно использоваться в качестве свойства внешнего ключа для данной связи. Обычно это делается, когда свойство внешнего ключа не обнаруживается по соглашению:

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/Relationships/ForeignKey.cs?name=ForeignKey&highlight=17)]

> [!TIP]  
> `[ForeignKey]` заметку можно поместить в любое свойство навигации в связи. Не требуется переходить к свойству навигации в классе зависимой сущности.

> [!NOTE]
> Свойство, указанное с помощью `[ForeignKey]` свойства навигации, не обязательно должно существовать в зависимом типе. В этом случае для создания теневого внешнего ключа будет использоваться указанное имя.

---

#### <a name="shadow-foreign-key"></a>Теневой внешний ключ

Можно использовать перегрузку строк `HasForeignKey(...)`, чтобы настроить свойство теневого копирования в качестве внешнего ключа (Дополнительные сведения см. в разделе [Свойства тени](shadow-properties.md) ). Рекомендуется явно добавить свойство Shadow в модель, прежде чем использовать ее как внешний ключ (как показано ниже).

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/ShadowForeignKey.cs?name=ShadowForeignKey&highlight=10,16)]

#### <a name="foreign-key-constraint-name"></a>Имя ограничения внешнего ключа

По соглашению при нацеливании на реляционную базу данных ограничения внешнего ключа именуются FK_<dependent type name> _<principal type name>_ <foreign key property name>. Для составных внешних ключей <foreign key property name> преобразуется в список имен свойств внешнего ключа с разделителями подчеркивания.

Имя ограничения также можно настроить следующим образом:

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/ConstraintName.cs?name=ConstraintName&highlight=6-7)]

### <a name="without-navigation-property"></a>Без свойства навигации

Указывать свойство навигации не обязательно. Можно просто предоставить внешний ключ на одной стороне связи.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/NoNavigation.cs?name=NoNavigation&highlight=8-11)]

### <a name="principal-key"></a>Основной ключ

Если требуется, чтобы внешний ключ ссылался на свойство, отличное от первичного ключа, можно использовать API Fluent, чтобы настроить свойство ключа субъекта для связи. Свойство, настраиваемое в качестве ключа участника, будет автоматически настроено в качестве [альтернативного ключа](alternate-keys.md).

#### <a name="simple-keytabsimple-key"></a>[Простой ключ](#tab/simple-key)

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/PrincipalKey.cs?name=PrincipalKey&highlight=11)]

#### <a name="composite-keytabcomposite-key"></a>[Составной ключ](#tab/composite-key)

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/CompositePrincipalKey.cs?name=CompositePrincipalKey&highlight=11)]

> [!WARNING]  
> Порядок указания свойств ключа субъекта должен совпадать с порядком, в котором они указаны для внешнего ключа.

---

### <a name="required-and-optional-relationships"></a>Обязательные и необязательные связи

С помощью API-интерфейса Fluent можно настроить, является ли связь обязательной или необязательной. В конечном итоге это определяет, является ли свойство внешнего ключа обязательным или необязательным. Это наиболее полезно при использовании внешнего ключа теневого состояния. Если у вас есть свойство внешнего ключа в классе сущностей, обязательность связи определяется на основе того, является ли свойство внешнего ключа обязательным или необязательным (Дополнительные сведения см. в разделе [обязательные и необязательные свойства](required-optional.md) ).

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/Required.cs?name=Required&highlight=6)]

> [!NOTE]
> Вызов `IsRequired(false)` также делает свойство внешнего ключа необязательным, если оно не настроено в противном случае.

### <a name="cascade-delete"></a>Каскадное удаление

Для явной настройки поведения каскадного удаления для данной связи можно использовать API Fluent.

Подробное описание каждого варианта см. в разделе [каскадное удаление](../saving/cascade-delete.md) .

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/CascadeDelete.cs?name=CascadeDelete&highlight=6)]

## <a name="other-relationship-patterns"></a>Другие шаблоны отношений

### <a name="one-to-one"></a>Один к одному

Связь «один к одному» имеет свойство навигации «ссылка» на обеих сторонах. Они следуют тем же соглашениям, что и отношения "один ко многим", но уникальный индекс вводится в свойство внешнего ключа, чтобы гарантировать, что только один зависимый объект связан с каждым участником.

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/Relationships/OneToOne.cs?name=OneToOne&highlight=6,15-16)]

> [!NOTE]  
> EF выберет одну из сущностей, которая будет зависимой, исходя из возможности обнаружения свойства внешнего ключа. Если в качестве зависимого объекта выбрана неверная сущность, можно исправить это с помощью API-интерфейса Fluent.

При настройке связи с помощью API-интерфейса Fluent вы используете методы `HasOne` и `WithOne`.

При настройке внешнего ключа необходимо указать тип зависимой сущности — Обратите внимание на универсальный параметр, предоставленный для `HasForeignKey` в списке ниже. В связи «один ко многим» ясно, что сущность с навигацией по ссылке является зависимой, а она является участником коллекции. Но это не так в связи «один к одному», поэтому необходимо явно определить его.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/OneToOne.cs?name=OneToOne&highlight=11)]

### <a name="many-to-many"></a>"Многие ко многим"

Связи «многие ко многим» без класса сущности для представления таблицы соединений пока не поддерживаются. Однако можно представить связь «многие ко многим», включив класс сущности для таблицы Join и составляя две отдельные связи «один ко многим».

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Relationships/ManyToMany.cs?name=ManyToMany&highlight=11-14,16-19,39-46)]
