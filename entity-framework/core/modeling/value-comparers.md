---
title: Компараторы значений — EF Core
description: Использование компараторов значений для управления EF Core сравнения значений свойств
author: ajcvickers
ms.date: 01/16/2021
uid: core/modeling/value-comparers
ms.openlocfilehash: 9318b41479b43b327c76a11cc99b4f7695fa88d3
ms.sourcegitcommit: 4798ab8d04c1fdbe6dd204d94d770fcbf309d09b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/11/2021
ms.locfileid: "103023904"
---
# <a name="value-comparers"></a>Компараторы значений

> [!NOTE]
> Эта возможность появилась в EF Core 3.0.

> [!TIP]
> Код в этом документе можно найти на сайте GitHub в качестве [готового к запуску примера](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Modeling/ValueConversions/).

## <a name="background"></a>Фон

[Отслеживание изменений](xref:core/change-tracking/index) означает, что EF Core автоматически определяет, какие изменения были выполнены приложением на загруженном экземпляре сущности, чтобы эти изменения можно было сохранить обратно в базу данных при <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> вызове метода. EF Core обычно выполняет это путем *создания моментального снимка* экземпляра при его загрузке из базы данных и *сравнения* этого моментального снимка с экземпляром приложения.

EF Core поставляется со встроенной логикой для значит и сравнивает большинство стандартных типов, используемых в базах данных, поэтому пользователям обычно не нужно беспокоиться об этом разделе. Однако если свойство сопоставлено через [преобразователь значений](xref:core/modeling/value-conversions), EF Core необходимо выполнить сравнение с произвольными типами пользователей, что может быть сложным. По умолчанию EF Core использует сравнение на равенство по умолчанию, определенное типами (например, `Equals` метод); для значит [типы значений](/dotnet/csharp/language-reference/builtin-types/value-types) копируются для создания моментального снимка, а для [ссылочных типов](/dotnet/csharp/language-reference/keywords/reference-types) не выполняется копирование, и в качестве моментального снимка используется тот же экземпляр.

В случаях, когда встроенное поведение сравнения не подходит, пользователи могут предоставить *компаратор значений*, который содержит логику для значит, сравнив и вычисляя хэш-код. Например, следующая строка устанавливает преобразование значения для `List<int>` свойства в значение, преобразованное в строку JSON в базе данных, а также определяет соответствующий компаратор значений.

[!code-csharp[ListProperty](../../../samples/core/Modeling/ValueConversions/MappingListProperty.cs?name=ConfigureListProperty)]

Дополнительные сведения см. в разделе [Изменяемые классы](#mutable-classes) ниже.

Обратите внимание, что компараторы значений также используются при определении того, совпадают ли два значения ключа при разрешении связей. Это объясняется ниже.

## <a name="shallow-vs-deep-comparison"></a>Неполное и глубокое сравнение

Для небольших неизменяемых типов значений, таких как `int` , логика по умолчанию EF Core работает правильно: значение копируется как есть при снапшоттед и сравнивается со встроенным сравнением равенства типа. При реализации собственного компаратора значений важно учитывать, подходит ли логика глубокого или неглубокого сравнения (и значит).

Рассмотрите возможность использовать массивы байтов, которые могут иметь произвольное большое число. Это можно сравнить:

* По ссылке, что различие обнаруживается только при использовании нового массива байтов
* По глубокому сравнению, что обнаружено изменение байтов в массиве

По умолчанию EF Core использует первый из этих подходов для неключевых массивов байтов. То есть сравниваются только ссылки, а изменение обнаруживается только в том случае, если существующий массив байтов заменяется новым. Это практичное решение, которое позволяет избежать копирования целых массивов и сравнения их байтов в байтах при выполнении <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> . Это означает, что распространенный сценарий замены, скажем, одного изображения с другим, обрабатывается по своему принципу.

С другой стороны, равенство ссылок не будет работать, если массивы байтов используются для представления двоичных ключей, так как очень маловероятно, чтобы свойство FK было задано тем _же экземпляром_ , что и свойство PK, для которого требуется сравнение. Таким образом, EF Core использует глубокие сравнения для массивов байтов, действующих в качестве ключей. Это вряд ли пострадает от снижения производительности, так как обычно двоичные ключи являются короткими.

Обратите внимание, что выбранная логика сравнения и значита должна соответствовать друг другу: чтобы обеспечить правильное функционирование, для глубокого сравнения требуется глубокий значит.

## <a name="simple-immutable-classes"></a>Простые неизменяемые классы

Рассмотрим свойство, которое использует преобразователь значений для отображения простого, неизменяемого класса.

[!code-csharp[SimpleImmutableClass](../../../samples/core/Modeling/ValueConversions/MappingImmutableClassProperty.cs?name=SimpleImmutableClass)]

[!code-csharp[ConfigureImmutableClassProperty](../../../samples/core/Modeling/ValueConversions/MappingImmutableClassProperty.cs?name=ConfigureImmutableClassProperty)]

Свойства этого типа не требуют специальных сравнений или моментальных снимков, поскольку:

* Равенство переопределяется, так что различные экземпляры будут сравниваться правильно
* Тип является неизменяемым, поэтому невозможно изменить значение моментального снимка

Поэтому в этом случае поведение EF Core по умолчанию отлично от.

## <a name="simple-immutable-structs"></a>Простые неизменяемые структуры

Сопоставление простых структур также является простым и не требует специальных компараторов или значит.

[!code-csharp[SimpleImmutableStruct](../../../samples/core/Modeling/ValueConversions/MappingImmutableStructProperty.cs?name=SimpleImmutableStruct)]

[!code-csharp[ConfigureImmutableStructProperty](../../../samples/core/Modeling/ValueConversions/MappingImmutableStructProperty.cs?name=ConfigureImmutableStructProperty)]

EF Core имеет встроенную поддержку создания скомпилированных, почленном сравнений свойств структуры. Это означает, что структуры не требуют переопределения равенства для EF Core, но вы по-прежнему можете выбрать это по [другим причинам](/dotnet/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type). Кроме того, Специальные значит не нужны, так как структуры являются неизменяемыми и всегда копируются почленном в любом случае. (Это также справедливо для изменяемых структур, но [в общем случае изменяющиеся структуры следует избегать](/dotnet/csharp/write-safe-efficient-code).)

## <a name="mutable-classes"></a>Изменяемые классы

Рекомендуется использовать неизменяемые типы (классы или структуры) с преобразователями значений, если это возможно. Обычно это более эффективно и имеет семантику очистки, чем использование изменяемого типа. Тем не менее, часто используются свойства типов, которые приложение не может изменять. Например, сопоставление свойства, содержащего список чисел:

[!code-csharp[ListProperty](../../../samples/core/Modeling/ValueConversions/MappingListProperty.cs?name=ListProperty)]

Класс <xref:System.Collections.Generic.List%601>:

* Имеет равенство ссылок; два списка, содержащие одни и те же значения, рассматриваются как разные.
* Является изменяемым; значения в списке можно добавлять и удалять.

Стандартное преобразование значения для свойства списка может привести к преобразованию списка в JSON и из него:

### <a name="ef-core-50"></a>[EF Core 5.0](#tab/ef5)

[!code-csharp[ListProperty](../../../samples/core/Modeling/ValueConversions/MappingListProperty.cs?name=ConfigureListProperty&highlight=7-10)]

### <a name="older-versions"></a>[Более старые версии](#tab/older-versions)

[!code-csharp[ListProperty](../../../samples/core/Modeling/ValueConversions/MappingListPropertyOld.cs?name=ConfigureListProperty&highlight=8-11,17)]

***

<xref:Microsoft.EntityFrameworkCore.ChangeTracking.ValueComparer%601>Конструктор принимает три выражения:

* Выражение для проверки равенства
* Выражение для создания хэш-кода
* Выражение для создания снимка значения

В этом случае сравнение выполняется путем проверки того, совпадают ли последовательности чисел.

Аналогичным образом хэш-код строится из этой же последовательности. (Обратите внимание, что это хэш-код для изменяемых значений и, следовательно, может [вызвать проблемы](https://ericlippert.com/2011/02/28/guidelines-and-rules-for-gethashcode/). Быть неизменяемым вместо этого, если это возможно.)

Моментальный снимок создается путем клонирования списка с помощью `ToList` . Опять же, это необходимо, только если списки будут изменяться. Быть неизменяемым вместо этого, если это возможно.

> [!NOTE]
> Преобразователи значений и компараторы создаются с помощью выражений, а не простых делегатов. Это связано с тем, что EF Core вставляет эти выражения в гораздо более сложное дерево выражения, которое затем компилируется в делегат сущности-фигуры. По сути, это похоже на встраивание компилятора. Например, простое преобразование может быть просто скомпилированным в приведении, а не вызовом другого метода для преобразования.

## <a name="key-comparers"></a>Ключевые компараторы

В разделе Background описывается, почему для сравнения ключей может потребоваться специальная семантика. Обязательно создайте средство сравнения, которое подходит для ключей при его задании в свойстве первичного, основного или внешнего ключа.

Используйте <xref:Microsoft.EntityFrameworkCore.MutablePropertyExtensions.SetKeyValueComparer%2A> в редких случаях, когда для одного свойства требуется другая семантика.

> [!NOTE]
> <xref:Microsoft.EntityFrameworkCore.MutablePropertyExtensions.SetStructuralValueComparer%2A> является устаревшим в EF Core 5,0. Используйте вместо этого <xref:Microsoft.EntityFrameworkCore.MutablePropertyExtensions.SetKeyValueComparer%2A>.

## <a name="overriding-the-default-comparer"></a>Переопределение компаратора по умолчанию

Иногда сравнение по умолчанию, используемое EF Core, может быть неприменимо. Например, изменение массивов байтов по умолчанию не определяется в EF Core. Это можно переопределить, задав другое средство сравнения для свойства:

[!code-csharp[OverrideComparer](../../../samples/core/Modeling/ValueConversions/OverridingByteArrayComparisons.cs?name=OverrideComparer)]

EF Core теперь будет сравнивать последовательности байтов и, следовательно, определит изменения массива байтов.
