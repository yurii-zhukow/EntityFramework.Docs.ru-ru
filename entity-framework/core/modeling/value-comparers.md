---
title: Компараторы значений — EF Core
description: Использование компараторов значений для управления EF Core сравнения значений свойств
author: ajcvickers
ms.date: 03/20/2020
uid: core/modeling/value-comparers
ms.openlocfilehash: d59ab093c7e9d251aac80420972d3e35edabae0b
ms.sourcegitcommit: 788a56c2248523967b846bcca0e98c2ed7ef0d6b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/20/2020
ms.locfileid: "95003618"
---
# <a name="value-comparers"></a>Компараторы значений

> [!NOTE]  
> Эта функция появилась в EF Core 3,0.

> [!TIP]  
> Код в этом документе можно найти на сайте GitHub в качестве [готового к запуску примера](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Modeling/ValueConversions/).

## <a name="background"></a>Фон

EF Core необходимо сравнить значения свойств, если:

* Определение, было ли изменено свойство в процессе [обнаружения изменений для обновлений](xref:core/saving/basic)
* Определение того, совпадают ли два значения ключа при разрешении связей

Он обрабатывается автоматически для распространенных типов примитивов, таких как int, bool, DateTime и т. д.

Для более сложных типов необходимо выбрать способ сравнения.
Например, можно сравнить массив байтов:

* По ссылке, что различие обнаруживается только при использовании нового массива байтов
* По глубокому сравнению, что обнаружено изменение байтов в массиве

По умолчанию EF Core использует первый из этих подходов для неключевых массивов байтов.
То есть сравниваются только ссылки, а изменение обнаруживается только в том случае, если существующий массив байтов заменяется новым.
Это практичное решение, которое позволяет избежать глубокого сравнения большого числа больших массивов байтов при выполнении команды SaveChanges.
Но распространенный сценарий замены, скажем, изображения с другим изображением, обрабатывается по-своему.

С другой стороны, равенство ссылок не будет работать, если массивы байтов используются для представления двоичных ключей.
Очень маловероятно, чтобы свойство FK было равно тому _же экземпляру_ , что и свойство PK, для которого требуется сравнение.
Таким образом, EF Core использует глубокие сравнения для массивов байтов, действующих в качестве ключей.
Это вряд ли пострадает от снижения производительности, так как обычно двоичные ключи являются короткими.

### <a name="snapshots"></a>Моментальные снимки

Углубленное сравнение изменяемых типов означает, что EF Core требуется возможность создания глубокого моментального снимка значения свойства.
Просто копирование ссылки приведет к изменению текущего значения и моментального снимка, так как они являются одним и тем _же объектом_.
Таким образом, если для изменяемых типов используются глубокие сравнения, также требуется глубокий значит.

## <a name="properties-with-value-converters"></a>Свойства с преобразователями значений

В приведенном выше случае EF Core имеет встроенную поддержку сопоставления для массивов байтов, поэтому может автоматически выбирать соответствующие значения по умолчанию.
Однако если свойство сопоставлено через [преобразователь значений](xref:core/modeling/value-conversions), то EF Core не всегда может определить соответствующее сравнение для использования.
Вместо этого EF Core всегда использует сравнение на равенство по умолчанию, определенное типом свойства.
Это часто верно, но при сопоставлении более сложных типов может потребоваться переопределение.

### <a name="simple-immutable-classes"></a>Простые неизменяемые классы

Рассмотрим свойство, которое использует преобразователь значений для отображения простого, неизменяемого класса.

[!code-csharp[SimpleImmutableClass](../../../samples/core/Modeling/ValueConversions/MappingImmutableClassProperty.cs?name=SimpleImmutableClass)]

[!code-csharp[ConfigureImmutableClassProperty](../../../samples/core/Modeling/ValueConversions/MappingImmutableClassProperty.cs?name=ConfigureImmutableClassProperty)]

Свойства этого типа не требуют специальных сравнений или моментальных снимков, поскольку:

* Равенство переопределяется, так что различные экземпляры будут сравниваться правильно
* Тип является неизменяемым, поэтому невозможно изменить значение моментального снимка

Поэтому в этом случае поведение EF Core по умолчанию отлично от.

### <a name="simple-immutable-structs"></a>Простые неизменяемые структуры

Сопоставление простых структур также является простым и не требует специальных компараторов или значит.

[!code-csharp[SimpleImmutableStruct](../../../samples/core/Modeling/ValueConversions/MappingImmutableStructProperty.cs?name=SimpleImmutableStruct)]

[!code-csharp[ConfigureImmutableStructProperty](../../../samples/core/Modeling/ValueConversions/MappingImmutableStructProperty.cs?name=ConfigureImmutableStructProperty)]

EF Core имеет встроенную поддержку создания скомпилированных, почленном сравнений свойств структуры.
Это означает, что структуры не требуют переопределения равенства для EF, но вы по-прежнему можете выбрать это по [другим причинам](/dotnet/csharp/programming-guide/statements-expressions-operators/how-to-define-value-equality-for-a-type).
Кроме того, Специальные значит не требуются, так как структуры неизменяемы и всегда почленном копируются.
(Это также справедливо для изменяемых структур, но [в общем случае изменяющиеся структуры следует избегать](/dotnet/csharp/write-safe-efficient-code).)

### <a name="mutable-classes"></a>Изменяемые классы

Рекомендуется использовать неизменяемые типы (классы или структуры) с преобразователями значений, если это возможно.
Обычно это более эффективно и имеет семантику очистки, чем использование изменяемого типа.

Тем не менее, часто используются свойства типов, которые приложение не может изменять.
Например, сопоставление свойства, содержащего список чисел:

[!code-csharp[ListProperty](../../../samples/core/Modeling/ValueConversions/MappingListProperty.cs?name=ListProperty)]

[ `List<T>` Класс](/dotnet/api/system.collections.generic.list-1):

* Имеет равенство ссылок; два списка, содержащие одни и те же значения, рассматриваются как разные.
* Является изменяемым; значения в списке можно добавлять и удалять.

Стандартное преобразование значения для свойства списка может привести к преобразованию списка в JSON и из него:

[!code-csharp[ConfigureListProperty](../../../samples/core/Modeling/ValueConversions/MappingListProperty.cs?name=ConfigureListProperty)]

После этого необходимо задать для `ValueComparer<T>` свойства значение, чтобы принудительно EF Core использовать правильные сравнения с этим преобразованием:

[!code-csharp[ConfigureListPropertyComparer](../../../samples/core/Modeling/ValueConversions/MappingListProperty.cs?name=ConfigureListPropertyComparer)]

> [!NOTE]  
> API-интерфейс конструктора моделей ("Fluent") для установки компаратора значений еще не реализован.
> Вместо этого код вызывает Сетвалуекомпарер на Имутаблепроперти низкого уровня, предоставляемый построителем как "Metadata".

`ValueComparer<T>`Конструктор принимает три выражения:

* Выражение для проверки равенства
* Выражение для создания хэш-кода
* Выражение для создания снимка значения  

В этом случае сравнение выполняется путем проверки того, совпадают ли последовательности чисел.

Аналогичным образом хэш-код строится из этой же последовательности.
(Обратите внимание, что это хэш-код для изменяемых значений и, следовательно, может [вызвать проблемы](https://ericlippert.com/2011/02/28/guidelines-and-rules-for-gethashcode/).
Быть неизменяемым вместо этого, если это возможно.)

Моментальный снимок создается путем клонирования списка с помощью ToList.
Опять же, это необходимо, только если списки будут изменяться.
Быть неизменяемым вместо этого, если это возможно.

> [!NOTE]  
> Преобразователи значений и компараторы создаются с помощью выражений, а не простых делегатов.
> Это обусловлено тем, что EF вставляет эти выражения в гораздо более сложное дерево выражения, которое затем компилируется в делегат сущности-фигуры.
> По сути, это похоже на встраивание компилятора.
> Например, простое преобразование может быть просто скомпилированным в приведении, а не вызовом другого метода для преобразования.

### <a name="key-comparers"></a>Ключевые компараторы

В разделе Background описывается, почему для сравнения ключей может потребоваться специальная семантика.
Обязательно создайте средство сравнения, которое подходит для ключей при его задании в свойстве первичного, основного или внешнего ключа.

Используйте [сеткэйвалуекомпарер](/dotnet/api/microsoft.entityframeworkcore.mutablepropertyextensions.setkeyvaluecomparer) в редких случаях, когда для одного свойства требуется другая семантика.

> [!NOTE]  
> Сетструктуралкомпарер в EF Core 5,0 устарел.
> Вместо этого используйте Сеткэйвалуекомпарер.

### <a name="overriding-defaults"></a>Переопределение параметров по умолчанию

Иногда сравнение по умолчанию, используемое EF Core, может быть неприменимо.
Например, изменение массивов байтов по умолчанию не определяется в EF Core.
Это можно переопределить, задав другое средство сравнения для свойства:

[!code-csharp[OverrideComparer](../../../samples/core/Modeling/ValueConversions/OverridingByteArrayComparisons.cs?name=OverrideComparer)]

EF Core теперь будет сравнивать последовательности байтов и, следовательно, определит изменения массива байтов.
