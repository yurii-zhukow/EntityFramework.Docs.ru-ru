---
title: Свойства сущности — EF Core
description: Настройка и сопоставьте свойства сущности с помощью Entity Framework Core
author: roji
ms.date: 05/27/2020
uid: core/modeling/entity-properties
ms.openlocfilehash: 55c6f31543d4ce3257cf203eaf9fd2191301ea7e
ms.sourcegitcommit: f3512e3a98e685a3ba409c1d0157ce85cc390cf4
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2020
ms.locfileid: "94429600"
---
# <a name="entity-properties"></a>Свойства сущности

Каждый тип сущности в модели имеет набор свойств, которые EF Core будут считывать и записывать данные из базы данных. Если используется реляционная база данных, то свойства сущности сопоставляются со столбцами таблицы.

## <a name="included-and-excluded-properties"></a>Включенные и исключенные свойства

По соглашению все открытые свойства с методом считывания и методом задания будут включаться в модель.

Конкретные свойства можно исключить следующим образом.

### <a name="data-annotations"></a>[Заметки к данным](#tab/data-annotations)

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/IgnoreProperty.cs?name=IgnoreProperty&highlight=6)]

### <a name="fluent-api"></a>[Текучий API](#tab/fluent-api)

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/IgnoreProperty.cs?name=IgnoreProperty&highlight=3,4)]

***

## <a name="column-names"></a>Имена столбцов

По соглашению при использовании реляционной базы данных свойства сущности сопоставляются со столбцами таблицы, имеющими то же имя, что и свойство.

Если вы предпочитаете настраивать столбцы с разными именами, это можно сделать с помощью следующего фрагмента кода:

### <a name="data-annotations"></a>[Заметки к данным](#tab/data-annotations)

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/ColumnName.cs?Name=ColumnName&highlight=3)]

### <a name="fluent-api"></a>[Текучий API](#tab/fluent-api)

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/ColumnName.cs?Name=ColumnName&highlight=3-5)]

**_

## <a name="column-data-types"></a>Типы данных столбцов

При использовании реляционной базы данных поставщик базы данных выбирает тип данных, основанный на типе .NET свойства. Он также учитывает другие метаданные, такие как настроенная [Максимальная длина](#maximum-length), является ли свойство частью первичного ключа и т. д.

Например, SQL Server сопоставляет `DateTime` свойства со `datetime2(7)` столбцами, а `string` свойства — `nvarchar(max)` со столбцами (или для `nvarchar(450)` свойств, которые используются в качестве ключа).

Можно также настроить столбцы, указав для столбца точный тип данных. Например, следующий код настраивает в `Url` качестве строки в формате, отличном от Юникод, максимальную длину `200` и `Rating` в десятичном формате с точностью `5` и масштабом `2` :

### <a name="data-annotations"></a>[Заметки к данным](#tab/data-annotations)

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/ColumnDataType.cs?name=ColumnDataType&highlight=4,6)]

### <a name="fluent-api"></a>[Текучий API](#tab/fluent-api)

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/ColumnDataType.cs?name=ColumnDataType&highlight=5-6)]

_*_

### <a name="maximum-length"></a>Максимальная длина

Настройка максимальной длины предоставляет указание поставщику базы данных о соответствующем типе данных столбца для выбора конкретного свойства. Максимальная длина применяется только к типам данных массива, таким как `string` и `byte[]` .

> [!NOTE]
> Entity Framework не выполняет никаких проверок максимальной длины перед передачей данных поставщику. Поставщик или хранилище данных можно проверить, если это уместно. Например, если целевой объект SQL Server, то превышение максимальной длины приведет к возникновению исключения, так как тип данных базового столбца не позволит сохранить излишние данные.

В следующем примере Настройка максимальной длины 500 приведет к созданию столбца типа, `nvarchar(500)` который будет создан на SQL Server:

#### <a name="data-annotations"></a>[Заметки к данным](#tab/data-annotations)

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/MaxLength.cs?name=MaxLength&highlight=4)]

#### <a name="fluent-api"></a>[Текучий API](#tab/fluent-api)

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/MaxLength.cs?name=MaxLength&highlight=3-5)]

_*_

### <a name="precision-and-scale"></a>Точность и масштаб

Начиная с Ефкоре 5,0 можно использовать API Fluent, чтобы настроить точность и масштаб. Он сообщает поставщику базы данных, какой объем хранилища требуется для данного столбца. Он применяется только к типам данных, где поставщик допускает точность и масштабирование в зависимости от того, как правило `decimal` , и `DateTime` .

Для `decimal` свойств точность определяет максимальное количество цифр, необходимое для выражения любого значения, которое будет содержать столбец, а масштабирование определяет максимальное число требуемых десятичных разрядов. Для `DateTime` свойств точность определяет максимальное количество цифр, необходимое для выражения долей секунд, а масштабирование не используется.

> [!NOTE]
> Entity Framework не выполняет никаких проверок точности или масштабирования перед передачей данных поставщику. Поставщик или хранилище данных должны проверяться соответствующим образом. Например, при нацеливании на SQL Server столбец типа данных `datetime` не позволяет задать точность, тогда как у `datetime2` одной из них может быть точность от 0 до 7 включительно.

В следующем примере `Score` для свойства с точностью 14 и масштабом 2 будет `decimal(14,2)` создаваться столбец типа, который будет создан на SQL Server, а `LastUpdated` для свойства с точностью 3 будет использоваться столбец типа `datetime2(3)` :

#### <a name="data-annotations"></a>[Заметки к данным](#tab/data-annotations)

В настоящее время невозможно настроить точность и масштаб с помощью заметок к данным.

#### <a name="fluent-api"></a>[Текучий API](#tab/fluent-api)

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/PrecisionAndScale.cs?name=PrecisionAndScale&highlight=3-9)]

> [!NOTE]
> Масштаб никогда не определяется без предварительного определения точности, поэтому API-интерфейсом Fluent для определения масштаба является `HasPrecision(precision, scale)` .

_*_

## <a name="required-and-optional-properties"></a>Обязательные и необязательные свойства

Свойство считается необязательным, если оно является допустимым для его хранения `null` . Если `null` значение не является допустимым для присвоения свойству, оно считается обязательным свойством. При сопоставлении со схемой реляционной базы данных обязательные свойства создаются как столбцы, не допускающие значения NULL, а дополнительные свойства создаются как столбцы, допускающие значение null.

### <a name="conventions"></a>Соглашения

По соглашению свойство, тип .NET которого может содержать значение null, будет настроено как необязательный, тогда как свойства, типы .NET которых не могут содержать значение null, будут настроены как обязательные. Например, все свойства с типами значений .NET ( `int` , `decimal` , `bool` и т. д.) настраиваются как обязательные, а все свойства с типами значений .NET, допускающими значение null ( `int?` , `decimal?` , `bool?` и т. д.), настраиваются как необязательные.

В C# 8 появилась новая функция, называемая [обнуляемым ссылочными типами (превентивной)](/dotnet/csharp/tutorials/nullable-reference-types), которая позволяет создавать заметки для ссылочных типов, указывая, является ли он допустимым для того, чтобы они содержали значение null. Эта функция отключена по умолчанию и влияет на поведение EF Core следующим образом.

_ — Если ссылочные типы, допускающие значение null, отключены (по умолчанию), все свойства с ссылочными типами .NET настраиваются как необязательные по соглашению (например, `string` ).
* Если ссылочные типы, допускающие значение null, включены, то свойства будут настроены на основе допустимости значений NULL в C# для их типа .NET: `string?` будут настроены как необязательные, но `string` будут настроены как обязательные.

В следующем примере показан тип сущности с обязательными и необязательными свойствами с отключенной ссылкой, допускающей значение null (по умолчанию) и включенной.

#### <a name="without-nrt-default"></a>[Без ПРЕВЕНТИВНОЙ (по умолчанию)](#tab/without-nrt)

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/CustomerWithoutNullableReferenceTypes.cs?name=Customer&highlight=4-8)]

#### <a name="with-nrt"></a>[С ПРЕВЕНТИВНОЙ](#tab/with-nrt)

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Customer.cs?name=Customer&highlight=4-6)]

***

Рекомендуется использовать ссылочные типы, допускающие значение null, так как она передает возможность принимать нулевое значение, выраженную в коде C#, в модель EF Core и в базу данных, а также устраняет использование заметок к данным в API-интерфейсе или аннотациях данных для выражения дважды.

> [!NOTE]
> Соблюдайте осторожность при включении ссылочных типов, допускающих значение null, в существующем проекте: свойства ссылочного типа, которые ранее были настроены как необязательные, теперь будут настроены как обязательные, если только они не имеют явно заметку null. При управлении схемой реляционной базы данных это может привести к созданию миграции, которые изменяют допустимость значений NULL в столбце базы данных.

Дополнительные сведения о ссылочных типах, допускающих значения NULL, и об их использовании с EF Core [см. на специальной странице документации по этой функции](xref:core/miscellaneous/nullable-reference-types).

### <a name="explicit-configuration"></a>Явная конфигурация

Свойство, которое было бы необязательным по соглашению, может быть настроено следующим образом:

#### <a name="data-annotations"></a>[Заметки к данным](#tab/data-annotations)

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/Required.cs?name=Required&highlight=4)]

#### <a name="fluent-api"></a>[Текучий API](#tab/fluent-api)

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/Required.cs?name=Required&highlight=3-5)]

***

## <a name="column-collations"></a>Параметры сортировки столбцов

> [!NOTE]
> Эта возможность появилась в EF Core 5.0.

Параметры сортировки могут быть определены для текстовых столбцов, определяя, как они сравниваются и упорядочиваются. Например, следующий фрагмент кода настраивает SQL Server столбца, в котором регистр не учитывается:

[!code-csharp[Main](../../../samples/core/Miscellaneous/Collations/Program.cs?range=42-43)]

Если всем столбцам в базе данных необходимо использовать определенные параметры сортировки, то вместо этого определите параметры сортировки на уровне базы данных.

Общие сведения о EF Core поддержки параметров сортировки можно найти на [странице документации по параметрам сортировки](xref:core/miscellaneous/collations-and-case-sensitivity).
