---
title: Перенос приложений из EF6 в EF Core — EF
description: Общие сведения о переносе приложения с Entity Framework 6 в Entity Framework Core
author: ajcvickers
ms.date: 10/27/2016
uid: efcore-and-ef6/porting/index
ms.openlocfilehash: d50def47e65455c8cf5242cad4386f157148c0bc
ms.sourcegitcommit: f3512e3a98e685a3ba409c1d0157ce85cc390cf4
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/10/2020
ms.locfileid: "94429212"
---
# <a name="porting-from-ef6-to-ef-core"></a>Перенос приложений из EF6 в EF Core

Из-за фундаментальных отличий от EF Core мы не рекомендуем переносить приложения EF6 на EF Core, если для этого нет веской причины.
Переход с EF6 на EF Core следует рассматривать как портирование, а не обновление.

> [!IMPORTANT]
> Прежде чем начать перенос, следует убедиться, что EF Core соответствует требованиям приложения к доступу к данным.

## <a name="missing-features"></a>Отсутствующие функции

Убедитесь, что EF Core обладает всеми функциями, которые нужны для использования в приложении. Ознакомьтесь с [подробным сравнением набора функций](xref:efcore-and-ef6/index) EF Core и EF6. Если отсутствуют необходимые функции, перед выполнением переноса в EF Core убедитесь, что вы можете компенсировать их отсутствие.

## <a name="behavior-changes"></a>Изменения в работе

Это не исчерпывающий список некоторых изменений в поведении между EF6 и EF Core. Эти факторы важно учитывать при переносе своего приложения, так как его поведение может измениться. После перехода на EF Core такие изменения не будут отображаться как ошибки компиляции.

### <a name="dbsetaddattach-and-graph-behavior"></a>Поведение методов DbSet.Add и DbSet.Attach и графа

В EF6 при вызове метода `DbSet.Add()` для сущности происходит рекурсивный поиск по всем сущностям, на которые указаны ссылки в свойствах навигации. Все найденные сущности, которые еще не отслеживаются контекстом, также помечаются как добавленные. `DbSet.Attach()` работает так же, за исключением того, что все сущности помечаются как неизмененные.

**EF Core выполняет аналогичный рекурсивный поиск, но с несколько иными правилами.**

* Корневая сущность всегда находится в запрошенном состоянии (added (Добавлено) для `DbSet.Add` и unchanged (Не изменено) для `DbSet.Attach`).
* **Для сущностей, найденных во время рекурсивного поиска свойств навигации:**
  * **Если первичный ключ сущности создан хранилищем**
    * Если первичному ключу не присвоено значение, то устанавливается состояние added. Значение первичного ключа считается не присвоенным, если для типа свойства задано значение CLR по умолчанию (например, `0` для `int`, `null` для `string` и т. д.).
    * Если первичному ключу присвоено значение, то устанавливается состояние unchanged.
  * Если первичный ключ не создан базой данных, то сущность помещается в то же состояние, что и корневая сущность.

### <a name="code-first-database-initialization"></a>Инициализация базы данных с использованием Code First

**В EF6 присутствует множество сложностей при выборе подключения к базе данных и ее инициализации. Вот некоторые из таких правил:**

* Если конфигурация не выполняется, EF6 выберет базу данных в SQL Express или LocalDb.

* Если в файле приложения `App/Web.config` присутствует строка подключения с таким же именем, как у контекста, подключение будет использоваться.

* Если база данных не существует, она будет создана.

* Если ни одной из таблиц модели нет в базе данных, то в базу данных добавляется схема для текущей модели. Если включены миграции, то они используются для создания базы данных.

* Если база данных существует и в EF6 схема была создана ранее, то она проверяется на совместимость с текущей моделью. Если же модель изменилась с момента создания схемы, возникает исключение.

**В EF Core нет таких сложных операций.**

* Подключение к базе данных должно быть явно настроено в коде.

* Инициализация не выполняется. Для применения миграций нужно использовать `DbContext.Database.Migrate()`. Либо используйте `DbContext.Database.EnsureCreated()` и `EnsureDeleted()` для создания или удаления базы данных без применения миграций.

### <a name="code-first-table-naming-convention"></a>Соглашение об именовании таблиц с использованием Code First

EF6 передает имя класса сущности в службу преобразования во множественную форму, чтобы вычислить имя таблицы по умолчанию, с которой сопоставлена сущность.

В EF Core используется имя свойства `DbSet`, в котором предоставлена сущность в производном контексте. Если для сущности нет свойства `DbSet`, используется имя класса.
